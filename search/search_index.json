{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Go","text":"<p>Gi Studies Wiki: A centralized repository offering a wealth of resources and insights for mastering Go programming.</p> <p>A particular but not private repository to centralize all studies about Go and a few famous Go's libraries. It's kind my own documentation about the language. </p>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>Go Expert - FullCycle</li> </ul> <p>*and of course chatGPT </p>"},{"location":"generics/","title":"Generics","text":"<p>Generics enables you to write <code>functions and data structures that work with different types while maintaining type safety</code>. You can define functions and structures that operate on various types without sacrificing the compiler's ability to catch type errors at compile time.</p> Example <p>run command<pre><code>go run src/generics/basic.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n)\nfunc FindMax[T int | float64](data []T) T {\nif len(data) == 0 {\nreturn 0\n}\nmax := data[0]\nfor _, value := range data {\nif value &gt; max {\nmax = value\n}\n}\nreturn max\n}\nfunc main() {\nints := []int{3, 7, 1, 9, 4, 6}\nfloats := []float64{3.14, 2.71, 1.618, 2.718}\nfmt.Println(\"FindMax integer:\", FindMax(ints))\nfmt.Println(\"FindMax float:\", FindMax(floats))\n}\n</code></pre> output<pre><code>FindMax integer: 9\nFindMax float: 3.14\n</code></pre></p>"},{"location":"generics/#combine-multiple-types-constraint","title":"Combine Multiple Types (Constraint)","text":"<p>In Go, <code>generic constraints are a way to specify requirements for the type parameters used in generic functions or data structures</code>. Constraints <code>ensure that the generic code can only be used with types that meet certain criteria</code>.</p> Example <p>run command<pre><code>go run src/generics/constraint.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n)\ntype ValidNumbers interface {\nint | float64\n}\nfunc FindMax[T ValidNumbers](data []T) T {\nif len(data) == 0 {\nreturn 0\n}\nmax := data[0]\nfor _, value := range data {\nif value &gt; max {\nmax = value\n}\n}\nreturn max\n}\nfunc main() {\nints := []int{3, 7, 1, 9, 4, 6}\nfloats := []float64{3.14, 2.71, 1.618, 2.718}\nfmt.Println(\"FindMax integer:\", FindMax(ints))\nfmt.Println(\"FindMax float:\", FindMax(floats))\n}\n</code></pre> output<pre><code>FindMax integer: 9\nFindMax float: 3.14\n</code></pre></p>"},{"location":"generics/#tilde-closer-than-identical-types","title":"Tilde(~) - Closer Than Identical Types","text":"<p>The special tilde (<code>~</code>) symbol, often referred to as the <code>approximation constraint</code>, is used in Go generics to <code>indicate that a type should approximately match one of the specified types or their derived types</code>. <code>Without the tilde, the function or method constrained by generic types would only accept exact types declared in the constraints and not their derived types</code>. The tilde allows for a broader match, including derived types, making your code more flexible and accommodating related types.</p> Example <p>run command<pre><code>go run src/generics/approximation_constraint.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n)\ntype NumberInt int\ntype NumberFloat float64\ntype ValidNumbers interface {\n~int | ~float64\n}\nfunc FindMax[T ValidNumbers](data []T) T {\nif len(data) == 0 {\nreturn 0\n}\nmax := data[0]\nfor _, value := range data {\nif value &gt; max {\nmax = value\n}\n}\nreturn max\n}\nfunc main() {\nints := []NumberInt{3, 7, 1, 9, 4, 6}\nfloats := []NumberFloat{3.14, 2.71, 1.618, 2.718}\nfmt.Println(\"FindMax integer:\", FindMax(ints))\nfmt.Println(\"FindMax float:\", FindMax(floats))\n}\n</code></pre> output<pre><code>FindMax integer: 9\nFindMax float: 3.14\n</code></pre></p>"},{"location":"generics/#comparable","title":"Comparable","text":"<p>In Go generics, you can use the <code>comparable constraint</code> to specify that a type should be comparable. This constraint ensures that the type can be used with comparison operators like <code>==</code> and <code>!=</code>.</p> Example <p>run command<pre><code>go run src/generics/comparable.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc CheckNumbers[T comparable](a T, b T) bool {\nif a == b {\nreturn true\n}\nreturn false\n}\nfunc FindIndex[T comparable](data []T, value T) int {\nfor i, data_value := range data {\nif data_value == value {\nreturn i\n}\n}\nreturn -1\n}\nfunc main() {\nfmt.Println(\"CheckNumbers: \", CheckNumbers(10, 10.5))\nfmt.Println(\"CheckNumbers: \", CheckNumbers(10.5, 10.5))\nints := []int{3, 7, 1, 9, 4, 6}\nfmt.Println(\"FindMax integer:\", FindIndex(ints, 300))\nfmt.Println(\"FindMax integer:\", FindIndex(ints, 9))\nfmt.Println(\"FindMax integer:\", FindIndex(ints, 10))\n}\n</code></pre> output<pre><code>CheckNumbers:  false\nCheckNumbers:  true\nFindMax integer: -1\nFindMax integer: 3\nFindMax integer: -1\n</code></pre></p>"},{"location":"generics/#references","title":"References","text":"<ul> <li>An Introduction to Generics in Go</li> </ul>"},{"location":"pointers/","title":"Pointers","text":"<p>In Go, pointers are <code>variables that store memory addresses</code>. <code>They are used to reference values rather than holding the values themselves</code>. It allows you to <code>indirectly access and modify the value of the variable</code> it points to. Pointers are represented using the <code>*</code> symbol.</p> <p>To <code>access the value that a pointer points to</code>, you can use the <code>*</code> symbol again. This is called <code>dereferencing the pointer</code>. The <code>&amp;</code> operator is <code>used to obtain the memory address of a variable</code>. This memory address is also known as a pointer.</p> <p>Example</p> <p>run command<pre><code>go run src/structs/pointers.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nx := 42\nfmt.Println(\"Value of x: \", x)\nptr := &amp;x\nfmt.Println(\"Value that ptr point to: \", *ptr)\nfmt.Println(\"Memory address of ptr: \", ptr)\n*ptr = 100\nfmt.Println(\"Updated value of x: \", x)\n}\n</code></pre> output<pre><code>Value of x:  42\nValue that ptr point to:  42\nMemory address of ptr:  0xc0000120f0\nUpdated value of x:  100\n</code></pre></p>"},{"location":"basics/go_cli/","title":"Go CLI","text":""},{"location":"basics/go_cli/#go-environment-command","title":"Go Environment Command","text":"<p>Lists all Go <code>environment variables</code>.</p> <p>Info</p> <pre><code>go env\n</code></pre> go env output <pre><code>GO111MODULE=''\nGOARCH='amd64'\nGOBIN=''\nGOCACHE='/home/gabriel/.cache/go-build'\nGOENV='/home/gabriel/.config/go/env'\nGOEXE=''\nGOEXPERIMENT=''\nGOFLAGS=''\nGOHOSTARCH='amd64'\nGOHOSTOS='linux'\nGOINSECURE=''\nGOMODCACHE='/home/gabriel/go/pkg/mod'\nGONOPROXY=''\nGONOSUMDB=''\nGOOS='linux'\nGOPATH='/home/gabriel/go'\nGOPRIVATE=''\nGOPROXY='https://proxy.golang.org,direct'\nGOROOT='/usr/local/go'\nGOSUMDB='sum.golang.org'\nGOTMPDIR=''\nGOTOOLCHAIN='auto'\nGOTOOLDIR='/usr/local/go/pkg/tool/linux_amd64'\nGOVCS=''\nGOVERSION='go1.21.1'\nGCCGO='gccgo'\nGOAMD64='v1'\nAR='ar'\nCC='gcc'\nCXX='g++'\nCGO_ENABLED='1'\nGOMOD='/dev/null'\nGOWORK=''\nCGO_CFLAGS='-O2 -g'\nCGO_CPPFLAGS=''\nCGO_CXXFLAGS='-O2 -g'\nCGO_FFLAGS='-O2 -g'\nCGO_LDFLAGS='-O2 -g'\nPKG_CONFIG='pkg-config'\nGOGCCFLAGS='-fPIC -m64 -pthread -Wl,--no-gc-sections -fmessage-length=0 -ffile-prefix-map=/tmp/go-build4097433368=/tmp/go-build -gno-record-gcc-switches'\n</code></pre>"},{"location":"basics/go_cli/#gopath","title":"GOPATH","text":"<p><code>GOPATH</code> is a variable that <code>defines the root of your workspace</code>. It stores your code base and all the files necessary for your development. <code>It also contains the binaries of your compilations and the libraries used.</code></p>"},{"location":"basics/go_cli/#gomodcache","title":"GOMODCACHE","text":"<p><code>GOMODCACHE</code> is related to <code>Go module management</code>, which is used for handling dependencies. It is <code>typically a subfolder within your GOPATH</code>.</p>"},{"location":"basics/go_cli/#go-mod","title":"Go mod","text":"<p>Info</p> <pre><code>go mod init example.com/module\n</code></pre> <p>This command <code>initializes a new module with the specified name</code>. You can then <code>add dependencies to the module using the go get command and manage the module's requirements through the go.mod file</code>.</p>"},{"location":"basics/go_paradigm/","title":"Go's Paradigms","text":"<p>Go aims to be both simple and powerful, with the goal of enhancing programmers' productivity. <code>It boasts a straightforward and consistent syntax that remains stable across versions, ensuring compatibility</code>. One of Go's standout features is its robust support for concurrency. <code>It is designed to efficiently leverage multicore processors and excel in handling network-related tasks</code>. In terms of typing, <code>Go follows a static and strong typing system</code>. Here are some key aspects of Go's paradigms and its way of work:</p> <ol> <li>Concurrent and Structured Programming;</li> <li>Static and Strong Typing;</li> </ol>"},{"location":"basics/packages/","title":"Packages and Modules","text":""},{"location":"basics/packages/#packages","title":"Packages","text":"<p>Every <code>.go file begins with the package command</code>, and the <code>package's name should match the directory in which the file resides</code>. The exceptions to this rule are <code>package main</code> and <code>package test</code> which serve as the entry points for applications and tests, respectively. <code>Packages within the same directory should share the same package name. Anything within the same package can be accessed and utilized</code>.</p> Simple package example <p>run command<pre><code>go run src/packages/*\n</code></pre> src/packages/nice_func.go<pre><code>package main\nfunc nice_func() {\nprintln(\"   I'm on the same directory than main, so my package has to be main\")\n}\n</code></pre> src/packages/main.go<pre><code>package main\nfunc main() {\nprintln(\"Starting script\")\nprintln(\"Now, calling nice_func that is defined from the same file directory, on nice_func.go file\")\nnice_func()\n}\n</code></pre> output<pre><code>Starting script\nNow, calling nice_func that is defined from the same file directory, on nice_func.go file\n    I'm on the same directory than main, so my package has to be main\n</code></pre></p>"},{"location":"basics/packages/#modules","title":"Modules","text":"<p>In Go, a <code>module is a collection of related Go packages that are versioned together as a single unit</code>. Modules are the key component of the Go module system, <code>introduced to manage package dependencies and versioning</code>.</p> <p>A Go module typically consists of one or more Go packages, a<code>long with a go.mod file that defines the module's requirements and dependencies</code>. The go.mod file keeps track of the module's dependencies, versions, and the other modules it requires.</p> <p>To create a new module in Go, you can use the go mod init command followed by the name of the module.</p> <p>Public and Private Access</p> <p>In Go, the concept of <code>public and private access is determined by the first letter's case of a variable or function name</code>. If the first letter of an identifier is in <code>uppercase</code>, it is <code>exported and can be accessed from other packages</code>. On the other hand, if the first letter is <code>lowercase</code>, the identifier is considered <code>unexported and can only be accessed within the same package</code>.</p> <p>This convention helps maintain encapsulation and ensures that package-level variables and functions are used only where intended.</p> Example <p>run command<pre><code>cd src/modules/\ngo run main.go\n</code></pre> src/modules/mathpackage/mathpackage.go<pre><code>package mathpackage\nimport \"fmt\"\nfunc sum[T int | float64](a, b T) T {\nfmt.Println(\"   Accessing sum function. Private to mathpackage\")\nreturn a + b\n}\nfunc SumInt(a, b int) int {\nreturn sum(a, b)\n}\nfunc SumFloat(a, b float64) float64 {\nreturn sum(a, b)\n}\n</code></pre> src/modules/car_package/car_package.go<pre><code>package carpackage\nimport (\n\"time\"\n)\ntype Car struct {\nName     string\nNickName string\nYear     int\n}\ntype fullCarPrivate struct {\nFullName string\nYear     int\nYearOld  int\n}\nfunc (c Car) CreateFullCar() fullCarPrivate {\nyearNow := time.Now().Year()\nfinalCar := fullCarPrivate{\nFullName: c.Name + \" \" + c.NickName,\nYear:     c.Year,\nYearOld:  yearNow - c.Year,\n}\nreturn finalCar\n}\n</code></pre> src/modules/main.go<pre><code>package main\nimport (\n\"fmt\"\ncarpackage \"start/modules/car_package\"\n\"start/modules/mathpackage\"\n)\nfunc main() {\nintSum := mathpackage.SumInt(50, 21)\nfmt.Println(\"Result of SumInt: \", intSum)\nfloatSum := mathpackage.SumFloat(3.14, 17.8)\nfmt.Println(\"Result of SumFloat: \", floatSum)\nfmt.Println(\"****\")\nfmt.Println(\"Starting explore Car Module\")\ncar := carpackage.Car{\nName:     \"Corolla\",\nNickName: \"Giant car\",\nYear:     2020,\n}\nfullCar := car.CreateFullCar()\nfmt.Println(\"Full Car name: \", fullCar.FullName)\nfmt.Println(\"Full Car Years Old: \", fullCar.YearOld)\n}\n</code></pre> output<pre><code>    Accessing sum function. Private to mathpackage\nResult of SumInt:  71\nAccessing sum function. Private to mathpackage\nResult of SumFloat:  20.94\n****\nStarting explore Car Module\nFull Car name:  Corolla Giant car\nFull Car Years Old:  3\n</code></pre></p>"},{"location":"basics/packages/#references","title":"References","text":"<ul> <li>Go Expert - FullCycle</li> </ul>"},{"location":"basics/vars/","title":"Variables and Data Types","text":"<p>In Go, <code>variables and constants are strongly typed</code>. To declare a constant, you use the <code>const</code> keyword, and for variables, you use <code>var</code>.</p> <p>Go can also <code>automatically infer variable types</code>, providing various syntaxes for declaring variables and constants, as shown below.</p> Simple vars example <p>run command<pre><code>go run src/variables/*\n</code></pre> <pre><code>package main\nconst A = \"I'm a constant\"\nvar B bool\nfunc main() {\nprintln(\"Starting basic variables\")\nprint(\"Print A const: \")\nprintln(A)\nprint(\"Print B var: \")\nprintln(B)\nprintln(\"NOTICE: B was infer as false\")\nprintln()\nprintln(\"Different ways to declare a variable: \")\nvar full_declare string = \"A\"\nprintln(\"Full declaration: \" + full_declare)\nshort_hand := \"B\"\nprintln(\"Short hand: \" + short_hand)\n}\n</code></pre> output<pre><code>Starting basic variables\nPrint A const: I'm a constant\nPrint B var: false\nNOTICE: B was infer as false\nDifferent ways to declare a variable:\nFull declaration: A\nShort hand: B\n</code></pre></p> Checking Default Infered Types <p>run command<pre><code>go run variables/infer_types.go </code></pre> <pre><code>package main\nvar (\nb  bool\nc  int\nd  string\ne  float32\ne6 float64\n)\nfunc main() {\nprint(\"bool \")\nprintln(b)\nprint(\"int \")\nprintln(c)\nprint(\"string \")\nprintln(d)\nprint(\"float32 \")\nprintln(e)\nprint(\"float64 \")\nprintln(e6)\n}\n</code></pre> output<pre><code>bool false\nint 0\nstring float32 +0.000000e+000\nfloat64 +0.000000e+000\n</code></pre></p>"},{"location":"basics/vars/#using-type","title":"Using type","text":"<p>In Go the <code>type</code> keyword is used to <code>define custom data types</code>. These custom types can be based on existing types, making it a versatile feature in the language.</p> Using type <p>run command<pre><code>go run variables/using_type.go\n</code></pre> <pre><code>package main\ntype custom_id string\nfunc main() {\ncustom_id := \"e96d759e-dc59-4394-9feb-79c8bf4130c9\"\nprintln(\"custom_id value: \" + custom_id)\n}\n</code></pre> output<pre><code>custom_id value: e96d759e-dc59-4394-9feb-79c8bf4130c9\n</code></pre></p>"},{"location":"basics/vars/#arrays","title":"Arrays","text":"<p>In Go, an array is a <code>fixed-size collection of elements of the same type</code>. Arrays are declared with a specific size, and that <code>size cannot be changed after the array is created</code>.</p> Example <p>run command<pre><code>go run variables/arrays.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvar myArray [3]int\nmyArray[1] = 10\nmyArray[2] = 20\nfmt.Println(myArray[0])\nfmt.Println(myArray)\nfor i, value := range myArray {\nfmt.Printf(\"Value stored in %d index is %d\\n\", i, value)\n}\ninitArray := [3]string{\"apple\", \"banana\", \"cherry\"}\nfor i, value := range initArray {\nfmt.Printf(\"Value stored in %d index is %v\\n\", i, value)\n}\n}\n</code></pre> output<pre><code>0\n[0 10 20]\nValue stored in 0 index is 0\nValue stored in 1 index is 10\nValue stored in 2 index is 20\nValue stored in 0 index is apple\nValue stored in 1 index is banana\nValue stored in 2 index is cherry\n</code></pre></p>"},{"location":"basics/vars/#slices","title":"Slices","text":"<p>In Go, a slice is a <code>more versatile and dynamic alternative to arrays</code>. Slices are like views into an underlying array, allowing you to work with a portion of an a<code>rray without specifying a fixed size</code>. Slices allow you to perform operations like appending elements, slicing (creating sub-slices), and growing dynamically.</p> <p>Slices also have a <code>length and capacity</code> (the maximum number of elements it can hold without reallocation). Use the <code>len()</code> and <code>cap()</code> functions to get these values.</p> Example <p>run command<pre><code>go run variables/slices.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nmy_slice := []int{10, 20, 30, 40, 50, 60}\nfmt.Println(\"Full slice: \", my_slice)\nfirst_three_elem := my_slice[0:3]\nfmt.Println(\"First 3 elements: \", first_three_elem)\nfmt.Printf(\"my_slice    = len=%d cap=%d %v\\n\", len(my_slice), cap(my_slice), my_slice)\nnone_value := my_slice[:0]\nfmt.Printf(\"none_value  = len=%d cap=%d %v\\n\", len(none_value), cap(none_value), none_value)\nfirst_four := my_slice[:4]\nfmt.Printf(\"first_four  = len=%d cap=%d %v\\n\", len(first_four), cap(first_four), first_four)\nskip_two_first := my_slice[2:]\nfmt.Printf(\"last_two    = len=%d cap=%d %v\\n\", len(skip_two_first), cap(skip_two_first), skip_two_first)\nmy_slice = append(my_slice, 70)\nfmt.Println(\"my_slice with 70: \", my_slice)\nfmt.Printf(\"my_slice    = len=%d cap=%d %v\\n\", len(my_slice), cap(my_slice), my_slice)\n}\n</code></pre> output<pre><code>Full slice:  [10 20 30 40 50 60]\nFirst 3 elements:  [10 20 30]\nmy_slice        = len=6 cap=6 [10 20 30 40 50 60]\nnone_value      = len=0 cap=6 []\nfirst_four      = len=4 cap=6 [10 20 30 40]\nlast_two        = len=4 cap=4 [30 40 50 60]\nmy_slice with 70:  [10 20 30 40 50 60 70]\nmy_slice        = len=7 cap=12 [10 20 30 40 50 60 70]\n</code></pre></p> <p>Warning</p> <p>Remember that slices are based on arrays, so they can change in size dynamically. <code>If the underlying array runs out of capacity, a new larger array is allocated, and the data is copied over</code>. When added 70 in the example aboce, notice that the <code>slice's capacity increases to 12 instead of 7</code>. This happens because Go, when it needs to increase capacity, <code>doubles the original size</code>. Doubling the capacity of the underlying array allows for more elements to be added in the future without frequent reallocations. <code>In the case of very large slices, this can consume more memory than necessary</code>. So, when you anticipate working with a large slice, it's a <code>good practice to initialize the slice with a size closer to the maximum you expect to use to minimize unnecessary memory consumption</code>.</p>"},{"location":"basics/vars/#maps","title":"Maps","text":"<p>Maps in Go are a versatile data structure used to store <code>key-value pairs</code>. They are <code>similar to dictionaries or hash tables</code> in other programming languages. A key feature of maps is their ability to provide fast and efficient lookups for values based on their associated keys.</p> <p>Remember that maps are <code>reference types</code>, so when you pass a map to a function or assign it to another variable, you're working with a reference to the same underlying data structure.</p> Example <p>run command<pre><code>go run variables/maps.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nempty_map := map[string]int{}\nfmt.Println(empty_map)\nempty_make := make(map[string]int)\nfmt.Println(empty_make)\nmap_works_salary := map[string]int{\"Gabriel\": 100, \"Renato Augusto\": 3000}\nmap_works_salary[\"Cassio\"] = 3000\ngabriel_salary := map_works_salary[\"Gabriel\"]\nfmt.Printf(\"Init map_works_salary: %v\\n\", map_works_salary)\nfmt.Printf(\"Gabriel salary: %v\\n\", gabriel_salary)\nvalue, exists := map_works_salary[\"Yuri Alberto\"]\nif exists {\nfmt.Printf(\"Yuri Alberto salary: %v\\n\", value)\n} else {\nmap_works_salary[\"Yuri Alberto\"] = 3000\nyuri_salary := map_works_salary[\"Yuri Alberto\"]\nfmt.Printf(\"Yuri Alberto salary: %v\\n\", yuri_salary)\n}\ndelete(map_works_salary, \"Gabriel\")\nfmt.Printf(\"After delete Gabriel: %v\\n\\n\", map_works_salary)\nfor key, value := range map_works_salary {\nfmt.Printf(\"Player: %v, Salaray: %d\\n\", key, value)\n}\n}\n</code></pre> output<pre><code>map[]\nmap[]\nInit map_works_salary: map[Cassio:3000 Gabriel:100 Renato Augusto:3000]\nGabriel salary: 100\nYuri Alberto salary: 3000\nAfter delete Gabriel: map[Cassio:3000 Renato Augusto:3000 Yuri Alberto:3000]\nPlayer: Renato Augusto, Salaray: 3000\nPlayer: Cassio, Salaray: 3000\nPlayer: Yuri Alberto, Salaray: 3000\n</code></pre></p>"},{"location":"functions/","title":"Functions","text":""},{"location":"functions/#definition-and-arguments","title":"Definition and Arguments","text":"<p>The <code>func</code> keyword introduces a function definition, followed by the function name and a list of formal parameters enclosed in parentheses. Functions can take zero or more parameters. Parameters are declared with their type. <code>When function parameters share the same type, you can declare the type once for all of them</code>.</p> <p>When you pass <code>parameters to a function, they are typically passed by copy</code>. This means that a copy of the value is made, and <code>any changes you make to the parameter within the function do not affect the original value outside of the function</code>. To change the parameters passed, use pointers and pointers receivers.</p> Example <p>run command<pre><code>go run function/basic.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nprint_double(6)\nsum_result := sum(7, 3)\nfmt.Printf(\"sum_result is: %d\\n\", sum_result)\n}\nfunc print_double(double int) {\nresult := double * 2\nfmt.Printf(\"Double of %d: %d\\n\", double, result)\n}\nfunc sum(num1, num2 int) int {\nreturn num1 + num2\n}\n</code></pre> output<pre><code>Double of 6: 12\nsum_result is: 10\n</code></pre></p>"},{"location":"functions/#variadic-functions","title":"Variadic Functions","text":"<p>Go allows you to define <code>functions that can accept a variable number of arguments</code>. You use the <code>...</code> notation before the type of the last parameter</p> Example <p>run command<pre><code>go run function/func_variadic.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc sum(numbers ...int) int {\ntotal := 0\nfor _, num := range numbers {\ntotal += num\n}\nreturn total\n}\nfunc main() {\nresult := sum(1, 2, 3, 4, 5, 6, 7, 8, 9)\nfmt.Printf(\"Result %d\\n\", result)\n}\n</code></pre> output<pre><code>Result 45\n</code></pre></p>"},{"location":"functions/#return","title":"Return","text":"<p>Functions in Go can indeed <code>return multiple values</code>. When a function is called, it can produce multiple results. <code>Functions can declare named return values</code>, which act as variables. This can make the code more readable by specifying what the function is returning.</p> Example <p>run command<pre><code>go run function/return.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nresult, is_even := sum_check_even(1, 2)\nfmt.Printf(\"result is: %d\\n\", result)\nif is_even {\nfmt.Printf(\"result is even!!!\\n\")\n}\nresult, is_even = sum_check_even(2, 2)\nfmt.Printf(\"result is: %d\\n\", result)\nif is_even {\nfmt.Printf(\"result is even!!!\\n\")\n}\n}\nfunc sum_check_even(num1, num2 int) (result int, is_even bool) {\nresult = num1 + num2\nis_even = result%2 == 0\nreturn\n}\n</code></pre> output<pre><code>result is: 3\nresult1 is: 4\nresult1 is even!!!\n</code></pre></p>"},{"location":"functions/#error-handling","title":"Error Handling","text":"<p>In Go, error handling differs significantly from languages that use try/catch blocks. <code>Go intentionally does not have try/catch mechanisms because it encourages a different approach to handling errors</code>. Instead, functions in Go often <code>return multiple values, where the last value is typically an error</code>.</p> Example <p>run command<pre><code>go run function/return_error.go\n</code></pre> <pre><code>package main\nimport (\n\"errors\"\n\"fmt\"\n)\nfunc divide(a, b float64) (float64, error) {\nif b == 0 {\nreturn 0, errors.New(\"division by zero\")\n}\nreturn a / b, nil\n}\nfunc main() {\nresult, err := divide(10, 2)\nif err != nil {\nfmt.Println(\"Error:\", err)\n} else {\nfmt.Println(\"Result:\", result)\n}\nresult, err = divide(10, 0)\nif err != nil {\nfmt.Println(\"Error:\", err)\n} else {\nfmt.Println(\"Result:\", result)\n}\n}\n</code></pre> output<pre><code>Result: 5\nError: division by zero\n</code></pre></p>"},{"location":"functions/#anonymous-functions-closures","title":"Anonymous Functions (Closures)","text":"<p>Go supports anonymous functions, <code>which can be assigned to variables or passed as arguments</code> to other functions. <code>They can capture and use variables from their surrounding scope</code>.</p> Example <p>run command<pre><code>go run function/closures.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nadd := func(a, b int) int {\nreturn a + b\n}\nresult1 := add(2, 4)\nfmt.Printf(\"result1 %d\\n\", result1)\nresult1 = add(3, 4)\nfmt.Printf(\"result1 %d\\n\", result1)\nresult1 = add(4, 4)\nfmt.Printf(\"result1 %d\\n\", result1)\n}\n</code></pre> output<pre><code>result1 6\nresult1 7\nresult1 8\n</code></pre></p>"},{"location":"structs/interface/","title":"Interface","text":"<p>In Go, interfaces are a powerful and flexible way to <code>define sets of methods that types must implement</code>. <code>They allow you to write functions and methods that can work with various types, as long as those types satisfy the interface contract</code>. Interfaces support methods but <code>not properties or fields</code>.</p> <p>To declare an interface, <code>you list the method signatures that types must implement</code>. <code>Any type that has methods matching these signatures implicitly implements the interface</code>. To implement an interface, <code>a type needs to provide method implementations that match the method signatures in the interface</code>. If a type has all the required methods, <code>it implicitly satisfies the interface</code>. Interfaces <code>promote polymorphism and decoupling of code</code>.</p> Example <p>run command<pre><code>go run structs/interfaces.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Shape interface {\nArea() float64\n}\ntype Circle struct {\nRadius float64\n}\nfunc (c Circle) Area() float64 {\nreturn 3.14 * c.Radius * c.Radius\n}\ntype Rectangle struct {\nWidth  float64\nHeight float64\n}\nfunc (r Rectangle) Area() float64 {\nreturn r.Width * r.Height\n}\nfunc printArea(s Shape) {\narea := s.Area()\nfmt.Printf(\"Area: %.2f\\n\", area)\n}\nfunc main() {\nc := Circle{Radius: 5.0}\nr := Rectangle{Width: 4.0, Height: 6.0}\nprintArea(c)\nprintArea(r)\n}\n</code></pre> output<pre><code>Area: 78.50\nArea: 24.00\n</code></pre></p>"},{"location":"structs/structs/","title":"Structs","text":"<p>In Go, <code>structs are composite data types used to group together variables (fields) under a single data structure</code>. They are similar to classes in other languages, but <code>Go doesn't have classes in the traditional sense</code>.</p> <p>You define a struct using the <code>type</code> keyword, followed by the <code>name of the struct</code> and a set of field declarations within curly braces. To <code>create an instance</code> of a struct, you can use the <code>struct's name followed by curly braces and provide values for its fields</code>.</p> Example <p>run command<pre><code>go run structs/basic.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Person struct {\nName string\nAge  int\n}\nfunc main() {\nperson := Person{\nName: \"Gabriel\",\nAge:  100,\n}\nfmt.Printf(\"Create object person, from Person struct: %v\\n\", person)\n}\n</code></pre> output<pre><code>Create object person, from Person struct: {Gabriel 100}\n</code></pre></p>"},{"location":"structs/structs/#anonymous-structs","title":"Anonymous Structs","text":"<p>Anonymous Structs are structs without a defined name, often used for <code>temporary data structures</code>.</p> Example <p>run command<pre><code>go run structs/anonymous.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvector := struct {\nX int\nY int\n}{\nX: 10,\nY: 20,\n}\nfmt.Printf(\"Create object from an anonymous structs : %v\\n\", vector)\nfmt.Printf(\"X : %v\\n\", vector.X)\nfmt.Printf(\"Y : %v\\n\", vector.Y)\n}\n</code></pre> output<pre><code>Create object from an anonymous structs : {10 20}\nX : 10\nY : 20\n</code></pre></p>"},{"location":"structs/structs/#composing-structs","title":"Composing Structs","text":"<p>In Go, you can <code>embed one struct within another</code>, creating a composition of structs. This is <code>similar to inheritance</code> in other languages.</p> Example <p>run command<pre><code>go run structs/composing.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Team struct {\nTeamName string\n}\ntype Person struct {\nName string\nAge  int\nTeam\nPersonTeam Team\n}\nfunc main() {\nperson := Person{\nName:       \"Gabriel\",\nAge:        100,\nTeam:       Team{\"Corinthians\"},\nPersonTeam: Team{\"Knicks\"},\n}\nfmt.Printf(\"Person: %v\\n\", person)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.Team)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.Team.TeamName)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.TeamName)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.PersonTeam)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.TeamName)\n}\n</code></pre> output<pre><code>Person: {Gabriel 100 {Corinthians} {Knicks}}\nPerson name: Gabriel, Clube: {Corinthians}\nPerson name: Gabriel, Clube: Corinthians\nPerson name: Gabriel, Clube: Corinthians\nPerson name: Gabriel, Clube: {Knicks}\nPerson name: Gabriel, Clube: Corinthians\n</code></pre></p> Composing x Property, and Accessing Properties <p>In the given example, it's evident that the <code>Person struct is composed of a Team</code> and <code>has a property named PersonTeam of type Team</code>. The key distinction here is that when using the abbreviation <code>person.TeamName</code>, it returns the value of the composition, not the property. In Go, <code>you can directly access the properties of a composed struct</code>.</p>"},{"location":"structs/structs/#struct-methods","title":"Struct Methods","text":"<p>In Go, <code>structs can have methods associated with them</code>. These methods are <code>functions that operate on instances of the struct</code>, and they enable you to define behavior specific to the struct type.</p> Example <p>run command<pre><code>go run structs/methods.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Circle struct {\nRadius float64\n}\nfunc (c Circle) Area() float64 {\nreturn 3.14 * c.Radius * c.Radius\n}\nfunc main() {\ncircle := Circle{Radius: 5.0}\narea := circle.Area()\nfmt.Printf(\"Area: %v\\n\", area)\n}\n</code></pre> output<pre><code>Area: 78.5\n</code></pre></p>"},{"location":"structs/structs/#pointer-receivers","title":"Pointer Receivers","text":"<p><code>Pointer receivers can modify the state of the struct directly</code>. Using a pointer receiver allows you to <code>change the state</code> of an instance directly. When you pass a struct to a function, you're essentially <code>passing a copy of the struct</code>. Using pointers, you can <code>pass a reference to the struct</code>, allowing the function to modify the original data.</p> Example <p>run command<pre><code>go run structs/methods_pointer.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Circle struct {\nRadius float64\n}\nfunc (c Circle) NormalArea() float64 {\nresult := 3.14 * c.Radius * c.Radius\nc.Radius = 100\nreturn result\n}\nfunc (c *Circle) PointerArea() float64 {\nresult := 3.14 * c.Radius * c.Radius\nc.Radius = 100\nreturn result\n}\nfunc main() {\ncircle := Circle{Radius: 5.0}\narea := circle.NormalArea()\nfmt.Printf(\"Area: %v\\n\", area)\nfmt.Printf(\"Circle change? %v\\n\", circle)\narea = circle.PointerArea()\nfmt.Printf(\"Area: %v\\n\", area)\nfmt.Printf(\"Circle change? %v\\n\", circle)\n}\n</code></pre> output<pre><code>Area: 78.5\nCircle change? {5}\nArea: 78.5\nCircle change? {100}\n</code></pre></p>"},{"location":"structs/structs/#pointers-constructors","title":"Pointers Constructors","text":"<p>In Go, when you create a constructor function for a struct, <code>it typically returns a reference to the newly created struct</code>. With this technique, <code>any modification made to the reference returned by the constructor will affect all places that use that reference. This can be quite powerful, especially when managing resources like database connections</code>.</p> Example <p>run command<pre><code>go run structs/constructor_pointer.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype DbConnection struct {\nisOpen   bool\nstr_conn string\n}\nfunc NewDbConnection(str_conn string) *DbConnection {\nreturn &amp;DbConnection{\nisOpen:   true,\nstr_conn: str_conn,\n}\n}\nfunc (conn *DbConnection) Close() {\nconn.isOpen = false\nfmt.Println(\"Closing the DB conncetion \", conn.str_conn)\n}\nfunc main() {\ndbConn := NewDbConnection(\"**nice connection!***\")\ndbConnValue := *dbConn\nperformQuery1(dbConnValue)\nperformQuery2(dbConn)\nperformQuery3(dbConn)\ndbConn.Close()\nperformQuery1(dbConnValue)\nperformQuery2(dbConn)\nperformQuery3(dbConn)\n}\nfunc performQuery1(conn DbConnection) {\nfmt.Println(\"Query 1 executed\", conn.str_conn, conn.isOpen)\n}\nfunc performQuery2(conn *DbConnection) {\nfmt.Println(\"Query 2 executed\", conn.str_conn, conn.isOpen)\n}\nfunc performQuery3(conn *DbConnection) {\nfmt.Println(\"Query 3 executed\", conn.str_conn, conn.isOpen)\n}\n</code></pre> output<pre><code>Query 1 executed **nice connection!*** true\nQuery 2 executed **nice connection!*** true\nQuery 3 executed **nice connection!*** true\nClosing the DB conncetion  **nice connection!***\nQuery 1 executed **nice connection!*** true\nQuery 2 executed **nice connection!*** false\nQuery 3 executed **nice connection!*** false\n</code></pre></p>"}]}