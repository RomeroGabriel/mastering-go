{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Go","text":"<p>Gi Studies Wiki: A centralized repository offering a wealth of resources and insights for mastering Go programming.</p> <p>A particular but not private repository to centralize all studies about Go and a few famous Go's libraries. It's kind my own documentation about the language. </p>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>Go Expert - FullCycle</li> </ul> <p>*and of course chatGPT </p>"},{"location":"generics/","title":"Generics","text":"<p>Generics enables you to write <code>functions and data structures that work with different types while maintaining type safety</code>. You can define functions and structures that operate on various types without sacrificing the compiler's ability to catch type errors at compile time.</p> Example <p>run command<pre><code>go run src/generics/basic.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n)\nfunc FindMax[T int | float64](data []T) T {\nif len(data) == 0 {\nreturn 0\n}\nmax := data[0]\nfor _, value := range data {\nif value &gt; max {\nmax = value\n}\n}\nreturn max\n}\nfunc main() {\nints := []int{3, 7, 1, 9, 4, 6}\nfloats := []float64{3.14, 2.71, 1.618, 2.718}\nfmt.Println(\"FindMax integer:\", FindMax(ints))\nfmt.Println(\"FindMax float:\", FindMax(floats))\n}\n</code></pre> output<pre><code>FindMax integer: 9\nFindMax float: 3.14\n</code></pre></p>"},{"location":"generics/#combine-multiple-types-constraint","title":"Combine Multiple Types (Constraint)","text":"<p>In Go, <code>generic constraints are a way to specify requirements for the type parameters used in generic functions or data structures</code>. Constraints <code>ensure that the generic code can only be used with types that meet certain criteria</code>.</p> Example <p>run command<pre><code>go run src/generics/constraint.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n)\ntype ValidNumbers interface {\nint | float64\n}\nfunc FindMax[T ValidNumbers](data []T) T {\nif len(data) == 0 {\nreturn 0\n}\nmax := data[0]\nfor _, value := range data {\nif value &gt; max {\nmax = value\n}\n}\nreturn max\n}\nfunc main() {\nints := []int{3, 7, 1, 9, 4, 6}\nfloats := []float64{3.14, 2.71, 1.618, 2.718}\nfmt.Println(\"FindMax integer:\", FindMax(ints))\nfmt.Println(\"FindMax float:\", FindMax(floats))\n}\n</code></pre> output<pre><code>FindMax integer: 9\nFindMax float: 3.14\n</code></pre></p>"},{"location":"generics/#tilde-closer-than-identical-types","title":"Tilde(~) - Closer Than Identical Types","text":"<p>The special tilde (<code>~</code>) symbol, often referred to as the <code>approximation constraint</code>, is used in Go generics to <code>indicate that a type should approximately match one of the specified types or their derived types</code>. <code>Without the tilde, the function or method constrained by generic types would only accept exact types declared in the constraints and not their derived types</code>. The tilde allows for a broader match, including derived types, making your code more flexible and accommodating related types.</p> Example <p>run command<pre><code>go run src/generics/approximation_constraint.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n)\ntype NumberInt int\ntype NumberFloat float64\ntype ValidNumbers interface {\n~int | ~float64\n}\nfunc FindMax[T ValidNumbers](data []T) T {\nif len(data) == 0 {\nreturn 0\n}\nmax := data[0]\nfor _, value := range data {\nif value &gt; max {\nmax = value\n}\n}\nreturn max\n}\nfunc main() {\nints := []NumberInt{3, 7, 1, 9, 4, 6}\nfloats := []NumberFloat{3.14, 2.71, 1.618, 2.718}\nfmt.Println(\"FindMax integer:\", FindMax(ints))\nfmt.Println(\"FindMax float:\", FindMax(floats))\n}\n</code></pre> output<pre><code>FindMax integer: 9\nFindMax float: 3.14\n</code></pre></p>"},{"location":"generics/#comparable","title":"Comparable","text":"<p>In Go generics, you can use the <code>comparable constraint</code> to specify that a type should be comparable. This constraint ensures that the type can be used with comparison operators like <code>==</code> and <code>!=</code>.</p> Example <p>run command<pre><code>go run src/generics/comparable.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc CheckNumbers[T comparable](a T, b T) bool {\nif a == b {\nreturn true\n}\nreturn false\n}\nfunc FindIndex[T comparable](data []T, value T) int {\nfor i, data_value := range data {\nif data_value == value {\nreturn i\n}\n}\nreturn -1\n}\nfunc main() {\nfmt.Println(\"CheckNumbers: \", CheckNumbers(10, 10.5))\nfmt.Println(\"CheckNumbers: \", CheckNumbers(10.5, 10.5))\nints := []int{3, 7, 1, 9, 4, 6}\nfmt.Println(\"FindMax integer:\", FindIndex(ints, 300))\nfmt.Println(\"FindMax integer:\", FindIndex(ints, 9))\nfmt.Println(\"FindMax integer:\", FindIndex(ints, 10))\n}\n</code></pre> output<pre><code>CheckNumbers:  false\nCheckNumbers:  true\nFindMax integer: -1\nFindMax integer: 3\nFindMax integer: -1\n</code></pre></p>"},{"location":"generics/#references","title":"References","text":"<ul> <li>An Introduction to Generics in Go</li> </ul>"},{"location":"pointers/","title":"Pointers","text":"<p>In Go, pointers are <code>variables that store memory addresses</code>. <code>They are used to reference values rather than holding the values themselves</code>. It allows you to <code>indirectly access and modify the value of the variable</code> it points to. Pointers are represented using the <code>*</code> symbol.</p> <p>To <code>access the value that a pointer points to</code>, you can use the <code>*</code> symbol again. This is called <code>dereferencing the pointer</code>. The <code>&amp;</code> operator is <code>used to obtain the memory address of a variable</code>. This memory address is also known as a pointer.</p> <p>Example</p> <p>run command<pre><code>go run src/structs/pointers.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nx := 42\nfmt.Println(\"Value of x: \", x)\nptr := &amp;x\nfmt.Println(\"Value that ptr point to: \", *ptr)\nfmt.Println(\"Memory address of ptr: \", ptr)\n*ptr = 100\nfmt.Println(\"Updated value of x: \", x)\n}\n</code></pre> output<pre><code>Value of x:  42\nValue that ptr point to:  42\nMemory address of ptr:  0xc0000120f0\nUpdated value of x:  100\n</code></pre></p>"},{"location":"basics/control_flow/","title":"Control Flow","text":"<p>Listing the fundamental and commonly used control flow structures in Go.</p>"},{"location":"basics/control_flow/#for","title":"for","text":"Example <p>run command<pre><code>go run src/control_flow/for.go\n</code></pre> src/control_flow/for.go<pre><code>package main\nimport \"fmt\"\nfunc main() {\nfor i := 0; i &lt; 5; i++ {\nfmt.Println(\"Basic for type 1: \", i)\n}\nfmt.Println(\"*********\")\nj := 2\nfor j &lt; 5 {\nfmt.Println(\"Basic for type 2: \", j)\nj++\n}\nfmt.Println(\"*********\")\narr := []int{1, 2, 3, 4, 5}\nfor index, value := range arr {\nfmt.Println(\"arr for, index: \", index, \"value \", value)\n}\nfmt.Println(\"*********\")\nmyMap := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}\nfor key, value := range myMap {\nfmt.Println(\"map for, key: \", key, \"value \", value)\n}\n}\n</code></pre> output<pre><code>Basic for type 1:  0\nBasic for type 1:  1\nBasic for type 1:  2\nBasic for type 1:  3\nBasic for type 1:  4\n*********\nBasic for type 2:  2\nBasic for type 2:  3\nBasic for type 2:  4\n*********\narr for, index:  0 value  1\narr for, index:  1 value  2\narr for, index:  2 value  3\narr for, index:  3 value  4\narr for, index:  4 value  5\n*********\nmap for, key:  a value  1\nmap for, key:  b value  2\nmap for, key:  c value  3\n</code></pre></p>"},{"location":"basics/control_flow/#switch","title":"switch","text":"Example <p>run command<pre><code>go run src/control_flow/switch.go\n</code></pre> src/control_flow/switch.go<pre><code>package main\nimport \"fmt\"\nfunc main() {\nday := \"Monday\"\nswitch day {\ncase \"Monday\":\nfmt.Println(\"Today is Monday.\")\ncase \"Tuesday\":\nfmt.Println(\"Today is Tuesday.\")\ncase \"Wednesday\":\nfmt.Println(\"Today is Wednesday.\")\ndefault:\nfmt.Println(\"It's some other day.\")\n}\n}\n</code></pre> output<pre><code>Today is Monday.\n</code></pre></p>"},{"location":"basics/go_cli/","title":"Go CLI","text":""},{"location":"basics/go_cli/#go-environment-command","title":"Go Environment Command","text":"<p>Lists all Go <code>environment variables</code>.</p> <p>Info</p> <pre><code>go env\n</code></pre> go env output <pre><code>GO111MODULE=''\nGOARCH='amd64'\nGOBIN=''\nGOCACHE='/home/gabriel/.cache/go-build'\nGOENV='/home/gabriel/.config/go/env'\nGOEXE=''\nGOEXPERIMENT=''\nGOFLAGS=''\nGOHOSTARCH='amd64'\nGOHOSTOS='linux'\nGOINSECURE=''\nGOMODCACHE='/home/gabriel/go/pkg/mod'\nGONOPROXY=''\nGONOSUMDB=''\nGOOS='linux'\nGOPATH='/home/gabriel/go'\nGOPRIVATE=''\nGOPROXY='https://proxy.golang.org,direct'\nGOROOT='/usr/local/go'\nGOSUMDB='sum.golang.org'\nGOTMPDIR=''\nGOTOOLCHAIN='auto'\nGOTOOLDIR='/usr/local/go/pkg/tool/linux_amd64'\nGOVCS=''\nGOVERSION='go1.21.1'\nGCCGO='gccgo'\nGOAMD64='v1'\nAR='ar'\nCC='gcc'\nCXX='g++'\nCGO_ENABLED='1'\nGOMOD='/dev/null'\nGOWORK=''\nCGO_CFLAGS='-O2 -g'\nCGO_CPPFLAGS=''\nCGO_CXXFLAGS='-O2 -g'\nCGO_FFLAGS='-O2 -g'\nCGO_LDFLAGS='-O2 -g'\nPKG_CONFIG='pkg-config'\nGOGCCFLAGS='-fPIC -m64 -pthread -Wl,--no-gc-sections -fmessage-length=0 -ffile-prefix-map=/tmp/go-build4097433368=/tmp/go-build -gno-record-gcc-switches'\n</code></pre>"},{"location":"basics/go_cli/#gopath","title":"GOPATH","text":"<p><code>GOPATH</code> is a variable that <code>defines the root of your workspace</code>. It stores your code base and all the files necessary for your development. <code>It also contains the binaries of your compilations and the libraries used.</code></p>"},{"location":"basics/go_cli/#gomodcache","title":"GOMODCACHE","text":"<p><code>GOMODCACHE</code> is related to <code>Go module management</code>, which is used for handling dependencies. It is <code>typically a subfolder within your GOPATH</code>.</p>"},{"location":"basics/go_cli/#go-mod","title":"Go Mod","text":""},{"location":"basics/go_cli/#go-mod-init","title":"Go Mod Init","text":"<p>Info</p> <pre><code>go mod init example.com/module\n</code></pre> <p>This command <code>initializes a new module with the specified name</code>. You can then <code>add dependencies to the module using the go get command and manage the module's requirements through the go.mod file</code>.</p>"},{"location":"basics/go_cli/#go-mod-tidy","title":"Go Mod TIDY","text":"<p>This is a command that <code>ensures that the go.mod file matches the source code in the module</code>. <code>It adds any missing and removes any unused module dependencies</code>, keeping the go.mod file clean and ensuring that it accurately reflects the actual dependencies needed for your project.</p> <p>Info</p> <pre><code>go mod tydi\n</code></pre> <p><code>Make sure that you have initialized Go modules in your project (with go mod init) before running the go mod tidy command</code>. This ensures that the go.mod file exists in the root of your project directory.</p>"},{"location":"basics/go_cli/#go-get","title":"Go Get","text":"<p>To install packages in Go, you can use the <code>go get command followed by the package name</code>.</p> <p><code>Make sure that you have initialized Go modules in your project (with go mod init) before running the go get command</code>. This ensures that the go.mod file exists in the root of your project directory.</p> <p>Info</p> <pre><code>go get [packages]\n</code></pre> <p>It is also used to update and manage dependencies in your GOPATH. Some helpful subcommands you can use with go get:</p> <ol> <li><code>-u</code>: Update the package and install the latest version;</li> <li><code>-d</code>: Download the package's source code but do not install it.</li> <li><code>-t</code>: Also download the packages needed to run tests.</li> <li><code>-v</code>: Enable verbose output to see the package being fetched and installed.</li> </ol>"},{"location":"basics/go_cli/#go-build","title":"Go Build","text":"<p>The <code>go build</code> command is used to compile packages and dependencies <code>into an executable binary file</code>. This command compiles the Go source files in the current directory and creates an executable binary file.</p> <p>Building a <code>single file</code> in Go can be done by simply using the <code>go build filename.go</code> command followed by the name of the file. This command will <code>generate an executable binary based on the contents of the specified filename.go source file</code>. For <code>projects  that utilize the go.mod file</code> can be achieved by running the go build <code>command in the root directory of the project</code>. This command automatically builds the project, resolving dependencies defined in the go.mod file.</p> <p>Info</p> <p>just one file<pre><code>go build filename.go\n</code></pre> for projects<pre><code>go build\n</code></pre></p>"},{"location":"basics/go_cli/#variables-to-build","title":"Variables to Build","text":"<p>In Go, <code>GOOS</code> is an environment variable that specifies the <code>target operating system for code compilation</code>. The <code>GOARCH</code> is an environment variable that specifies the <code>target architecture for code compilation</code>. To find out the possibilities for <code>GOOS</code> and <code>GOARCH</code>, use go tool dist list. Is good start a new</p> <p>Info</p> <pre><code>GOOS=[target-OS] GOARCH=[target-architecture] go build\n</code></pre>"},{"location":"basics/go_cli/#go-tool","title":"Go Tool","text":""},{"location":"basics/go_cli/#go-tool-dist-list","title":"Go Tool dist list","text":"<p>In order to find out what operating systems and platforms are available for building executables, you can use the dist tool.</p> <p>Info</p> <pre><code>go tool dist list\n</code></pre> Example <p>android/386</p> <p>android/arm</p> <p>android/arm64</p> <p>darwin/amd64</p> <p>darwin/arm64</p> <p>ios/amd64</p> <p>ios/arm64</p> <p>linux/386</p> <p>linux/amd64</p> <p>linux/arm</p> <p>windows/386</p> <p>windows/amd64</p> <p>windows/arm</p> <p>...</p>"},{"location":"basics/go_cli/#refereces","title":"Refereces","text":"<ul> <li>How To Build Go Executables for Multiple Platforms on Ubuntu 20.04</li> </ul>"},{"location":"basics/go_paradigm/","title":"Go's Paradigms","text":"<p>Go aims to be both simple and powerful, with the goal of enhancing programmers' productivity. <code>It boasts a straightforward and consistent syntax that remains stable across versions, ensuring compatibility</code>. One of Go's standout features is its robust support for concurrency. <code>It is designed to efficiently leverage multicore processors and excel in handling network-related tasks</code>. In terms of typing, <code>Go follows a static and strong typing system</code>. Here are some key aspects of Go's paradigms and its way of work:</p> <ol> <li>Concurrent and Structured Programming;</li> <li>Static and Strong Typing;</li> </ol>"},{"location":"basics/handle_files/","title":"Handle Files","text":""},{"location":"basics/handle_files/#create-a-file","title":"Create a File","text":"<p>To create a file, you can use the <code>os.Create</code> function along with the defer statement to close the file after writing to it.</p> Example <p>run command<pre><code>go run src/handle_files/create_file.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n\"os\"\n)\nfunc main() {\nfile, err := os.Create(\"src/handle_files/example.txt\")\ndefer file.Close()\nif err != nil {\nfmt.Println(err)\nreturn\n}\n}\n</code></pre></p>"},{"location":"basics/handle_files/#write-into-a-file","title":"Write into a File","text":"<p>Open the file in <code>append mode</code> and write to it using the <code>os.OpenFile</code> function.</p> Example <p>run command<pre><code>go run src/handle_files/write_file.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n\"os\"\n)\nfunc main() {\nfile, err := os.OpenFile(\"src/handle_files/example.txt\", os.O_APPEND|os.O_WRONLY, 0644)\nif err != nil {\nfmt.Println(err)\nreturn\n}\ndefer file.Close()\nsize, err := file.WriteString(\"\\nWriting a string into the file\\n\")\nif err != nil {\nfmt.Println(err)\nreturn\n}\nfmt.Println(\"Size written into file: \", size)\n_, err = file.Write([]byte(\"Using bytes to write\"))\n}\n</code></pre></p>"},{"location":"basics/handle_files/#file-permission-number","title":"File Permission Number","text":"<p>In the <code>os.OpenFile</code> function, the <code>perm argument is used to specify the file permission when creating or opening a file</code>. It is an integer value that represents the file mode and permission bits. The typical file permission values used in Unix-like systems are represented in octal notation. <code>The permission mode is composed of three digits, each of which represents the permissions for different user groups</code>.</p> <ol> <li><code>Owner Permissions</code>: The first digit represents the permissions for the file owne.</li> <li><code>Group Permissions</code>: The second digit represents the permissions for the group that the file belongs to.</li> <li><code>Other Permissions</code>: The third digit represents the permissions for everyone else (other users).</li> </ol> <p>The digits in the mode are a sum of permission bits:</p> <ol> <li><code>4: Read (r)</code></li> <li><code>2: Write (w)</code></li> <li><code>1: Execute (x)</code></li> </ol> <p>And calculate the permissions numbers:</p> <ol> <li><code>6 (4 + 2) means read and write permissions (rw)</code>.</li> <li><code>4 (only 4) means read-only (r).</code>.</li> <li><code>7 (4 + 2 + 1) means read, write, and execute permissions (rwx).</code>.</li> </ol> Example <ol> <li><code>0644</code>: Owner has read and write (6), group and others have read-only (4).</li> <li><code>0755</code>: Owner has read, write, and execute (7), group and others have read and execute (5).</li> <li><code>0600</code>: Owner has read and write (6), no permissions for group and others.</li> </ol>"},{"location":"basics/handle_files/#reading-a-file","title":"Reading a File","text":"<p>To read from a file, you can use the <code>os.Open</code> function along with a <code>Scanner from the bufio package</code>.</p> Example <p>run command<pre><code>go run src/handle_files/read_file.go\n</code></pre> <pre><code>package main\nimport (\n\"bufio\"\n\"fmt\"\n\"os\"\n)\nfunc main() {\nfile, err := os.Open(\"src/handle_files/example.txt\")\nif err != nil {\nfmt.Println(err)\nreturn\n}\ndefer file.Close()\nscanner := bufio.NewScanner(file)\nfor scanner.Scan() {\nfmt.Println(scanner.Text())\n}\n}\n</code></pre> output<pre><code>Writing a string into the file\nUsing bytes to write\n</code></pre></p>"},{"location":"basics/handle_files/#delete-a-file","title":"Delete a File","text":"<p>To delete a file, you can use the <code>os.Remove</code> function.</p> Example <p>run command<pre><code>go run src/handle_files/delete_file.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n\"os\"\n)\nfunc main() {\nerr := os.Remove(\"src/handle_files/example.txt\")\nif err != nil {\nfmt.Println(err)\nreturn\n}\nfmt.Println(\"File deleted successfully.\")\n}\n</code></pre></p>"},{"location":"basics/packages/","title":"Packages and Modules","text":""},{"location":"basics/packages/#packages","title":"Packages","text":"<p>Every <code>.go file begins with the package command</code>, and the <code>package's name should match the directory in which the file resides</code>. The exceptions to this rule are <code>package main</code> and <code>package test</code> which serve as the entry points for applications and tests, respectively. <code>Packages within the same directory should share the same package name. Anything within the same package can be accessed and utilized</code>.</p> Simple package example <p>run command<pre><code>go run src/packages/*\n</code></pre> src/packages/nice_func.go<pre><code>package main\nfunc nice_func() {\nprintln(\"   I'm on the same directory than main, so my package has to be main\")\n}\n</code></pre> src/packages/main.go<pre><code>package main\nfunc main() {\nprintln(\"Starting script\")\nprintln(\"Now, calling nice_func that is defined from the same file directory, on nice_func.go file\")\nnice_func()\n}\n</code></pre> output<pre><code>Starting script\nNow, calling nice_func that is defined from the same file directory, on nice_func.go file\n    I'm on the same directory than main, so my package has to be main\n</code></pre></p>"},{"location":"basics/packages/#installing-packages","title":"Installing Packages","text":"<p>See Go Get and Go Mod TIDY.</p>"},{"location":"basics/packages/#modules","title":"Modules","text":"<p>In Go, a <code>module is a collection of related Go packages that are versioned together as a single unit</code>. Modules are the key component of the Go module system, <code>introduced to manage package dependencies and versioning</code>.</p> <p>A Go module typically consists of one or more Go packages, a<code>long with a go.mod file that defines the module's requirements and dependencies</code>. The go.mod file keeps track of the module's dependencies, versions, and the other modules it requires.</p> <p>To create a new module in Go, you can use the go mod init command followed by the name of the module.</p> <p>Public and Private Access</p> <p>In Go, the concept of <code>public and private access is determined by the first letter's case of a variable or function name</code>. If the first letter of an identifier is in <code>uppercase</code>, it is <code>exported and can be accessed from other packages</code>. On the other hand, if the first letter is <code>lowercase</code>, the identifier is considered <code>unexported and can only be accessed within the same package</code>.</p> <p>This convention helps maintain encapsulation and ensures that package-level variables and functions are used only where intended.</p> Example <p>run command<pre><code>cd src/modules/\ngo run main.go\n</code></pre> src/modules/mathpackage/mathpackage.go<pre><code>package mathpackage\nimport \"fmt\"\nfunc sum[T int | float64](a, b T) T {\nfmt.Println(\"   Accessing sum function. Private to mathpackage\")\nreturn a + b\n}\nfunc SumInt(a, b int) int {\nreturn sum(a, b)\n}\nfunc SumFloat(a, b float64) float64 {\nreturn sum(a, b)\n}\n</code></pre> src/modules/car_package/car_package.go<pre><code>package carpackage\nimport (\n\"time\"\n)\ntype Car struct {\nName     string\nNickName string\nYear     int\n}\ntype fullCarPrivate struct {\nFullName string\nYear     int\nYearOld  int\n}\nfunc (c Car) CreateFullCar() fullCarPrivate {\nyearNow := time.Now().Year()\nfinalCar := fullCarPrivate{\nFullName: c.Name + \" \" + c.NickName,\nYear:     c.Year,\nYearOld:  yearNow - c.Year,\n}\nreturn finalCar\n}\n</code></pre> src/modules/main.go<pre><code>package main\nimport (\n\"fmt\"\ncarpackage \"start/modules/car_package\"\n\"start/modules/mathpackage\"\n)\nfunc main() {\nintSum := mathpackage.SumInt(50, 21)\nfmt.Println(\"Result of SumInt: \", intSum)\nfloatSum := mathpackage.SumFloat(3.14, 17.8)\nfmt.Println(\"Result of SumFloat: \", floatSum)\nfmt.Println(\"****\")\nfmt.Println(\"Starting explore Car Module\")\ncar := carpackage.Car{\nName:     \"Corolla\",\nNickName: \"Giant car\",\nYear:     2020,\n}\nfullCar := car.CreateFullCar()\nfmt.Println(\"Full Car name: \", fullCar.FullName)\nfmt.Println(\"Full Car Years Old: \", fullCar.YearOld)\n}\n</code></pre> output<pre><code>    Accessing sum function. Private to mathpackage\nResult of SumInt:  71\nAccessing sum function. Private to mathpackage\nResult of SumFloat:  20.94\n****\nStarting explore Car Module\nFull Car name:  Corolla Giant car\nFull Car Years Old:  3\n</code></pre></p>"},{"location":"basics/packages/#references","title":"References","text":"<ul> <li>Go Expert - FullCycle</li> </ul>"},{"location":"basics/vars/","title":"Variables and Data Types","text":"<p>In Go, <code>variables and constants are strongly typed</code>. To declare a constant, you use the <code>const</code> keyword, and for variables, you use <code>var</code>.</p> <p>Go can also <code>automatically infer variable types</code>, providing various syntaxes for declaring variables and constants, as shown below.</p> Simple vars example <p>run command<pre><code>go run src/variables/*\n</code></pre> <pre><code>package main\nconst A = \"I'm a constant\"\nvar B bool\nfunc main() {\nprintln(\"Starting basic variables\")\nprint(\"Print A const: \")\nprintln(A)\nprint(\"Print B var: \")\nprintln(B)\nprintln(\"NOTICE: B was infer as false\")\nprintln()\nprintln(\"Different ways to declare a variable: \")\nvar full_declare string = \"A\"\nprintln(\"Full declaration: \" + full_declare)\nshort_hand := \"B\"\nprintln(\"Short hand: \" + short_hand)\n}\n</code></pre> output<pre><code>Starting basic variables\nPrint A const: I'm a constant\nPrint B var: false\nNOTICE: B was infer as false\nDifferent ways to declare a variable:\nFull declaration: A\nShort hand: B\n</code></pre></p> Checking Default Infered Types <p>run command<pre><code>go run variables/infer_types.go </code></pre> <pre><code>package main\nvar (\nb  bool\nc  int\nd  string\ne  float32\ne6 float64\n)\nfunc main() {\nprint(\"bool \")\nprintln(b)\nprint(\"int \")\nprintln(c)\nprint(\"string \")\nprintln(d)\nprint(\"float32 \")\nprintln(e)\nprint(\"float64 \")\nprintln(e6)\n}\n</code></pre> output<pre><code>bool false\nint 0\nstring float32 +0.000000e+000\nfloat64 +0.000000e+000\n</code></pre></p>"},{"location":"basics/vars/#using-type","title":"Using type","text":"<p>In Go the <code>type</code> keyword is used to <code>define custom data types</code>. These custom types can be based on existing types, making it a versatile feature in the language.</p> Using type <p>run command<pre><code>go run variables/using_type.go\n</code></pre> <pre><code>package main\ntype custom_id string\nfunc main() {\ncustom_id := \"e96d759e-dc59-4394-9feb-79c8bf4130c9\"\nprintln(\"custom_id value: \" + custom_id)\n}\n</code></pre> output<pre><code>custom_id value: e96d759e-dc59-4394-9feb-79c8bf4130c9\n</code></pre></p>"},{"location":"basics/vars/#arrays","title":"Arrays","text":"<p>In Go, an array is a <code>fixed-size collection of elements of the same type</code>. Arrays are declared with a specific size, and that <code>size cannot be changed after the array is created</code>.</p> Example <p>run command<pre><code>go run variables/arrays.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvar myArray [3]int\nmyArray[1] = 10\nmyArray[2] = 20\nfmt.Println(myArray[0])\nfmt.Println(myArray)\nfor i, value := range myArray {\nfmt.Printf(\"Value stored in %d index is %d\\n\", i, value)\n}\ninitArray := [3]string{\"apple\", \"banana\", \"cherry\"}\nfor i, value := range initArray {\nfmt.Printf(\"Value stored in %d index is %v\\n\", i, value)\n}\n}\n</code></pre> output<pre><code>0\n[0 10 20]\nValue stored in 0 index is 0\nValue stored in 1 index is 10\nValue stored in 2 index is 20\nValue stored in 0 index is apple\nValue stored in 1 index is banana\nValue stored in 2 index is cherry\n</code></pre></p>"},{"location":"basics/vars/#slices","title":"Slices","text":"<p>In Go, a slice is a <code>more versatile and dynamic alternative to arrays</code>. Slices are like views into an underlying array, allowing you to work with a portion of an a<code>rray without specifying a fixed size</code>. Slices allow you to perform operations like appending elements, slicing (creating sub-slices), and growing dynamically.</p> <p>Slices also have a <code>length and capacity</code> (the maximum number of elements it can hold without reallocation). Use the <code>len()</code> and <code>cap()</code> functions to get these values.</p> Example <p>run command<pre><code>go run variables/slices.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nmy_slice := []int{10, 20, 30, 40, 50, 60}\nfmt.Println(\"Full slice: \", my_slice)\nfirst_three_elem := my_slice[0:3]\nfmt.Println(\"First 3 elements: \", first_three_elem)\nfmt.Printf(\"my_slice    = len=%d cap=%d %v\\n\", len(my_slice), cap(my_slice), my_slice)\nnone_value := my_slice[:0]\nfmt.Printf(\"none_value  = len=%d cap=%d %v\\n\", len(none_value), cap(none_value), none_value)\nfirst_four := my_slice[:4]\nfmt.Printf(\"first_four  = len=%d cap=%d %v\\n\", len(first_four), cap(first_four), first_four)\nskip_two_first := my_slice[2:]\nfmt.Printf(\"last_two    = len=%d cap=%d %v\\n\", len(skip_two_first), cap(skip_two_first), skip_two_first)\nmy_slice = append(my_slice, 70)\nfmt.Println(\"my_slice with 70: \", my_slice)\nfmt.Printf(\"my_slice    = len=%d cap=%d %v\\n\", len(my_slice), cap(my_slice), my_slice)\n}\n</code></pre> output<pre><code>Full slice:  [10 20 30 40 50 60]\nFirst 3 elements:  [10 20 30]\nmy_slice        = len=6 cap=6 [10 20 30 40 50 60]\nnone_value      = len=0 cap=6 []\nfirst_four      = len=4 cap=6 [10 20 30 40]\nlast_two        = len=4 cap=4 [30 40 50 60]\nmy_slice with 70:  [10 20 30 40 50 60 70]\nmy_slice        = len=7 cap=12 [10 20 30 40 50 60 70]\n</code></pre></p> <p>Warning</p> <p>Remember that slices are based on arrays, so they can change in size dynamically. <code>If the underlying array runs out of capacity, a new larger array is allocated, and the data is copied over</code>. When added 70 in the example aboce, notice that the <code>slice's capacity increases to 12 instead of 7</code>. This happens because Go, when it needs to increase capacity, <code>doubles the original size</code>. Doubling the capacity of the underlying array allows for more elements to be added in the future without frequent reallocations. <code>In the case of very large slices, this can consume more memory than necessary</code>. So, when you anticipate working with a large slice, it's a <code>good practice to initialize the slice with a size closer to the maximum you expect to use to minimize unnecessary memory consumption</code>.</p>"},{"location":"basics/vars/#maps","title":"Maps","text":"<p>Maps in Go are a versatile data structure used to store <code>key-value pairs</code>. They are <code>similar to dictionaries or hash tables</code> in other programming languages. A key feature of maps is their ability to provide fast and efficient lookups for values based on their associated keys.</p> <p>Remember that maps are <code>reference types</code>, so when you pass a map to a function or assign it to another variable, you're working with a reference to the same underlying data structure.</p> Example <p>run command<pre><code>go run variables/maps.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nempty_map := map[string]int{}\nfmt.Println(empty_map)\nempty_make := make(map[string]int)\nfmt.Println(empty_make)\nmap_works_salary := map[string]int{\"Gabriel\": 100, \"Renato Augusto\": 3000}\nmap_works_salary[\"Cassio\"] = 3000\ngabriel_salary := map_works_salary[\"Gabriel\"]\nfmt.Printf(\"Init map_works_salary: %v\\n\", map_works_salary)\nfmt.Printf(\"Gabriel salary: %v\\n\", gabriel_salary)\nvalue, exists := map_works_salary[\"Yuri Alberto\"]\nif exists {\nfmt.Printf(\"Yuri Alberto salary: %v\\n\", value)\n} else {\nmap_works_salary[\"Yuri Alberto\"] = 3000\nyuri_salary := map_works_salary[\"Yuri Alberto\"]\nfmt.Printf(\"Yuri Alberto salary: %v\\n\", yuri_salary)\n}\ndelete(map_works_salary, \"Gabriel\")\nfmt.Printf(\"After delete Gabriel: %v\\n\\n\", map_works_salary)\nfor key, value := range map_works_salary {\nfmt.Printf(\"Player: %v, Salaray: %d\\n\", key, value)\n}\n}\n</code></pre> output<pre><code>map[]\nmap[]\nInit map_works_salary: map[Cassio:3000 Gabriel:100 Renato Augusto:3000]\nGabriel salary: 100\nYuri Alberto salary: 3000\nAfter delete Gabriel: map[Cassio:3000 Renato Augusto:3000 Yuri Alberto:3000]\nPlayer: Renato Augusto, Salaray: 3000\nPlayer: Cassio, Salaray: 3000\nPlayer: Yuri Alberto, Salaray: 3000\n</code></pre></p>"},{"location":"functions/","title":"Functions","text":""},{"location":"functions/#definition-and-arguments","title":"Definition and Arguments","text":"<p>The <code>func</code> keyword introduces a function definition, followed by the function name and a list of formal parameters enclosed in parentheses. Functions can take zero or more parameters. Parameters are declared with their type. <code>When function parameters share the same type, you can declare the type once for all of them</code>.</p> <p>When you pass <code>parameters to a function, they are typically passed by copy</code>. This means that a copy of the value is made, and <code>any changes you make to the parameter within the function do not affect the original value outside of the function</code>. To change the parameters passed, use pointers and pointers receivers.</p> Example <p>run command<pre><code>go run function/basic.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nprint_double(6)\nsum_result := sum(7, 3)\nfmt.Printf(\"sum_result is: %d\\n\", sum_result)\n}\nfunc print_double(double int) {\nresult := double * 2\nfmt.Printf(\"Double of %d: %d\\n\", double, result)\n}\nfunc sum(num1, num2 int) int {\nreturn num1 + num2\n}\n</code></pre> output<pre><code>Double of 6: 12\nsum_result is: 10\n</code></pre></p>"},{"location":"functions/#variadic-functions","title":"Variadic Functions","text":"<p>Go allows you to define <code>functions that can accept a variable number of arguments</code>. You use the <code>...</code> notation before the type of the last parameter</p> Example <p>run command<pre><code>go run function/func_variadic.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc sum(numbers ...int) int {\ntotal := 0\nfor _, num := range numbers {\ntotal += num\n}\nreturn total\n}\nfunc main() {\nresult := sum(1, 2, 3, 4, 5, 6, 7, 8, 9)\nfmt.Printf(\"Result %d\\n\", result)\n}\n</code></pre> output<pre><code>Result 45\n</code></pre></p>"},{"location":"functions/#return","title":"Return","text":"<p>Functions in Go can indeed <code>return multiple values</code>. When a function is called, it can produce multiple results. <code>Functions can declare named return values</code>, which act as variables. This can make the code more readable by specifying what the function is returning.</p> Example <p>run command<pre><code>go run function/return.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nresult, is_even := sum_check_even(1, 2)\nfmt.Printf(\"result is: %d\\n\", result)\nif is_even {\nfmt.Printf(\"result is even!!!\\n\")\n}\nresult, is_even = sum_check_even(2, 2)\nfmt.Printf(\"result is: %d\\n\", result)\nif is_even {\nfmt.Printf(\"result is even!!!\\n\")\n}\n}\nfunc sum_check_even(num1, num2 int) (result int, is_even bool) {\nresult = num1 + num2\nis_even = result%2 == 0\nreturn\n}\n</code></pre> output<pre><code>result is: 3\nresult1 is: 4\nresult1 is even!!!\n</code></pre></p>"},{"location":"functions/#error-handling","title":"Error Handling","text":"<p>In Go, error handling differs significantly from languages that use try/catch blocks. <code>Go intentionally does not have try/catch mechanisms because it encourages a different approach to handling errors</code>. Instead, functions in Go often <code>return multiple values, where the last value is typically an error</code>.</p> Example <p>run command<pre><code>go run function/return_error.go\n</code></pre> <pre><code>package main\nimport (\n\"errors\"\n\"fmt\"\n)\nfunc divide(a, b float64) (float64, error) {\nif b == 0 {\nreturn 0, errors.New(\"division by zero\")\n}\nreturn a / b, nil\n}\nfunc main() {\nresult, err := divide(10, 2)\nif err != nil {\nfmt.Println(\"Error:\", err)\n} else {\nfmt.Println(\"Result:\", result)\n}\nresult, err = divide(10, 0)\nif err != nil {\nfmt.Println(\"Error:\", err)\n} else {\nfmt.Println(\"Result:\", result)\n}\n}\n</code></pre> output<pre><code>Result: 5\nError: division by zero\n</code></pre></p>"},{"location":"functions/#anonymous-functions-closures","title":"Anonymous Functions (Closures)","text":"<p>Go supports anonymous functions, <code>which can be assigned to variables or passed as arguments</code> to other functions. <code>They can capture and use variables from their surrounding scope</code>.</p> Example <p>run command<pre><code>go run function/closures.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nadd := func(a, b int) int {\nreturn a + b\n}\nresult1 := add(2, 4)\nfmt.Printf(\"result1 %d\\n\", result1)\nresult1 = add(3, 4)\nfmt.Printf(\"result1 %d\\n\", result1)\nresult1 = add(4, 4)\nfmt.Printf(\"result1 %d\\n\", result1)\n}\n</code></pre> output<pre><code>result1 6\nresult1 7\nresult1 8\n</code></pre></p>"},{"location":"functions/#defer","title":"Defer","text":"<p>In Go, the defer statement is used to <code>schedule a function call to be executed just before the surrounding function returns</code>. It is often used to simplify functions that perform various clean-up actions. <code>defer is commonly used for tasks such as closing files, unlocking mutexes, or generally executing clean-up actions</code>. The deferred call's arguments are <code>evaluated immediately, but the function call is not executed until the surrounding function returns</code>. It's important to note that <code>defer statements are executed in Last In, First Out (LIFO) order</code>. Multiple defer statements will be executed in the reverse order of their definition.</p> Example <p>In this code, \"Hello\" is printed first, and then the rest is printed.  This is because the defer statement <code>defers the execution tatement until after the surrounding function main finishes</code>.</p> <p>run command<pre><code>go run function/defer.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\ndefer fmt.Println(\"World\")\nfmt.Println(\"Hello\")\ndefer fmt.Println(\"Hi, testttting\")\n}\n</code></pre> output<pre><code>Hello\nHi, testttting\nWorld\n</code></pre></p>"},{"location":"https_network/api/","title":"API","text":"<p>You can create an HTTP server using the <code>net/http</code> package, allowing you to handle HTTP requests and responses.</p> <p>Example</p> <p>run command<pre><code>go run src/http/basic_server.go\ncurl localhost:8080\ncurl localhost:8080/anonymous_func\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n\"net/http\"\n)\nfunc main() {\nhandler := func(w http.ResponseWriter, r *http.Request) {\nw.Write([]byte(\"Hello World!\"))\n}\nhttp.HandleFunc(\"/\", handler)\nhttp.HandleFunc(\"/anonymous_func\", func(w http.ResponseWriter, r *http.Request) {\nw.Write([]byte(\"Hello World from anonymous_func!\"))\n})\nfmt.Println(\"Server is running on http://localhost:8080\")\nerr := http.ListenAndServe(\":8080\", nil)\nif err != nil {\nfmt.Println(\"Error:\", err)\n}\n}\n</code></pre> output<pre><code>Server is running on http://localhost:8080\nHello World!\nHello World from anonymous_func!\n</code></pre></p>"},{"location":"https_network/api/#examples","title":"Examples","text":"<ol> <li>Get Address - Basic API</li> </ol>"},{"location":"https_network/file_server/","title":"File Server","text":"<p>The <code>FileServer</code> function in the <code>net/http</code> package efficiently <code>serves static files from a specified directory</code>. It simplifies the process of serving a directory by providing a handler that serves HTTP requests with the contents of the specified directory.</p> <p>Example</p> <p>In this example, the FileServer function <code>serves files from the static directory</code>. The <code>http.Dir</code> function <code>specifies the directory from which to serve files</code>.</p> <p>run command<pre><code>go run src/http/file_server.go\ncurl localhost:8080\n</code></pre> <pre><code>package main\nimport (\n\"log\"\n\"net/http\"\n)\nfunc main() {\nfs := http.FileServer(http.Dir(\"./static\"))\nmux := http.NewServeMux()\nmux.Handle(\"/\", fs)\nlog.Fatal(http.ListenAndServe(\":8080\", mux))\n}\n</code></pre> output<pre><code>&lt;p&gt;Corinthians&lt;/p&gt;\n</code></pre></p>"},{"location":"https_network/json/","title":"JSON","text":"<p>Working with JSON in Go is straightforward and can be achieved using the <code>encoding/json</code> package, which provides functionalities to encode Go data structures into JSON and decode JSON into Go data structures.</p> <p>Nice to know Struts Tags</p>"},{"location":"https_network/json/#struct-to-json","title":"Struct to JSON","text":"<p>Using <code>json.Marshal</code> is the simple way. The <code>json.NewEncoder</code> is used to create a new <code>JSON encoder that writes to an io.Writer interface, such as a file or network connection</code>. This allows you to easily encode Go data structures to JSON and write them to an external destination.</p> Example <p>run command<pre><code>go run src/http/struct_to_json.go\n</code></pre> <pre><code>package main\nimport (\n\"encoding/json\"\n\"fmt\"\n\"os\"\n)\ntype Person struct {\nName string `json:\"name\"`\nAge  int    `json:\"age\"`\n}\nfunc main() {\nperson := Person{Name: \"Gabriel\", Age: 25}\njsonData, err := json.Marshal(person)\nfmt.Println(\"Using Marshal\")\nif err != nil {\nfmt.Println(\"Error:\", err)\nreturn\n}\nfmt.Println(\"JSON Data:\", string(jsonData))\nfmt.Println(\"***\")\nfmt.Println(\"Using NewEncoder\")\nfile, _ := os.Create(\"src/http/person.json\")\ndefer file.Close()\nerr = json.NewEncoder(file).Encode(person)\n}\n</code></pre> output<pre><code>Using Marshal\nJSON Data: {\"name\":\"Gabriel\",\"age\":25}\n***\nUsing NewEncoder\n</code></pre></p>"},{"location":"https_network/json/#json-to-struct","title":"JSON to Struct","text":"<p>Using <code>json.Unmarshal</code> is the simple way. The <code>json.NewDecoder</code> is used to create a new <code>JSON decoder that reads from an io.Reader interface, such as a file or network connection</code>. This enables you to easily decode JSON data from an external source into Go data structures.</p> Example <p>run command<pre><code>go run src/http/json_to_struct.go\n</code></pre> <pre><code>package main\nimport (\n\"encoding/json\"\n\"fmt\"\n\"os\"\n)\ntype Person struct {\nName string `json:\"name\"`\nAge  int    `json:\"age\"`\n}\nfunc main() {\nperson := Person{Name: \"Gabriel\", Age: 25}\njsonData, err := json.Marshal(person)\nfmt.Println(\"Using Marshal\")\nif err != nil {\nfmt.Println(\"Error:\", err)\nreturn\n}\nfmt.Println(\"JSON Data:\", string(jsonData))\nfmt.Println(\"***\")\nfmt.Println(\"Using NewEncoder\")\nfile, _ := os.Create(\"src/http/person.json\")\ndefer file.Close()\nerr = json.NewEncoder(file).Encode(person)\n}\n</code></pre> output<pre><code>Using Unmarshal\nPerson: {Gabriel 25}\n***\nUsing NewDecoder\nPerson2: {Gabriel 25}\n</code></pre></p>"},{"location":"https_network/request/","title":"HTTP Request","text":""},{"location":"https_network/request/#httpget","title":"http.Get","text":"<p>Use <code>http.Get for simple GET requests</code> where you don't need to customize the headers extensively.</p> Example <p>run command<pre><code>go run src/http/basic_http.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n\"io\"\n\"net/http\"\n)\nfunc main() {\nreq, err := http.Get(\"https://www.google.com/\")\nif err != nil {\nfmt.Println(\"Error requesting:\", err)\npanic(err)\n}\ndefer req.Body.Close()\nres, err := io.ReadAll(req.Body)\nif err != nil {\nfmt.Println(\"Error reading response:\", err)\npanic(err)\n}\nfmt.Println(string(res))\n}\n</code></pre> output<pre><code>GOOGLE PAGE IN STRING\n</code></pre></p>"},{"location":"https_network/request/#httppost","title":"http.Post","text":"<p>The <code>http.Post</code> function simplifies the process of sending POST requests. It allows you to <code>specify the URL, the content type, and the request body</code>. It's suitable for <code>simple POST requests</code> where you don't need to customize the headers extensively.</p> Example <p>run command<pre><code>go run src/http/http_post.go\n</code></pre> <pre><code>package main\nimport (\n\"bytes\"\n\"fmt\"\n\"net/http\"\n)\nfunc main() {\npayload := []byte(`{\"key1\": \"value1\", \"key2\": \"value2\"}`)\nbody := bytes.NewBuffer(payload)\nresp, err := http.Post(\"https://httpbin.org/post\", \"application/json\", body)\nif err != nil {\npanic(err)\n}\ndefer resp.Body.Close()\nfmt.Println(\"Status:\", resp.Status)\n}\n</code></pre> output<pre><code>Status: 200 OK\n</code></pre></p>"},{"location":"https_network/request/#httpclient","title":"http.Client","text":"<p>The <code>http.Client object allows customization of the HTTP request behavior</code>, such as setting timeouts, defining transport properties, and managing the client's behavior.</p> http.Client with a 3-second Timeout <p>run command<pre><code>go run src/http/http_client.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\n\"io\"\n\"net/http\"\n\"time\"\n)\nfunc main() {\nclient := http.Client{\nTimeout: time.Second * 3, // Set a timeout for the request\n}\nresp, err := client.Get(\"https://jsonplaceholder.typicode.com/posts/1\")\nif err != nil {\npanic(err)\n}\ndefer resp.Body.Close()\nbody, err := io.ReadAll(resp.Body)\nif err != nil {\npanic(err)\n}\nfmt.Println(string(body))\n}\n</code></pre> output<pre><code>{\n\"userId\": 1,\n    \"id\": 1,\n    \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",\n    \"body\": \"quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto\"\n}\n</code></pre></p>"},{"location":"https_network/request/#httpnewrequest","title":"http.NewRequest","text":"<p>This function <code>creates a new HTTP request</code>. It allows <code>control over the request headers, methods, and request bodies</code>. You can set custom headers, perform more type requests (such as PUT and DELETE), and attach a request body. It's particularly useful for making custom or more complex HTTP requests.</p> Post using Client and NewRequest <p>run command<pre><code>go run src/http/http_newRequest.go\n</code></pre> <pre><code>package main\nimport (\n\"bytes\"\n\"fmt\"\n\"net/http\"\n)\nfunc main() {\npayload := []byte(`{\"key1\": \"value1\", \"key2\": \"value2\"}`)\nbody := bytes.NewBuffer(payload)\nreq, err := http.NewRequest(\"POST\", \"https://httpbin.org/post\", body)\nif err != nil {\npanic(err)\n}\nreq.Header.Set(\"Content-Type\", \"application/json\")\nclient := http.Client{}\nresp, err := client.Do(req)\nif err != nil {\npanic(err)\n}\ndefer resp.Body.Close()\nfmt.Println(\"Status:\", resp.Status)\n}\n</code></pre> output<pre><code>Status: 200 OK\n</code></pre></p>"},{"location":"https_network/request/#httpnewrequestwithcontext","title":"http.NewRequestWithContext","text":"<p>A function that creates a <code>new HTTP request with a specific context</code>. This function is particularly <code>useful when you need to set a deadline, cancel a request, or pass a request-specific value across API boundaries</code>.</p> Post using Client and NewRequestWithContext <p>run command<pre><code>go run src/http/http_NewRequestWithContext.go\n</code></pre> <pre><code>package main\nimport (\n\"context\"\n\"fmt\"\n\"net/http\"\n\"time\"\n)\nfunc main() {\nctx := context.Background()\nctx, cancel := context.WithTimeout(ctx, time.Second*5)\ndefer cancel()\nreq, err := http.NewRequestWithContext(ctx, \"GET\", \"https://jsonplaceholder.typicode.com/posts/1\", nil)\nif err != nil {\npanic(err)\n}\nclient := &amp;http.Client{}\nresp, err := client.Do(req)\nif err != nil {\npanic(err)\n}\ndefer resp.Body.Close()\nfmt.Println(resp.Status)\n}\n</code></pre> output<pre><code>200 OK\n</code></pre></p>"},{"location":"https_network/request/#examples","title":"Examples","text":"<ol> <li>Get Address - Basic API</li> </ol>"},{"location":"https_network/templates/","title":"Templates","text":"<p>Templates are a powerful way to <code>separate the presentation layer from your code logic</code>. The <code>text/template</code> and <code>html/template</code> packages provide functionalities for <code>parsing and executing text and HTML templates</code>. Templates are <code>useful for rendering dynamic content in web applications or generating structured text documents</code>.</p> <p>html/template package</p> <p>The <code>html/template</code> package provides additional HTML-specific features and ensures proper escaping for HTML content.</p> <p>When you use <code>template.Must</code>, it helps <code>simplify error handling when parsing templates</code>. It panics if the template parsing fails, eliminating the need to explicitly check for errors. However, <code>this approach is suitable only during initialization</code>, and the application should terminate if the templates cannot be parsed properly.</p> <p>Example</p> <p>run command<pre><code>go run src/templates/template.go\n</code></pre> <pre><code>package main\nimport (\n\"fmt\"\nhtmlTemplate \"html/template\"\n\"os\"\ntextTemplate \"text/template\"\n)\ntype Person struct {\nName string\nAge  int\n}\nfunc main() {\ntmpl, err := textTemplate.New(\"temple-string\").Parse(\"Hello, {{ .Name }}\")\nif err != nil {\npanic(err)\n}\ndata := struct {\nName string\n}{\nName: \"Gabriel\",\n}\ntmpl.Execute(os.Stdout, data)\nfmt.Println(\"\\n************\")\npersons := [4]Person{\n{Name: \"Gabriel\", Age: 15},\n{Name: \"Cassio\", Age: 40},\n{Name: \"Yuri\", Age: 20},\n{Name: \"Lucas\", Age: 17},\n}\ntmpl_html := htmlTemplate.Must(\nhtmlTemplate.New(\"person.html\").ParseFiles(\"person.html\"))\ntmpl_html.Execute(os.Stdout, persons)\n}\n</code></pre> output<pre><code>Hello, Gabriel\n************\n    &lt;p&gt;All Users:&lt;/p&gt;\n    &lt;h1&gt;Hello, Gabriel!&lt;/h1&gt;\n    &lt;p&gt;Age: 15&lt;/p&gt;\n    &lt;h1&gt;Hello, Cassio!&lt;/h1&gt;\n    &lt;p&gt;Age: 40&lt;/p&gt;\n        &lt;p&gt;Adult User&lt;/p&gt;\n    &lt;h1&gt;Hello, Yuri!&lt;/h1&gt;\n    &lt;p&gt;Age: 20&lt;/p&gt;\n        &lt;p&gt;Adult User&lt;/p&gt;\n    &lt;h1&gt;Hello, Lucas!&lt;/h1&gt;\n    &lt;p&gt;Age: 17&lt;/p&gt;\n</code></pre></p>"},{"location":"https_network/templates/#compose-templates","title":"Compose Templates","text":"<p>You can compose templates by defining reusable parts and embedding them within other templates. This helps in creating modular and maintainable templates.</p> <p>Example</p> <p>run command<pre><code>go run src/templates/compose_template.go\ncurl localhost:8080\n</code></pre> <pre><code>package main\nimport (\n\"html/template\"\n\"net/http\"\n)\ntype Person struct {\nName string\nAge  int\n}\nfunc main() {\nbase_template := template.Must(template.ParseFiles(\n\"header.html\",\n\"person.html\",\n\"footer.html\",\n))\npersons := [4]Person{\n{Name: \"Gabriel\", Age: 15},\n{Name: \"Cassio\", Age: 40},\n{Name: \"Yuri\", Age: 20},\n{Name: \"Lucas\", Age: 17},\n}\nhttp.HandleFunc(\"/\", func(res http.ResponseWriter, request *http.Request) {\nerr := base_template.ExecuteTemplate(res, \"header.html\", persons)\nif err != nil {\npanic(err)\n}\n})\nhttp.ListenAndServe(\":8080\", nil)\n}\n</code></pre> output<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Persons&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;p&gt;All Users:&lt;/p&gt;\n        &lt;h1&gt;Hello, Gabriel!&lt;/h1&gt;\n        &lt;p&gt;Age: 15&lt;/p&gt;\n        &lt;h1&gt;Hello, Cassio!&lt;/h1&gt;\n        &lt;p&gt;Age: 40&lt;/p&gt;\n            &lt;p&gt;Adult User&lt;/p&gt;\n        &lt;h1&gt;Hello, Yuri!&lt;/h1&gt;\n        &lt;p&gt;Age: 20&lt;/p&gt;\n            &lt;p&gt;Adult User&lt;/p&gt;\n        &lt;h1&gt;Hello, Lucas!&lt;/h1&gt;\n        &lt;p&gt;Age: 17&lt;/p&gt;\n        &lt;div&gt;\n        &lt;p&gt;A nice footer here!&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"https_network/templates/#passing-functions","title":"Passing Functions","text":"<p>You can define and use functions with the <code>Funcs field of the template</code> to perform various operations on data. The <code>FuncMap</code> type is used to define a map of template functions.</p> <p>Example</p> <p>run command<pre><code>go run src/templates/passing_func.go\n</code></pre> <pre><code>package main\nimport (\n\"html/template\"\n\"os\"\n\"strings\"\n)\ntype Person struct {\nName string\nAge  int\n}\nfunc printName(s string) string {\nreturn \"Dear \" + s\n}\nfunc main() {\nt := template.New(\"person_func.html\")\nt.Funcs(template.FuncMap{\"upperString\": strings.ToUpper})\nt.Funcs(template.FuncMap{\"printName\": printName})\npersons := [4]Person{\n{Name: \"Gabriel\", Age: 15},\n{Name: \"Cassio\", Age: 40},\n{Name: \"Yuri\", Age: 20},\n{Name: \"Lucas\", Age: 17},\n}\nt = template.Must(t.ParseFiles(\"person_func.html\"))\nt.Execute(os.Stdout, persons)\n}\n</code></pre> output<pre><code>&lt;p&gt;All Users:&lt;/p&gt;\n    &lt;h1&gt;Hello, Dear Gabriel!&lt;/h1&gt;\n    &lt;p&gt;Age: 15&lt;/p&gt;\n    &lt;h1&gt;Hello, Dear Cassio!&lt;/h1&gt;\n    &lt;p&gt;Age: 40&lt;/p&gt;\n        &lt;p&gt;ADULT USER: CASSIO&lt;/p&gt;\n    &lt;h1&gt;Hello, Dear Yuri!&lt;/h1&gt;\n    &lt;p&gt;Age: 20&lt;/p&gt;\n        &lt;p&gt;ADULT USER: YURI&lt;/p&gt;\n    &lt;h1&gt;Hello, Dear Lucas!&lt;/h1&gt;\n    &lt;p&gt;Age: 17&lt;/p&gt;\n</code></pre></p>"},{"location":"https_network/templates/#references","title":"References","text":"<ol> <li>Go - Template Documentation</li> </ol>"},{"location":"projects/get_br_zipcode/","title":"Get Address - Basic API","text":"<p>Help: JSON-to-Go</p> run command<pre><code>cd src/projectapi/\ngo run main.go\ncurl localhost:8080/get-address?zipcode=08295005\ncurl localhost:8080/get-address?zipcode=03087000\ncurl localhost:8080/get-address?zipcode=17509180\n</code></pre> <pre><code>package address\nimport (\n\"encoding/json\"\n\"io\"\n\"net/http\"\n)\ntype Address struct {\nZipCode     string `json:\"cep\"`\nPublicPlace string `json:\"logradouro\"`\nExtra       string `json:\"complemento\"`\nDistrict    string `json:\"bairro\"`\nCity        string `json:\"localidade\"`\nState       string `json:\"uf\"`\nIbge        string `json:\"ibge\"`\nGia         string `json:\"gia\"`\nDdd         string `json:\"ddd\"`\nSiafi       string `json:\"siafi\"`\n}\nfunc GetAddress(zipcode string) (*Address, error) {\nurl := \"https://viacep.com.br/ws/\" + zipcode + \"/json\"\nreq, err := http.Get(url)\nif err != nil {\nreturn nil, err\n}\ndefer req.Body.Close()\nres, _ := io.ReadAll(req.Body)\nvar address Address\nerr = json.Unmarshal(res, &amp;address)\nif err != nil {\nreturn nil, err\n}\nreturn &amp;address, nil\n}\n</code></pre> <pre><code>package main\nimport (\n\"encoding/json\"\n\"fmt\"\n\"log\"\n\"net/http\"\n\"example.com/api.project/address\"\n)\nfunc setHeaders(next http.Handler) http.Handler {\nreturn http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\nres.Header().Set(\"Content-Type\", \"application/json\")\nnext.ServeHTTP(res, req)\n})\n}\nfunc GetAddressHandler(res http.ResponseWriter, req *http.Request) {\nqueryData := req.URL.Query()\nif !queryData.Has(\"zipcode\") {\nres.WriteHeader(http.StatusBadRequest)\nreturn\n}\nzipCodeParam := req.URL.Query().Get(\"zipcode\")\naddress, error := address.GetAddress(zipCodeParam)\nif error != nil {\nres.WriteHeader(http.StatusInternalServerError)\nreturn\n}\nres.WriteHeader(http.StatusOK)\njson.NewEncoder(res).Encode(address)\n}\nfunc main() {\nmux := http.NewServeMux()\nmux.HandleFunc(\"/get-address\", GetAddressHandler)\nmux_wrapped := setHeaders(mux)\nserver := &amp;http.Server{\nAddr:    \":8080\",\nHandler: mux_wrapped,\n}\nfmt.Println(\"Server is listening on port 8080\")\nif err := server.ListenAndServe(); err != nil {\nlog.Fatal(err)\n}\n}\n</code></pre> output<pre><code>{\"cep\":\"08295-005\",\"logradouro\":\"Avenida Miguel Ign\u00e1cio Curi\",\"complemento\":\"\",\"bairro\":\"Vila Carmosina\",\"localidade\":\"S\u00e3o Paulo\",\"uf\":\"SP\",\"ibge\":\"3550308\",\"gia\":\"1004\",\"ddd\":\"11\",\"siafi\":\"7107\"}\n{\"cep\":\"03087-000\",\"logradouro\":\"Rua S\u00e3o Jorge\",\"complemento\":\"\",\"bairro\":\"Parque S\u00e3o Jorge\",\"localidade\":\"S\u00e3o Paulo\",\"uf\":\"SP\",\"ibge\":\"3550308\",\"gia\":\"1004\",\"ddd\":\"11\",\"siafi\":\"7107\"}\n{\"cep\":\"17509-180\",\"logradouro\":\"Avenida Vicente Ferreira\",\"complemento\":\"at\u00e9 470/471\",\"bairro\":\"Mar\u00edlia\",\"localidade\":\"Mar\u00edlia\",\"uf\":\"SP\",\"ibge\":\"3529005\",\"gia\":\"4388\",\"ddd\":\"14\",\"siafi\":\"6681\"}\n</code></pre>"},{"location":"structs/interface/","title":"Interface","text":"<p>In Go, interfaces are a powerful and flexible way to <code>define sets of methods that types must implement</code>. <code>They allow you to write functions and methods that can work with various types, as long as those types satisfy the interface contract</code>. Interfaces support methods but <code>not properties or fields</code>.</p> <p>To declare an interface, <code>you list the method signatures that types must implement</code>. <code>Any type that has methods matching these signatures implicitly implements the interface</code>. To implement an interface, <code>a type needs to provide method implementations that match the method signatures in the interface</code>. If a type has all the required methods, <code>it implicitly satisfies the interface</code>. Interfaces <code>promote polymorphism and decoupling of code</code>.</p> Example <p>run command<pre><code>go run structs/interfaces.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Shape interface {\nArea() float64\n}\ntype Circle struct {\nRadius float64\n}\nfunc (c Circle) Area() float64 {\nreturn 3.14 * c.Radius * c.Radius\n}\ntype Rectangle struct {\nWidth  float64\nHeight float64\n}\nfunc (r Rectangle) Area() float64 {\nreturn r.Width * r.Height\n}\nfunc printArea(s Shape) {\narea := s.Area()\nfmt.Printf(\"Area: %.2f\\n\", area)\n}\nfunc main() {\nc := Circle{Radius: 5.0}\nr := Rectangle{Width: 4.0, Height: 6.0}\nprintArea(c)\nprintArea(r)\n}\n</code></pre> output<pre><code>Area: 78.50\nArea: 24.00\n</code></pre></p>"},{"location":"structs/structs/","title":"Structs","text":"<p>In Go, <code>structs are composite data types used to group together variables (fields) under a single data structure</code>. They are similar to classes in other languages, but <code>Go doesn't have classes in the traditional sense</code>.</p> <p>You define a struct using the <code>type</code> keyword, followed by the <code>name of the struct</code> and a set of field declarations within curly braces. To <code>create an instance</code> of a struct, you can use the <code>struct's name followed by curly braces and provide values for its fields</code>.</p> Example <p>run command<pre><code>go run structs/basic.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Person struct {\nName string\nAge  int\n}\nfunc main() {\nperson := Person{\nName: \"Gabriel\",\nAge:  100,\n}\nfmt.Printf(\"Create object person, from Person struct: %v\\n\", person)\n}\n</code></pre> output<pre><code>Create object person, from Person struct: {Gabriel 100}\n</code></pre></p>"},{"location":"structs/structs/#anonymous-structs","title":"Anonymous Structs","text":"<p>Anonymous Structs are structs without a defined name, often used for <code>temporary data structures</code>.</p> Example <p>run command<pre><code>go run structs/anonymous.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvector := struct {\nX int\nY int\n}{\nX: 10,\nY: 20,\n}\nfmt.Printf(\"Create object from an anonymous structs : %v\\n\", vector)\nfmt.Printf(\"X : %v\\n\", vector.X)\nfmt.Printf(\"Y : %v\\n\", vector.Y)\n}\n</code></pre> output<pre><code>Create object from an anonymous structs : {10 20}\nX : 10\nY : 20\n</code></pre></p>"},{"location":"structs/structs/#composing-structs","title":"Composing Structs","text":"<p>In Go, you can <code>embed one struct within another</code>, creating a composition of structs. This is <code>similar to inheritance</code> in other languages.</p> Example <p>run command<pre><code>go run structs/composing.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Team struct {\nTeamName string\n}\ntype Person struct {\nName string\nAge  int\nTeam\nPersonTeam Team\n}\nfunc main() {\nperson := Person{\nName:       \"Gabriel\",\nAge:        100,\nTeam:       Team{\"Corinthians\"},\nPersonTeam: Team{\"Knicks\"},\n}\nfmt.Printf(\"Person: %v\\n\", person)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.Team)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.Team.TeamName)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.TeamName)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.PersonTeam)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.TeamName)\n}\n</code></pre> output<pre><code>Person: {Gabriel 100 {Corinthians} {Knicks}}\nPerson name: Gabriel, Clube: {Corinthians}\nPerson name: Gabriel, Clube: Corinthians\nPerson name: Gabriel, Clube: Corinthians\nPerson name: Gabriel, Clube: {Knicks}\nPerson name: Gabriel, Clube: Corinthians\n</code></pre></p> Composing x Property, and Accessing Properties <p>In the given example, it's evident that the <code>Person struct is composed of a Team</code> and <code>has a property named PersonTeam of type Team</code>. The key distinction here is that when using the abbreviation <code>person.TeamName</code>, it returns the value of the composition, not the property. In Go, <code>you can directly access the properties of a composed struct</code>.</p>"},{"location":"structs/structs/#struct-methods","title":"Struct Methods","text":"<p>In Go, <code>structs can have methods associated with them</code>. These methods are <code>functions that operate on instances of the struct</code>, and they enable you to define behavior specific to the struct type.</p> Example <p>run command<pre><code>go run structs/methods.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Circle struct {\nRadius float64\n}\nfunc (c Circle) Area() float64 {\nreturn 3.14 * c.Radius * c.Radius\n}\nfunc main() {\ncircle := Circle{Radius: 5.0}\narea := circle.Area()\nfmt.Printf(\"Area: %v\\n\", area)\n}\n</code></pre> output<pre><code>Area: 78.5\n</code></pre></p>"},{"location":"structs/structs/#pointer-receivers","title":"Pointer Receivers","text":"<p><code>Pointer receivers can modify the state of the struct directly</code>. Using a pointer receiver allows you to <code>change the state</code> of an instance directly. When you pass a struct to a function, you're essentially <code>passing a copy of the struct</code>. Using pointers, you can <code>pass a reference to the struct</code>, allowing the function to modify the original data.</p> Example <p>run command<pre><code>go run structs/methods_pointer.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Circle struct {\nRadius float64\n}\nfunc (c Circle) NormalArea() float64 {\nresult := 3.14 * c.Radius * c.Radius\nc.Radius = 100\nreturn result\n}\nfunc (c *Circle) PointerArea() float64 {\nresult := 3.14 * c.Radius * c.Radius\nc.Radius = 100\nreturn result\n}\nfunc main() {\ncircle := Circle{Radius: 5.0}\narea := circle.NormalArea()\nfmt.Printf(\"Area: %v\\n\", area)\nfmt.Printf(\"Circle change? %v\\n\", circle)\narea = circle.PointerArea()\nfmt.Printf(\"Area: %v\\n\", area)\nfmt.Printf(\"Circle change? %v\\n\", circle)\n}\n</code></pre> output<pre><code>Area: 78.5\nCircle change? {5}\nArea: 78.5\nCircle change? {100}\n</code></pre></p>"},{"location":"structs/structs/#pointers-constructors","title":"Pointers Constructors","text":"<p>In Go, when you create a constructor function for a struct, <code>it typically returns a reference to the newly created struct</code>. With this technique, <code>any modification made to the reference returned by the constructor will affect all places that use that reference. This can be quite powerful, especially when managing resources like database connections</code>.</p> Example <p>run command<pre><code>go run structs/constructor_pointer.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype DbConnection struct {\nisOpen   bool\nstr_conn string\n}\nfunc NewDbConnection(str_conn string) *DbConnection {\nreturn &amp;DbConnection{\nisOpen:   true,\nstr_conn: str_conn,\n}\n}\nfunc (conn *DbConnection) Close() {\nconn.isOpen = false\nfmt.Println(\"Closing the DB conncetion \", conn.str_conn)\n}\nfunc main() {\ndbConn := NewDbConnection(\"**nice connection!***\")\ndbConnValue := *dbConn\nperformQuery1(dbConnValue)\nperformQuery2(dbConn)\nperformQuery3(dbConn)\ndbConn.Close()\nperformQuery1(dbConnValue)\nperformQuery2(dbConn)\nperformQuery3(dbConn)\n}\nfunc performQuery1(conn DbConnection) {\nfmt.Println(\"Query 1 executed\", conn.str_conn, conn.isOpen)\n}\nfunc performQuery2(conn *DbConnection) {\nfmt.Println(\"Query 2 executed\", conn.str_conn, conn.isOpen)\n}\nfunc performQuery3(conn *DbConnection) {\nfmt.Println(\"Query 3 executed\", conn.str_conn, conn.isOpen)\n}\n</code></pre> output<pre><code>Query 1 executed **nice connection!*** true\nQuery 2 executed **nice connection!*** true\nQuery 3 executed **nice connection!*** true\nClosing the DB conncetion  **nice connection!***\nQuery 1 executed **nice connection!*** true\nQuery 2 executed **nice connection!*** false\nQuery 3 executed **nice connection!*** false\n</code></pre></p>"},{"location":"structs/structs/#structs-tags","title":"Structs Tags","text":"<p>Struct tags are <code>annotations that can be added to the fields of a struct to provide additional information or metadata about the field</code>. Struct tags are <code>typically used to describe how the struct fields should be encoded or decoded to and from other formats, such as JSON, XML, or other data serialization formats</code>. They play a crucial role in mapping Go data structures to external formats, enabling seamless data interchange between different systems or languages.</p> Example <ol> <li>Struct tags are added to each field to <code>specify the corresponding JSON field names</code>. For example, the json:\"name\" tag indicates that the Name field should be encoded as \"name\" in JSON.</li> <li>The <code>omitempty</code> option in the json:\"address,omitempty\" tag indicates that the Address <code>field should be omitted from the JSON output if it is empty</code>.</li> </ol> <p>run command<pre><code>go run src/structs/tags.go\n</code></pre> <pre><code>package main\nimport (\n\"encoding/json\"\n\"fmt\"\n)\ntype Person struct {\nName    string `json:\"name\"`\nAge     int    `json:\"age\"`\nAddress string `json:\"address,omitempty\"`\n}\nfunc main() {\nperson := Person{Name: \"Gabriel\", Age: 25}\njsonData, err := json.Marshal(person)\nif err != nil {\nfmt.Println(\"Error:\", err)\nreturn\n}\nfmt.Println(\"JSON Data:\", string(jsonData))\n}\n</code></pre> output<pre><code>JSON Data: {\"name\":\"Gabriel\",\"age\":25}\n</code></pre></p>"}]}