{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>A particular but not private repository to centralize all studies about Go and a few famous Go's libraries. It's kind my own documentation about the language. </p>"},{"location":"#gos-paradigms-and-characteristics","title":"Go's Paradigms and Characteristics","text":"<p>Go aims to be both <code>simple and powerful</code>, with the goal of enhancing programmers' productivity. It boasts a straightforward and consistent syntax that remains stable across versions, ensuring <code>compatibility</code>. One of Go's standout features is its robust support for <code>concurrency</code>. It is designed to efficiently leverage multicore processors and excel in handling network-related tasks. In terms of typing, Go follows a <code>static and strong typing system</code>. Here are some key aspects of Go's paradigms and its way of work:</p> Imperative Programming <p>Go follows an imperative programming paradigm, where programs are composed of statements that change a program's state. Imperative programming is characterized by its focus on describing how a program operates by specifying a sequence of commands.</p> Procedural Programming <p>Go supports procedural programming, where programs are organized into procedures or functions that perform specific tasks. Procedural programming emphasizes the use of procedures for code organization and reusability.</p> Structured Programming <p>Structured programming promotes the use of structured control flow constructs like loops and conditionals to improve code readability and maintainability. Go encourages structured programming through its syntax and built-in control flow mechanisms.</p> Concurrent Programming <p>One of Go's key characteristics is its strong support for concurrent programming. Go provides built-in primitives such as goroutines and channels for concurrent execution, making it easier to write efficient and scalable concurrent programs.</p> Functional Programming <p>While Go is not a purely functional programming language, it incorporates some functional programming concepts such as first-class functions, closures, and immutability. These features enable functional programming patterns in Go code, allowing developers to write concise and expressive programs.</p> Static and Strong Typing <p>Go is statically typed, meaning that variable types are determined at compile time and cannot change during runtime. Go is statically typed, which means that variable types are known at compile time and cannot change during program execution. This allows the compiler to perform type checking and catch type-related errors before the program runs, leading to more robust and predictable behavior.</p> Minimalism <p>Go follows a minimalist design philosophy, favoring simplicity and readability over complexity. The language specification and standard library are intentionally kept small to reduce cognitive overhead and make it easier for developers to learn and understand the language.</p> Compiled Language <p>Go is a compiled language, meaning that source code is translated into machine code by a compiler before execution. Compiled languages typically offer better performance and efficiency compared to interpreted languages.</p> Efficiency <p>Go prioritizes efficiency in terms of both execution speed and resource usage. The language is designed to compile quickly and produce binaries that are lightweight and fast, making it suitable for a wide range of applications, including web servers, microservices, and system-level programming.</p>"},{"location":"context/","title":"Context","text":"<p>The <code>context</code> package provides a <code>mechanism for carrying deadlines, cancelation signals, and request-scoped</code> values across API boundaries and between processes. It is designed to <code>facilitate the management of long-running processes</code>, such as handling HTTP requests, canceling operations, or setting timeouts.</p> <p>context.Context</p> <p>This is the primary type representing an incoming request or task. It allows the propagation of deadlines, cancelation signals, and key-value pairs across API boundaries.</p> <p>context.WithCancel</p> <p>This function returns a derived Context and a cancel function. <code>Calling the cancel function signals that the work is done, and all the operations started from this Context should be canceled</code>.</p> <p>context.WithDeadline</p> <p>This function returns a derived Context and a cancel function. <code>It is similar to context.WithTimeout, but it allows you to specify an absolute deadline instead of a relative one</code>.</p> <p>context.WithTimeout</p> <p>This function returns a derived Context and a cancel function. <code>It is commonly used to set a timeout for an operation. After the specified duration, the cancel function is automatically called</code>.</p> <p>context.WithValue</p> <p>This function returns a derived Context with the provided key-value pair. <code>It is used to pass request-scoped values across API boundaries</code>. Normally, is passed metadata.</p> HTTP Server using all context possible <p>run command<pre><code>01. go run src/context/main.go\n02. curl localhost:8080/get-context\n03. curl localhost:8080/get-context AND CTRL + D to cancell the request before 5s\n04. curl localhost:8080/get-context-cancel\n05. curl localhost:8080/get-context-cancel?number=2\n06. curl localhost:8080/get-context-cancel?number=7\n07. curl localhost:8080/get-context-deadline\n08. curl localhost:8080/get-context-deadline?number=2\n09. curl localhost:8080/get-context-deadline?number=7\n10. curl localhost:8080/get-context-timeout\n11. curl localhost:8080/get-context-timeout?number=2\n12. curl localhost:8080/get-context-timeout?number=7\n13. curl localhost:8080/get-context-value\n14. curl localhost:8080/get-context-value?number=2\n15. curl localhost:8080/get-context-value?number=7\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"strconv\"\n    \"time\"\n)\n\nfunc ContextHandler(res http.ResponseWriter, req *http.Request) {\n    ctx := req.Context()\n    // Could be ctx := context.Background()\n    select {\n    case &lt;-time.After(5 * time.Second):\n        res.WriteHeader(http.StatusOK)\n        res.Write([]byte(\"Context completed successfully.\"))\n        return\n    case &lt;-ctx.Done():\n        log.Println(\"Request cancelled by client\")\n        return\n    }\n}\n\nfunc ContextCancelHandler(res http.ResponseWriter, req *http.Request) {\n    // Could be ctx := context.Background()\n    ctx, cancel := context.WithCancel(req.Context())\n    defer cancel()\n    queryParams := req.URL.Query()\n    number := 0\n    if queryParams.Has(\"number\") {\n        num, err := strconv.Atoi(queryParams.Get(\"number\"))\n        if err != nil {\n            res.WriteHeader(http.StatusBadRequest)\n            res.Write([]byte(\"ERROR Parsing number parameter to int\"))\n            return\n        }\n        number = num\n    }\n\n    if number%2 == 0 {\n        res.WriteHeader(http.StatusOK)\n        res.Write([]byte(\"ContextCancel completed successfully.\"))\n        return\n    } else {\n        cancel()\n    }\n\n    select {\n    case &lt;-ctx.Done():\n        res.WriteHeader(http.StatusBadRequest)\n        res.Write([]byte(\"ContextCancel Task canceled or timed out. Number cannot be odd\"))\n        return\n    }\n}\n\nfunc ContextDeadLineHandler(res http.ResponseWriter, req *http.Request) {\n    d := time.Now().Add(5 * time.Second)\n    ctx, cancel := context.WithDeadline(req.Context(), d)\n    defer cancel()\n    queryParams := req.URL.Query()\n    number := 0\n    if queryParams.Has(\"number\") {\n        num, err := strconv.Atoi(queryParams.Get(\"number\"))\n        if err != nil {\n            res.WriteHeader(http.StatusBadRequest)\n            res.Write([]byte(\"ERROR Parsing number parameter to int\"))\n            return\n        }\n        number = num\n    }\n\n    time.Sleep(time.Duration(number) * time.Second)\n    select {\n    case &lt;-ctx.Done():\n        res.WriteHeader(http.StatusBadRequest)\n        res.Write([]byte(\"ContextDeadLineHandler Task canceled or timed out.\"))\n    default:\n        res.WriteHeader(http.StatusOK)\n        res.Write([]byte(\"ContextDeadLineHandler completed successfully.\"))\n    }\n    return\n}\n\nfunc ContextTimeoutHandler(res http.ResponseWriter, req *http.Request) {\n    // Could be ctx := context.Background()\n    ctx, cancel := context.WithTimeout(req.Context(), 3*time.Second)\n    defer cancel()\n\n    queryParams := req.URL.Query()\n    number := 0\n    if queryParams.Has(\"number\") {\n        num, err := strconv.Atoi(queryParams.Get(\"number\"))\n        if err != nil {\n            res.WriteHeader(http.StatusBadRequest)\n            res.Write([]byte(\"ERROR Parsing number parameter to int\"))\n            return\n        }\n        number = num\n    }\n\n    select {\n    case &lt;-time.After(time.Duration(number) * time.Second):\n        res.WriteHeader(http.StatusOK)\n        res.Write([]byte(\"ContextTimeout completed successfully.\"))\n        return\n    case &lt;-ctx.Done():\n        res.WriteHeader(http.StatusRequestTimeout)\n        res.Write([]byte(\"ContextTimeout Task canceled or timed out.\"))\n        return\n    }\n}\n\nfunc ContextValueHandler(res http.ResponseWriter, req *http.Request) {\n    queryParams := req.URL.Query()\n    number := 0\n    if queryParams.Has(\"number\") {\n        num, err := strconv.Atoi(queryParams.Get(\"number\"))\n        if err != nil {\n            res.WriteHeader(http.StatusBadRequest)\n            res.Write([]byte(\"ERROR Parsing number parameter to int\"))\n            return\n        }\n        number = num\n    }\n    parentCtx, cancel := context.WithCancel(req.Context())\n    defer cancel()\n    // Could be ctx := context.Background()\n    ctx := context.WithValue(parentCtx, \"number\", number)\n    fmt.Println(\"Number passed\", ctx.Value(\"number\"))\n\n    if number%2 == 0 {\n        res.WriteHeader(http.StatusOK)\n        res.Write([]byte(\"ContextValue completed successfully\"))\n        return\n    } else {\n        cancel()\n    }\n\n    select {\n    case &lt;-ctx.Done():\n        res.WriteHeader(http.StatusBadRequest)\n        res.Write([]byte(\"ContextValue canceled or timed out. Number cannot be odd\"))\n        return\n    }\n}\n\nfunc main() {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/get-context\", ContextHandler)\n    mux.HandleFunc(\"/get-context-cancel\", ContextCancelHandler)\n    mux.HandleFunc(\"/get-context-deadline\", ContextDeadLineHandler)\n    mux.HandleFunc(\"/get-context-timeout\", ContextTimeoutHandler)\n    mux.HandleFunc(\"/get-context-value\", ContextValueHandler)\n\n    server := &amp;http.Server{\n        Addr:    \":8080\",\n        Handler: mux,\n    }\n    log.Println(\"Server is listening on port 8080\")\n    if err := server.ListenAndServe(); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> output<pre><code>1. 2023/10/30 18:28:01 Server is listening on port 8080\n2. Context completed successfully.\n3. 2023/10/30 18:30:15 Request cancelled by client\n4. ContextCancel completed successfully\n5. ContextCancel completed successfully\n6. ContextCancel Task canceled or timed out. Number cannot be odd\n7. ContextDeadLineHandler completed successfully.\n8. ContextDeadLineHandler completed successfully.\n9. ContextDeadLineHandler Task canceled or timed out.\n10. ContextTimeout completed successfully.\n11. ContextTimeout completed successfully.\n12. ContextTimeout Task canceled or timed out.\n13. ContextValue completed successfully.\n13.1 Number passed 0\n14. ContextValue completed successfully.\n14.1 Number passed 2\n15. ContextValue canceled or timed out. Number cannot be odd.\n15.1 Number passed 7\n</code></pre></p>"},{"location":"generics/","title":"Generics","text":"<p>Generics enables you to write <code>functions and data structures that work with different types while maintaining type safety</code>. You can define functions and structures that operate on various types without sacrificing the compiler's ability to catch type errors at compile time.</p> Example <p>run command<pre><code>go run src/generics/basic.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc FindMax[T int | float64](data []T) T {\n    if len(data) == 0 {\n        return 0\n    }\n\n    max := data[0]\n    for _, value := range data {\n        if value &gt; max {\n            max = value\n        }\n    }\n\n    return max\n}\n\nfunc main() {\n    ints := []int{3, 7, 1, 9, 4, 6}\n    floats := []float64{3.14, 2.71, 1.618, 2.718}\n\n    fmt.Println(\"FindMax integer:\", FindMax(ints))\n    fmt.Println(\"FindMax float:\", FindMax(floats))\n}\n</code></pre> output<pre><code>FindMax integer: 9\nFindMax float: 3.14\n</code></pre></p>"},{"location":"generics/#combine-multiple-types-constraint","title":"Combine Multiple Types (Constraint)","text":"<p>In Go, <code>generic constraints are a way to specify requirements for the type parameters used in generic functions or data structures</code>. Constraints <code>ensure that the generic code can only be used with types that meet certain criteria</code>.</p> Example <p>run command<pre><code>go run src/generics/constraint.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype ValidNumbers interface {\n    int | float64\n}\n\nfunc FindMax[T ValidNumbers](data []T) T {\n    if len(data) == 0 {\n        return 0\n    }\n\n    max := data[0]\n    for _, value := range data {\n        if value &gt; max {\n            max = value\n        }\n    }\n\n    return max\n}\n\nfunc main() {\n    ints := []int{3, 7, 1, 9, 4, 6}\n    floats := []float64{3.14, 2.71, 1.618, 2.718}\n\n    fmt.Println(\"FindMax integer:\", FindMax(ints))\n    fmt.Println(\"FindMax float:\", FindMax(floats))\n}\n</code></pre> output<pre><code>FindMax integer: 9\nFindMax float: 3.14\n</code></pre></p>"},{"location":"generics/#tilde-closer-than-identical-types","title":"Tilde(~) - Closer Than Identical Types","text":"<p>The special tilde (<code>~</code>) symbol, often referred to as the <code>approximation constraint</code>, is used in Go generics to <code>indicate that a type should approximately match one of the specified types or their derived types</code>. <code>Without the tilde, the function or method constrained by generic types would only accept exact types declared in the constraints and not their derived types</code>. The tilde allows for a broader match, including derived types, making your code more flexible and accommodating related types.</p> Example <p>run command<pre><code>go run src/generics/approximation_constraint.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\ntype NumberInt int\ntype NumberFloat float64\n\ntype ValidNumbers interface {\n    ~int | ~float64\n}\n\nfunc FindMax[T ValidNumbers](data []T) T {\n    if len(data) == 0 {\n        return 0\n    }\n\n    max := data[0]\n    for _, value := range data {\n        if value &gt; max {\n            max = value\n        }\n    }\n\n    return max\n}\n\nfunc main() {\n    ints := []NumberInt{3, 7, 1, 9, 4, 6}\n    floats := []NumberFloat{3.14, 2.71, 1.618, 2.718}\n\n    fmt.Println(\"FindMax integer:\", FindMax(ints))\n    fmt.Println(\"FindMax float:\", FindMax(floats))\n}\n</code></pre> output<pre><code>FindMax integer: 9\nFindMax float: 3.14\n</code></pre></p>"},{"location":"generics/#comparable","title":"Comparable","text":"<p>In Go generics, you can use the <code>comparable constraint</code> to specify that a type should be comparable. This constraint ensures that the type can be used with comparison operators like <code>==</code> and <code>!=</code>.</p> Example <p>run command<pre><code>go run src/generics/comparable.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc CheckNumbers[T comparable](a T, b T) bool {\n    if a == b {\n        return true\n    }\n    return false\n}\n\nfunc FindIndex[T comparable](data []T, value T) int {\n    for i, data_value := range data {\n        if data_value == value {\n            return i\n        }\n    }\n    return -1\n}\n\nfunc main() {\n    fmt.Println(\"CheckNumbers: \", CheckNumbers(10, 10.5))\n    fmt.Println(\"CheckNumbers: \", CheckNumbers(10.5, 10.5))\n\n    ints := []int{3, 7, 1, 9, 4, 6}\n    fmt.Println(\"FindMax integer:\", FindIndex(ints, 300))\n    fmt.Println(\"FindMax integer:\", FindIndex(ints, 9))\n    fmt.Println(\"FindMax integer:\", FindIndex(ints, 10))\n}\n</code></pre> output<pre><code>CheckNumbers:  false\nCheckNumbers:  true\nFindMax integer: -1\nFindMax integer: 3\nFindMax integer: -1\n</code></pre></p>"},{"location":"generics/#references","title":"References","text":"<ul> <li>An Introduction to Generics in Go</li> </ul>"},{"location":"pointers/","title":"Pointers","text":"<p>In Go, pointers are <code>variables that store memory addresses</code>. <code>They are used to reference values rather than holding the values themselves</code>. It allows you to <code>indirectly access and modify the value of the variable</code> it points to. Pointers are represented using the <code>*</code> symbol.</p> <p>To <code>access the value that a pointer points to</code>, you can use the <code>*</code> symbol again. This is called <code>dereferencing the pointer</code>. The <code>&amp;</code> operator is <code>used to obtain the memory address of a variable</code>. This memory address is also known as a pointer.</p> <p>Example</p> <p>run command<pre><code>go run src/structs/pointers.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    x := 42\n    fmt.Println(\"Value of x: \", x)\n\n    ptr := &amp;x\n    fmt.Println(\"Value that ptr point to: \", *ptr)\n    fmt.Println(\"Memory address of ptr: \", ptr)\n    *ptr = 100\n    fmt.Println(\"Updated value of x: \", x)\n}\n</code></pre> output<pre><code>Value of x:  42\nValue that ptr point to:  42\nMemory address of ptr:  0xc0000120f0\nUpdated value of x:  100\n</code></pre></p>"},{"location":"basics/control_flow/","title":"Control Flow","text":"<p>Listing the fundamental and commonly used control flow structures in Go.</p>"},{"location":"basics/control_flow/#for","title":"for","text":"Example <p>run command<pre><code>go run src/control_flow/for.go\n</code></pre> src/control_flow/for.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 0; i &lt; 5; i++ {\n        fmt.Println(\"Basic for type 1: \", i)\n    }\n    fmt.Println(\"*********\")\n\n    j := 2\n    for j &lt; 5 {\n        fmt.Println(\"Basic for type 2: \", j)\n        j++\n    }\n    fmt.Println(\"*********\")\n\n    arr := []int{1, 2, 3, 4, 5}\n    for index, value := range arr {\n        fmt.Println(\"arr for, index: \", index, \"value \", value)\n    }\n    fmt.Println(\"*********\")\n\n    myMap := map[string]int{\"a\": 1, \"b\": 2, \"c\": 3}\n    for key, value := range myMap {\n        fmt.Println(\"map for, key: \", key, \"value \", value)\n    }\n}\n</code></pre> output<pre><code>Basic for type 1:  0\nBasic for type 1:  1\nBasic for type 1:  2\nBasic for type 1:  3\nBasic for type 1:  4\n*********\nBasic for type 2:  2\nBasic for type 2:  3\nBasic for type 2:  4\n*********\narr for, index:  0 value  1\narr for, index:  1 value  2\narr for, index:  2 value  3\narr for, index:  3 value  4\narr for, index:  4 value  5\n*********\nmap for, key:  a value  1\nmap for, key:  b value  2\nmap for, key:  c value  3\n</code></pre></p>"},{"location":"basics/control_flow/#switch","title":"switch","text":"Example <p>run command<pre><code>go run src/control_flow/switch.go\n</code></pre> src/control_flow/switch.go<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    day := \"Monday\"\n\n    switch day {\n    case \"Monday\":\n        fmt.Println(\"Today is Monday.\")\n    case \"Tuesday\":\n        fmt.Println(\"Today is Tuesday.\")\n    case \"Wednesday\":\n        fmt.Println(\"Today is Wednesday.\")\n    default:\n        fmt.Println(\"It's some other day.\")\n    }\n}\n</code></pre> output<pre><code>Today is Monday.\n</code></pre></p>"},{"location":"basics/handle_files/","title":"Handle Files","text":""},{"location":"basics/handle_files/#create-a-file","title":"Create a File","text":"<p>To create a file, you can use the <code>os.Create</code> function along with the defer statement to close the file after writing to it.</p> Example <p>run command<pre><code>go run src/handle_files/create_file.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    file, err := os.Create(\"src/handle_files/example.txt\")\n    defer file.Close()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n}\n</code></pre></p>"},{"location":"basics/handle_files/#write-into-a-file","title":"Write into a File","text":"<p>Open the file in <code>append mode</code> and write to it using the <code>os.OpenFile</code> function.</p> Example <p>run command<pre><code>go run src/handle_files/write_file.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    file, err := os.OpenFile(\"src/handle_files/example.txt\", os.O_APPEND|os.O_WRONLY, 0644)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer file.Close()\n\n    size, err := file.WriteString(\"\\nWriting a string into the file\\n\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"Size written into file: \", size)\n    _, err = file.Write([]byte(\"Using bytes to write\"))\n}\n</code></pre></p>"},{"location":"basics/handle_files/#file-permission-number","title":"File Permission Number","text":"<p>In the <code>os.OpenFile</code> function, the <code>perm argument is used to specify the file permission when creating or opening a file</code>. It is an integer value that represents the file mode and permission bits. The typical file permission values used in Unix-like systems are represented in octal notation. <code>The permission mode is composed of three digits, each of which represents the permissions for different user groups</code>.</p> <ol> <li><code>Owner Permissions</code>: The first digit represents the permissions for the file owne.</li> <li><code>Group Permissions</code>: The second digit represents the permissions for the group that the file belongs to.</li> <li><code>Other Permissions</code>: The third digit represents the permissions for everyone else (other users).</li> </ol> <p>The digits in the mode are a sum of permission bits:</p> <ol> <li><code>4: Read (r)</code></li> <li><code>2: Write (w)</code></li> <li><code>1: Execute (x)</code></li> </ol> <p>And calculate the permissions numbers:</p> <ol> <li><code>6 (4 + 2) means read and write permissions (rw)</code>.</li> <li><code>4 (only 4) means read-only (r).</code>.</li> <li><code>7 (4 + 2 + 1) means read, write, and execute permissions (rwx).</code>.</li> </ol> Example <ol> <li><code>0644</code>: Owner has read and write (6), group and others have read-only (4).</li> <li><code>0755</code>: Owner has read, write, and execute (7), group and others have read and execute (5).</li> <li><code>0600</code>: Owner has read and write (6), no permissions for group and others.</li> </ol>"},{"location":"basics/handle_files/#reading-a-file","title":"Reading a File","text":"<p>To read from a file, you can use the <code>os.Open</code> function along with a <code>Scanner from the bufio package</code>.</p> Example <p>run command<pre><code>go run src/handle_files/read_file.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    file, err := os.Open(\"src/handle_files/example.txt\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer file.Close()\n\n    scanner := bufio.NewScanner(file)\n    for scanner.Scan() {\n        fmt.Println(scanner.Text())\n    }\n}\n</code></pre> output<pre><code>Writing a string into the file\nUsing bytes to write\n</code></pre></p>"},{"location":"basics/handle_files/#delete-a-file","title":"Delete a File","text":"<p>To delete a file, you can use the <code>os.Remove</code> function.</p> Example <p>run command<pre><code>go run src/handle_files/delete_file.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    err := os.Remove(\"src/handle_files/example.txt\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(\"File deleted successfully.\")\n}\n</code></pre></p>"},{"location":"basics/packages/","title":"Packages, Modules and Workspaces","text":""},{"location":"basics/packages/#packages","title":"Packages","text":"<p>Every <code>.go file begins with the package command</code>, and the <code>package's name should match the directory in which the file resides</code>. The exceptions to this rule are <code>package main</code> and <code>package test</code> which serve as the entry points for applications and tests, respectively. <code>Packages within the same directory should share the same package name. Anything within the same package can be accessed and utilized</code>.</p> Simple package example <p>run command<pre><code>go run src/packages/*\n</code></pre> src/packages/nice_func.go<pre><code>package main\n\nfunc nice_func() {\n    println(\"   I'm on the same directory than main, so my package has to be main\")\n}\n</code></pre> src/packages/main.go<pre><code>package main\n\nfunc main() {\n    println(\"Starting script\")\n    println(\"Now, calling nice_func that is defined from the same file directory, on nice_func.go file\")\n    nice_func()\n}\n</code></pre> output<pre><code>Starting script\nNow, calling nice_func that is defined from the same file directory, on nice_func.go file\n    I'm on the same directory than main, so my package has to be main\n</code></pre></p>"},{"location":"basics/packages/#installing-packages","title":"Installing Packages","text":"<p>See Go Get and Go Mod TIDY.</p>"},{"location":"basics/packages/#modules","title":"Modules","text":"<p>In Go, a <code>module is a collection of related Go packages that are versioned together as a single unit</code>. Modules are the key component of the Go module system, <code>introduced to manage package dependencies and versioning</code>.</p> <p>A Go module typically consists of one or more Go packages, <code>along with a go.mod file that defines the module's requirements and dependencies</code>. The go.mod file keeps track of the module's dependencies, versions, and the other modules it requires.</p> <p>To create a new module in Go, you can use the go mod init command followed by the name of the module.</p> <p>Public and Private Access</p> <p>In Go, the concept of <code>public and private access is determined by the first letter's case of a variable or function name</code>. If the first letter of an identifier is in <code>uppercase</code>, it is <code>exported and can be accessed from other packages</code>. On the other hand, if the first letter is <code>lowercase</code>, the identifier is considered <code>unexported and can only be accessed within the same package</code>.</p> <p>This convention helps maintain encapsulation and ensures that package-level variables and functions are used only where intended.</p> Example <p>run command<pre><code>cd src/modules/\ngo run main.go\n</code></pre> src/modules/mathpackage/mathpackage.go<pre><code>package mathpackage\n\nimport \"fmt\"\n\nfunc sum[T int | float64](a, b T) T {\n    fmt.Println(\"   Accessing sum function. Private to mathpackage\")\n    return a + b\n}\n\nfunc SumInt(a, b int) int {\n    return sum(a, b)\n}\n\nfunc SumFloat(a, b float64) float64 {\n    return sum(a, b)\n}\n</code></pre> src/modules/car_package/car_package.go<pre><code>package carpackage\n\nimport (\n    \"time\"\n)\n\ntype Car struct {\n    Name     string\n    NickName string\n    Year     int\n}\n\ntype fullCarPrivate struct {\n    FullName string\n    Year     int\n    YearOld  int\n}\n\nfunc (c Car) CreateFullCar() fullCarPrivate {\n    yearNow := time.Now().Year()\n    finalCar := fullCarPrivate{\n        FullName: c.Name + \" \" + c.NickName,\n        Year:     c.Year,\n        YearOld:  yearNow - c.Year,\n    }\n    return finalCar\n}\n</code></pre> src/modules/main.go<pre><code>package main\n\nimport (\n    \"fmt\"\n    carpackage \"start/modules/car_package\"\n    \"start/modules/mathpackage\"\n)\n\nfunc main() {\n    intSum := mathpackage.SumInt(50, 21)\n    fmt.Println(\"Result of SumInt: \", intSum)\n    floatSum := mathpackage.SumFloat(3.14, 17.8)\n    fmt.Println(\"Result of SumFloat: \", floatSum)\n\n    fmt.Println(\"****\")\n    fmt.Println(\"Starting explore Car Module\")\n    car := carpackage.Car{\n        Name:     \"Corolla\",\n        NickName: \"Giant car\",\n        Year:     2020,\n    }\n    fullCar := car.CreateFullCar()\n    fmt.Println(\"Full Car name: \", fullCar.FullName)\n    fmt.Println(\"Full Car Years Old: \", fullCar.YearOld)\n}\n</code></pre> output<pre><code>    Accessing sum function. Private to mathpackage\nResult of SumInt:  71\n    Accessing sum function. Private to mathpackage\nResult of SumFloat:  20.94\n****\nStarting explore Car Module\nFull Car name:  Corolla Giant car\nFull Car Years Old:  3\n</code></pre></p>"},{"location":"basics/packages/#workspaces","title":"Workspaces","text":"<p>Introduced in Go 1.18, Go Workspaces allow developers to <code>work on multiple modules simultaneously without having to edit go.mod files for each module</code>. Each module within a workspace is treated as a main module when resolving dependencies.</p> <p>To create a workspace, is necessary to execute go work init command. This will create a <code>go.work</code> file. The <code>go.work</code> file has <code>use</code> and <code>replace</code> directives that <code>override the individual go.mod files</code>, so there is no need to edit each <code>go.mod</code> file individually. The <code>use</code> directive adds a module on disk to the set of main modules in a workspace, while the <code>replace</code> directive replaces the contents of a specific version of a module, or all versions of a module, with contents found elsewhere.</p> <p><code>Workspaces are flexible and support a variety of workflows</code>. For example, you can add a feature to an upstream module and use it in your own module, work with multiple interdependent modules in the same repository, or switch between different dependency configurations.</p>"},{"location":"basics/packages/#references","title":"References","text":"<ul> <li>Go Expert - FullCycle</li> </ul>"},{"location":"cli/general/","title":"Go's CLI","text":"<p>Go's Command Line Interface (CLI) <code>refers to the set of tools and utilities provided by the Go</code> programming language that developers can use directly from the terminal or command prompt. The Go CLI is designed to be straightforward and efficient, allowing developers to perform common tasks quickly and with minimal configuration. It's an integral part of the Go ecosystem, enabling rapid development and deployment of Go applications.</p> <p>These tools facilitate various tasks such as <code>compiling code</code>, <code>managing dependencies</code>, <code>running tests</code>, and more. Here's a brief overview:</p> <ul> <li>go build: Compiles Go source files into executable binaries.</li> <li>go get: Downloads and installs packages and dependencies required for a Go project.</li> <li>go mod: Manages module dependencies for Go projects, which includes tasks like initializing modules, adding requirements, and tidying up dependencies.</li> <li>go env: Lists all Go environment variables.</li> <li>go run: Compiles and runs Go programs without explicitly creating an executable file.</li> <li>go test: Executes unit tests within Go packages to ensure code correctness.</li> <li>go fmt: Automatically formats Go source code according to the official style guidelines.</li> <li>go vet: Analyzes Go source code for potential issues that may not necessarily prevent compilation but could lead to bugs or unidiomatic code.</li> <li>go doc: Generates documentation for Go packages in various formats.</li> <li>go list: Lists all the packages named by the import paths, one per line.</li> </ul>"},{"location":"cli/general/#go-env","title":"go env","text":"<p>Lists all Go <code>environment variables</code>.</p> <p>go env</p> <pre><code>$ go env\nGO111MODULE=''\nGOARCH='amd64'\nGOBIN=''\nGOCACHE='/home/gabriel/.cache/go-build'\nGOENV='/home/gabriel/.config/go/env'\nGOEXE=''\n...\n</code></pre> full output <pre><code>GO111MODULE=''\nGOARCH='amd64'\nGOBIN=''\nGOCACHE='/home/gabriel/.cache/go-build'\nGOENV='/home/gabriel/.config/go/env'\nGOEXE=''\nGOEXPERIMENT=''\nGOFLAGS=''\nGOHOSTARCH='amd64'\nGOHOSTOS='linux'\nGOINSECURE=''\nGOMODCACHE='/home/gabriel/go/pkg/mod'\nGONOPROXY=''\nGONOSUMDB=''\nGOOS='linux'\nGOPATH='/home/gabriel/go'\nGOPRIVATE=''\nGOPROXY='https://proxy.golang.org,direct'\nGOROOT='/usr/local/go'\nGOSUMDB='sum.golang.org'\nGOTMPDIR=''\nGOTOOLCHAIN='auto'\nGOTOOLDIR='/usr/local/go/pkg/tool/linux_amd64'\nGOVCS=''\nGOVERSION='go1.21.1'\nGCCGO='gccgo'\nGOAMD64='v1'\nAR='ar'\nCC='gcc'\nCXX='g++'\nCGO_ENABLED='1'\nGOMOD='/dev/null'\nGOWORK=''\nCGO_CFLAGS='-O2 -g'\nCGO_CPPFLAGS=''\nCGO_CXXFLAGS='-O2 -g'\nCGO_FFLAGS='-O2 -g'\nCGO_LDFLAGS='-O2 -g'\nPKG_CONFIG='pkg-config'\nGOGCCFLAGS='-fPIC -m64 -pthread -Wl,--no-gc-sections -fmessage-length=0 -ffile-prefix-map=/tmp/go-build4097433368=/tmp/go-build -gno-record-gcc-switches'\n</code></pre> <p>GOPATH variable</p> <p><code>GOPATH</code> is a variable that <code>defines the root of your workspace</code>. It stores your code base and all the files necessary for your development. <code>It also contains the binaries of your compilations and the libraries used.</code></p> <p>GOMODCACHE variable</p> <p><code>GOMODCACHE</code> is related to <code>Go module management</code>, which is used for handling dependencies. It is <code>typically a subfolder within your GOPATH</code>.</p>"},{"location":"cli/general/#go-get","title":"go get","text":"<p>To install packages in Go, you can use the <code>go get command followed by the package name</code>.</p> <p>Module Initialized</p> <p><code>Make sure that you have initialized Go modules in your project</code> (with go mod init) <code>before running the go get command</code>. This ensures that the go.mod file exists in the root of your project directory.</p> <p>It is also used to update and manage dependencies in your <code>GOPATH</code>. Some helpful subcommands you can use with go get:</p> <ol> <li><code>-u</code>: Update the package and install the latest version;</li> <li><code>-d</code>: Download the package's source code but do not install it.</li> <li><code>-t</code>: Also download the packages needed to run tests.</li> <li><code>-v</code>: Enable verbose output to see the package being fetched and installed.</li> </ol> <p>Example</p> <pre><code>$ go get github.com/google/uuid\n$ go get github.com/google/uuid@1.0.0 # version 1.0.0\n$ go get github.com/google/uuid@abcdef1234567890 # commit hash abcdef1234567890\n$ go get -u github.com/google/uuid\n$ go get -d github.com/google/uuid\n$ go get -t github.com/google/uuid\n$ go get -v github.com/google/uuid\n</code></pre>"},{"location":"cli/general/#go-build","title":"go build","text":"<p>The <code>go build</code> command is used to compile packages and dependencies <code>into an executable binary file</code>. This command compiles the Go source files in the current directory and creates an executable binary file.</p> <p>Building a <code>single file</code> in Go can be done by simply using the <code>go build filename.go</code> command followed by the name of the file. This command will <code>generate an executable binary based on the contents of the specified filename.go source file</code>.</p> <p>Building a single file</p> <pre><code>go build filename.go\n</code></pre> <p>For <code>projects  that utilize the go.mod file</code> can be achieved by running the go build <code>command in the root directory of the project</code>. This command automatically builds the project, resolving dependencies defined in the <code>go.mod</code> file.</p> <p>Building a project</p> <pre><code>go build\n</code></pre> <p>When building the code is possible to configure behaviors to build the code. <code>Build variables</code> are environment variables that influence the behavior of the <code>go build</code> command. <code>They allow you to customize the build process</code>, define build constraints, and pass additional flags to the compiler. Here's a concise summary of Build Variables.</p> <p>Some of variables</p> <ol> <li><code>GOARCH</code>: Specifies the target architecture for the binary, such as amd64, arm, 386, etc.</li> <li><code>GOOS</code>: Defines the target operating system, like linux, windows, darwin (macOS), etc.</li> <li><code>GOROOT</code>: Sets the location of the Go standard library and tools.</li> <li><code>GOPATH</code>: Specifies the workspace directory where Go looks for source code and dependencies.</li> <li><code>CGO_ENABLED</code>: Controls whether cgo is enabled for cross-compilation. Set to 1 to enable, 0 to disable.</li> <li><code>GO111MODULE</code>: Determines the module mode for the current build. Can be set to on, off, or auto.</li> <li><code>GOFLAGS</code>: Allows passing additional flags to the go build command.</li> <li><code>GOBIN</code>: Defines the directory where compiled executables are placed.</li> <li><code>GOPROXY</code>: Specifies the URL of the proxy server for downloading modules.</li> <li><code>GOMOD</code>: Used to point to a specific go.mod file when building a module.</li> <li><code>GODEBUG</code>: Enables debugging output for certain runtime components.</li> </ol> <p>In Go, <code>GOOS</code> is an environment variable that specifies the <code>target operating system for code compilation</code>. The <code>GOARCH</code> is an environment variable that specifies the <code>target architecture for code compilation</code>. To find out the possibilities for <code>GOOS</code> and <code>GOARCH</code>, use go tool dist list.</p> <p>To find out the available values for operating system and platform, checkout go tool dist list</p> <p>Example</p> <pre><code>GOOS=[target-OS] GOARCH=[target-architecture] go build\n</code></pre>"},{"location":"cli/general/#go-tool","title":"go tool","text":"<p><code>go tool</code> is a suite of command-line tools included with the Go programming language distribution. <code>These tools are designed to assist developers in various aspects of software development, including code analysis, testing, performance profiling, and more</code>. The <code>go tool</code> command itself is a <code>meta-command</code> that provides access to several subcommands, each serving a distinct purpose.</p> <p>Here's a brief description of some commonly used <code>go tool</code> subcommands:</p> <ul> <li><code>go tool compile</code>: Compiles Go source files into object files.</li> <li><code>go tool link</code>: Links object files together to produce an executable binary.</li> <li><code>go tool nm</code>: Lists the symbols from object files.</li> <li><code>go tool objdump</code>: Displays information from object files.</li> <li><code>go tool trace</code>: Visualizes execution traces of Go programs.</li> <li><code>go tool pprof</code>: Analyzes and visualizes performance profiles of Go programs.</li> <li><code>go tool cover</code>: Provides code coverage analysis for Go tests.</li> <li><code>go tool vet</code>: Reports suspicious constructs in Go source code.</li> <li><code>go tool yacc</code>: Generates parsers from yacc-like grammar files.</li> <li><code>go tool pack</code>: Packs object files into archive files.</li> <li><code>go tool cgo</code>: Handles C code generation and linking for programs that use cgo.</li> </ul> <p>Each of these tools is specialized for a particular task and can be used individually or in combination with other tools to achieve complex development workflows. The <code>go tool</code> suite is an essential part of the Go ecosystem, providing powerful functionality that complements the core features of the language and its standard library.</p>"},{"location":"cli/general/#go-tool-dist-list","title":"go tool dist list","text":"<p>List all operating systems and platforms are available for building executables.</p> <p>Example</p> <pre><code>$ go tool dist list\nandroid/386\nandroid/arm\nandroid/arm64\n...\n</code></pre>"},{"location":"cli/general/#go-work","title":"go work","text":"<p>Go 1.18 adds workspace mode to Go, which lets you <code>work on multiple modules simultaneously</code> without having to edit go.mod files for each module. <code>Each module within a workspace is treated as a main module when resolving dependencies</code>. With Go workspaces, <code>you control all your dependencies using a go.work file in the root of your workspace directory</code>. The go.work file has use and replace directives that override the individual go.mod files, <code>so there is no need to edit each go.mod file individually</code>.</p> Before workpaces <p>Previously, <code>to add a feature to one module and use it in another module, you needed to either publish the changes to the first module, or edit the go.mod file of the dependent module with a replace directive for your local, unpublished module changes</code>. In order to publish without errors, you had to remove the replace directive from the dependent module\u2019s go.mod file after you published the local changes to the first module.</p> <p>Creating a workspace</p> <p>To create a workspace, you can use the <code>go work init</code> command with a list of module directories as space-separated arguments. The workspace <code>doesn\u2019t need to contain the modules you\u2019re working with</code>. The init command creates a <code>go.work</code> file that lists modules in the workspace. If you run go work init without arguments, the command creates an empty workspace.</p> <pre><code>$ go work init module1 module2 ...\n</code></pre> <p>Add modules to a workspace</p> <p>To add modules to the workspace, you can run <code>go work use</code> or manually edit the <code>go.work</code> file.</p> <p><pre><code>go work use [moddir]\n</code></pre> The <code>go work use -r</code> command can be used to recursively add directories in the argument directory with a <code>go.mod</code> file to your workspace</p> <pre><code>go work use -r .\n</code></pre>"},{"location":"cli/general/#refereces","title":"Refereces","text":"<ul> <li>How To Build Go Executables for Multiple Platforms on Ubuntu 20.04</li> <li>Tutorial: Getting started with multi-module workspaces</li> </ul>"},{"location":"cli/go_mod/","title":"Go Modules","text":"<p><code>go mod</code> is a command in the Go programming language that <code>manages module dependencies</code> for Go projects. Introduced in Go 1.11, Go Modules aimed to improve the experience of developing Go applications by simplifying dependency management.</p>"},{"location":"cli/go_mod/#go-mod-init","title":"go mod init","text":"<p>This command <code>initializes a new module with the specified path</code>. You can then <code>add dependencies to the module using the</code> go get command <code>and manage the module's requirements through the go.mod file</code>.</p> <p>Create a new module</p> <pre><code>go mod init {module-path}\n</code></pre> <p>Standard for modules name</p> <p><code>It's a good practice to use the location of the repository where Go tools can find the module's source code as the module path</code>, especially if you're planning to publish the module for others to use. <code>Be sure to specify a module path that won\u2019t conflict with the module path of other modules</code>.</p>"},{"location":"cli/go_mod/#go-mod-tidy","title":"go mod tidy","text":"<p>This is a command that <code>ensures that the go.mod file matches the source code in the module</code>. <code>It adds any missing and removes any unused module dependencies</code>, keeping the go.mod file clean and ensuring that it accurately reflects the actual dependencies needed for your project.</p> <p>Matching dependencies used in source code</p> <pre><code>$ go mod tidy\n</code></pre> Has a module initialize <p><code>Make sure that you have initialized Go modules in your project (with go mod init) before running the go mod tidy command</code>. This ensures that the go.mod file exists in the root of your project directory. There more complex edits that can be found running <code>go help mod edit</code> or checking the documentation.</p> <p>The -e flag</p> <p>The <code>-e</code> flag, causes <code>go mod tidy to attempt to proceed despite errors encountered while loading packages</code>.</p> <pre><code>go mod tidy -e\n</code></pre>"},{"location":"cli/go_mod/#go-mod-edit","title":"go mod edit","text":"<p>The <code>go mod edit</code> command allows you to <code>make changes to the module's requirements and dependencies</code>.</p> <p>Example</p> <p><pre><code>go mod edit -require=example.com/module@v1.2.3\n</code></pre> remove a requirement<pre><code>go mod edit -droprequire=example.com/module\n</code></pre></p> <p>go mod edit -replace</p> <p>The <code>go mod edit --replace</code> command in Go is used to add or update a replace directive in the go.mod file.</p> <pre><code>go mod edit --replace=example.com/module=../local/module\n</code></pre> <p><code>HOWEVER, it's recommended to utilize workspaces, as go mod edit may encounter limitations outside the local environment</code>.</p>"},{"location":"cli/go_mod/#references","title":"References","text":"<ul> <li>Managing dependencies</li> </ul>"},{"location":"cobra_cli/","title":"Cobra CLI","text":"<p>Cobra is a library for creating powerful modern <code>CLI applications</code> in Go. It provides a <code>simple interface to create powerful CLI interfaces</code>, similar to git or docker. It has a robust command handling system, including support for nested commands, global flags, and more. The library also includes functionality for generating auto-completion scripts, help text, and usage instructions.</p>"},{"location":"cobra_cli/#start-project","title":"Start Project","text":"<p>Example</p> <p>The <code>cobra-cli init</code> command is used to <code>initialize a new Cobra application</code>. This command sets up the initial application code structure for you, allowing you to immediately start benefiting from the features of Cobra. It also has the capability to apply the <code>license</code> you specify to your application.</p> <pre><code>```bash\ncobra-cli init\n```\n</code></pre>"},{"location":"cobra_cli/#commands","title":"Commands","text":"<p>At its core, Cobra is built on a <code>structure of commands, arguments, and flags</code>. Commands represent actions, arguments are things, and flags are modifiers for those actions. The pattern to follow is <code>APPNAME COMMAND ARG --FLAG</code>. For instance, in the command <code>hugo server --port=1313</code>, <code>server</code> is a command, and <code>port</code> is a flag.</p>"},{"location":"cobra_cli/#add-a-new-command","title":"Add a new Command","text":"<p>The add command in Cobra CLI is a method used to <code>add a new command to a Cobra application</code>. This command is <code>added to the root command of your application and can be accessed via the command line interface</code>.</p> <p>Info</p> <pre><code>cobra-cli add {command_name}\n</code></pre> <p>For each command added, a new file in <code>cmd</code> folder will be created.</p> Example <pre><code>/*\nCopyright \u00a9 2024 NAME HERE &lt;EMAIL ADDRESS&gt;\n*/\npackage cmd\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/spf13/cobra\"\n)\n\nvar text string\nvar testCommandCmd = &amp;cobra.Command{\n    Use:   \"testCommand\",\n    Short: \"A brief description of your command\",\n    Long: `A longer description that spans multiple lines and likely contains examples\nand usage of using your command. For example:\n\nCobra is a CLI library for Go that empowers applications.\nThis application is a tool to generate the needed files\nto quickly create a Cobra application.`,\n    Run: func(cmd *cobra.Command, args []string) {\n        upperCommand, _ := cmd.Flags().GetBool(\"uppercase\")\n\n        if upperCommand == true {\n            fmt.Println(strings.ToUpper(text))\n        } else {\n            fmt.Println(strings.ToLower(text))\n        }\n\n    },\n}\n\nfunc init() {\n    rootCmd.AddCommand(testCommandCmd)\n    testCommandCmd.Flags().StringVarP(&amp;text, \"text\", \"t\", \"\", \"Text to print\")\n    testCommandCmd.MarkFlagRequired(\"text\")\n\n    testCommandCmd.Flags().BoolP(\"uppercase\", \"u\", false, \"Should print in uppercase\")\n\n    // Here you will define your flags and configuration settings.\n\n    // Cobra supports Persistent Flags which will work for this command\n    // and all subcommands, e.g.:\n    // testCommandCmd.PersistentFlags().String(\"foo\", \"\", \"A help for foo\")\n\n    // Cobra supports local flags which will only run when this command\n    // is called directly, e.g.:\n    // testCommandCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\")\n}\n</code></pre> <p>In this example, <code>testCommand</code> is a new command that is defined with a short description, a long description, and a <code>function to execute when the command is run</code>. <code>The init function is called when the package is initialized</code>, and it adds the cmdAdd command to the root command of the application.</p> <p>Once you've defined the add command, you can access it via the command line by typing <code>yourApplicationName add</code>.</p>"},{"location":"cobra_cli/#subcommands","title":"Subcommands","text":"<p><code>Subcommands are commands that are part of other commands</code>. They allow you to create complex command structures in your CLI application, making it easier to manage and navigate. To create a nested command in Cobra, you <code>first define the parent command, then add the nested command to it</code>.</p> <p>Info</p> <pre><code>$ cobra-cli add category\n$ cobra-cli add create -p 'categoryCmd'\n$ cobra-cli add list -p 'categoryCmd'\n</code></pre> Example <p><pre><code>package cmd\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar categoryCmd = &amp;cobra.Command{\n    Use:   \"category\",\n    Short: \"A brief description of your command\",\n    Long: `A longer description that spans multiple lines and likely contains examples\nand usage of using your command.`,\n    Run: func(cmd *cobra.Command, args []string) {\n        cmd.Help()\n    },\n}\n\nfunc init() {\n    // add to rootCmd\n    rootCmd.AddCommand(categoryCmd)\n    categoryCmd.PersistentFlags().String(\"name\", \"\", \"Name of the category\")\n}\n</code></pre> <pre><code>package cmd\n\nimport (\n    \"fmt\"\n\n    \"github.com/spf13/cobra\"\n)\n\nvar createCmd = &amp;cobra.Command{\n    Use:   \"create\",\n    Short: \"A brief description of your command\",\n    Long: `A longer description that spans multiple lines and likely contains examples\nand usage of using your command.`,\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"create called\")\n    },\n}\n\nfunc init() {\n    // add to categoryCmd\n    categoryCmd.AddCommand(createCmd)\n    createCmd.Flags().String(\"created_type\", \"\", \"The Category type to be created\")\n}\n</code></pre> <pre><code>package cmd\n\nimport (\n    \"fmt\"\n\n    \"github.com/spf13/cobra\"\n)\n\nvar listCmd = &amp;cobra.Command{\n    Use:   \"list\",\n    Short: \"A brief description of your command\",\n    Long: `A longer description that spans multiple lines and likely contains examples\nand usage of using your command.`,\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"list called\")\n    },\n}\n\nfunc init() {\n    // add to categoryCmd\n    categoryCmd.AddCommand(listCmd)\n}\n</code></pre> <pre><code>$ go run main.go category\nA longer description that spans multiple lines and likely contains examples\nand usage of using your command.\n\nUsage:\ncobra_cli_example category [flags]\ncobra_cli_example category [command]\n\nAvailable Commands:\ncreate      A brief description of your command\nlist        A brief description of your command\n\nFlags:\n-h, --help   help for category\n\nUse \"cobra_cli_example category [command] --help\" for more information about a command.\n$\n$ go run main.go category create\ncreate called\n$ go run main.go category list\nlist called\n</code></pre></p>"},{"location":"cobra_cli/#argumentsflags","title":"Arguments/Flags","text":"<p>Arguments in Cobra CLI are <code>values that can be passed to commands</code>. They are typically used to provide input data to the command. <code>Arguments are used to modify the behavior of a command</code>. They can be both <code>global</code> and <code>local</code>.</p> Example <p><pre><code>/*\nCopyright \u00a9 2024 NAME HERE &lt;EMAIL ADDRESS&gt;\n*/\npackage cmd\n\nimport (\n    \"fmt\"\n    \"strings\"\n\n    \"github.com/spf13/cobra\"\n)\n\nvar text string\nvar testCommandCmd = &amp;cobra.Command{\n    Use:   \"testCommand\",\n    Short: \"A brief description of your command\",\n    Long: `A longer description that spans multiple lines and likely contains examples\nand usage of using your command. For example:\n\nCobra is a CLI library for Go that empowers applications.\nThis application is a tool to generate the needed files\nto quickly create a Cobra application.`,\n    Run: func(cmd *cobra.Command, args []string) {\n        upperCommand, _ := cmd.Flags().GetBool(\"uppercase\")\n\n        if upperCommand == true {\n            fmt.Println(strings.ToUpper(text))\n        } else {\n            fmt.Println(strings.ToLower(text))\n        }\n\n    },\n}\n\nfunc init() {\n    rootCmd.AddCommand(testCommandCmd)\n    testCommandCmd.Flags().StringVarP(&amp;text, \"text\", \"t\", \"\", \"Text to print\")\n    testCommandCmd.MarkFlagRequired(\"text\")\n\n    testCommandCmd.Flags().BoolP(\"uppercase\", \"u\", false, \"Should print in uppercase\")\n\n    // Here you will define your flags and configuration settings.\n\n    // Cobra supports Persistent Flags which will work for this command\n    // and all subcommands, e.g.:\n    // testCommandCmd.PersistentFlags().String(\"foo\", \"\", \"A help for foo\")\n\n    // Cobra supports local flags which will only run when this command\n    // is called directly, e.g.:\n    // testCommandCmd.Flags().BoolP(\"toggle\", \"t\", false, \"Help message for toggle\")\n}\n</code></pre> <pre><code>$ go run main.go testCommand -t \"Salve o Corinthians\"\nsalve o corinthians\n$ go run main.go testCommand -t \"Salve o Corinthians\" -u\nSALVE O CORINTHIANS\n</code></pre></p>"},{"location":"cobra_cli/#local-and-global-flags","title":"Local and Global Flags","text":"Local <p>A flag associated with a specific command.</p> <p><pre><code>package cmd\n\nimport (\n    \"fmt\"\n\n    \"github.com/spf13/cobra\"\n)\n\nvar createCmd = &amp;cobra.Command{\n    Use:   \"create\",\n    Short: \"A brief description of your command\",\n    Long: `A longer description that spans multiple lines and likely contains examples\nand usage of using your command.`,\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"create called\")\n    },\n}\n\nfunc init() {\n    // add to categoryCmd\n    categoryCmd.AddCommand(createCmd)\n    createCmd.Flags().String(\"created_type\", \"\", \"The Category type to be created\")\n}\n</code></pre> <pre><code>$ go run main.go category create -h\nA longer description that spans multiple lines and likely contains examples\nand usage of using your command.\n\nUsage:\ncobra_cli_example category create [flags]\n\nFlags:\n    --created_type string   The Category type to be created\n-h, --help                  help for create\n\nGlobal Flags:\n    --name string   Name of the category\n</code></pre></p> Global <p><pre><code>package cmd\n\nimport (\n    \"github.com/spf13/cobra\"\n)\n\nvar categoryCmd = &amp;cobra.Command{\n    Use:   \"category\",\n    Short: \"A brief description of your command\",\n    Long: `A longer description that spans multiple lines and likely contains examples\nand usage of using your command.`,\n    Run: func(cmd *cobra.Command, args []string) {\n        cmd.Help()\n    },\n}\n\nfunc init() {\n    // add to rootCmd\n    rootCmd.AddCommand(categoryCmd)\n    categoryCmd.PersistentFlags().String(\"name\", \"\", \"Name of the category\")\n}\n</code></pre> <pre><code>$ go run main.go category\nA longer description that spans multiple lines and likely contains examples\nand usage of using your command.\n\nUsage:\ncobra_cli_example category [flags]\ncobra_cli_example category [command]\n\nAvailable Commands:\ncreate      A brief description of your command\nlist        A brief description of your command\n\nFlags:\n-h, --help          help for category\n    --name string   Name of the category\n\nUse \"cobra_cli_example category [command] --help\" for more information about a command.\n</code></pre></p> <p>A flag persistent across multiple commands.</p>"},{"location":"cobra_cli/#hooks","title":"Hooks","text":"<p>Cobra does not natively support hooks, but you can achieve similar functionality using the <code>RunE</code>, <code>PreRun</code>, <code>PreRunE</code>, <code>PostRun</code>, and <code>PostRunE</code> functions. These functions allow you to specify what happens before and after a command runs.</p> Example <p><pre><code>package cmd\n\nimport (\n    \"fmt\"\n\n    \"github.com/spf13/cobra\"\n)\n\nvar hookCmdCmd = &amp;cobra.Command{\n    Use:   \"hookCmd\",\n    Short: \"A brief description of your command\",\n    Long: `A longer description that spans multiple lines and likely contains examples\nand usage of using your command.`,\n    PreRun: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"PRE RUN\")\n    },\n    Run: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"hookCmd called\")\n    },\n    PostRun: func(cmd *cobra.Command, args []string) {\n        fmt.Println(\"POST RUN\")\n    },\n}\n\nfunc init() {\n    rootCmd.AddCommand(hookCmdCmd)\n}\n</code></pre> <pre><code>$ go run main.go hookCmd\nPRE RUN\nhookCmd called\nPOST RUN\n</code></pre></p>"},{"location":"cobra_cli/#references","title":"References","text":"<ol> <li>Cobra GitHub</li> <li>Cobra</li> </ol>"},{"location":"db/basic/","title":"Databases","text":"<p>The <code>database/sql</code> package in Go <code>provides a generic interface around SQL (or SQL-like) databases</code>. It allows you to interact with various SQL databases using the same functions, <code>regardless of the specific database backend</code>.</p>"},{"location":"db/basic/#sqlopen","title":"sql.Open","text":"<p>The <code>sql.Open</code> function is used to <code>open a database specified by its driver name and a driver-specific data source name</code>. This function does not generate an error in the event of an incorrect password, driver, etc. Use <code>db.Ping</code> to check if the connection is successful.</p>"},{"location":"db/basic/#sqlprepare","title":"sql.Prepare","text":"<p>The <code>db.Prepare</code> function is used to <code>create a prepared statement for later queries or executions</code>. Prepared statements are advantageous when you need to execute the same or similar SQL statements repeatedly with high efficiency.</p>"},{"location":"db/basic/#queryrow","title":"QueryRow","text":"<p>The <code>QueryRow</code> method is used to <code>execute a query that is expected to return at most one row</code>.</p>"},{"location":"db/basic/#scan","title":"Scan","text":"<p>The <code>Scan</code> method is then used to  <code>read the values from the current row into variables</code>. This method expects a list of destination variables as arguments, which it fills with the values from the columns in the result set.</p>"},{"location":"db/basic/#code-example","title":"Code example","text":"<p>Example</p> <pre><code>package main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n\n    _ \"github.com/go-sql-driver/mysql\"\n    \"github.com/google/uuid\"\n)\n\ntype Product struct {\n    ID    string\n    Name  string\n    Price float64\n}\n\nfunc NewProduct(name string, price float64) *Product {\n    return &amp;Product{\n        ID:    uuid.New().String(),\n        Name:  name,\n        Price: price,\n    }\n}\n\nfunc insertProduct(db *sql.DB, product Product) error {\n    stmt, err := db.Prepare(\"INSERT INTO products (id, name, price) VALUES (?, ?, ?)\")\n    if err != nil {\n        return err\n    }\n    defer stmt.Close()\n    _, err = stmt.Exec(product.ID, product.Name, product.Price)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc updateProduct(db *sql.DB, product *Product) error {\n    stmt, err := db.Prepare(\"UPDATE products SET name = ?, price = ? WHERE id = ?\")\n    if err != nil {\n        return err\n    }\n    defer stmt.Close()\n    err = db.Ping()\n    if err != nil {\n        panic(err.Error())\n    }\n\n    _, err = stmt.Exec(product.Name, product.Price, product.ID)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc selectProduct(db *sql.DB, id string) (*Product, error) {\n    stmt, err := db.Prepare(\"SELECT * FROM products WHERE id = ?\")\n    if err != nil {\n        return nil, err\n    }\n    defer stmt.Close()\n    var product Product\n    err = stmt.QueryRow(id).Scan(&amp;product.ID, &amp;product.Name, &amp;product.Price)\n    if err != nil {\n        return nil, err\n    }\n    return &amp;product, nil\n}\n\nfunc selectAllProducts(db *sql.DB) ([]Product, error) {\n    rows, err := db.Query(\"SELECT * FROM products\")\n    if err != nil {\n        return nil, err\n    }\n    defer rows.Close()\n    var products []Product\n    var p Product\n    for rows.Next() {\n        err = rows.Scan(&amp;p.ID, &amp;p.Name, &amp;p.Price)\n        if err != nil {\n            return nil, err\n        }\n        products = append(products, p)\n    }\n    return products, nil\n}\n\nfunc deleteProduct(db *sql.DB, id string) error {\n    stmt, err := db.Prepare(\"DELETE FROM products WHERE id = ?\")\n    if err != nil {\n        return err\n    }\n    defer stmt.Close()\n    _, err = stmt.Exec(id)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc main() {\n\n    db, err := sql.Open(\"mysql\", \"root:root@tcp(localhost:3306)/goexpert\")\n    if err != nil {\n        panic(err)\n    }\n    defer db.Close()\n    product := NewProduct(\"Car\", 7.35)\n    err = insertProduct(db, *product)\n    if err != nil {\n        panic(err)\n    }\n    product = NewProduct(\"Notebook\", 7.35)\n    err = insertProduct(db, *product)\n    if err != nil {\n        panic(err)\n    }\n    product.Price = 1900.00\n    err = updateProduct(db, product)\n    if err != nil {\n        panic(err)\n    }\n\n    db_product, err := selectProduct(db, product.ID)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(db_product)\n    fmt.Println(\"********\")\n    deleteProduct(db, product.ID)\n    all_products, err := selectAllProducts(db)\n    if err != nil {\n        panic(err)\n    }\n    for _, p := range all_products {\n        fmt.Println(p)\n    }\n}\n</code></pre>"},{"location":"db/migrations/","title":"Migrations","text":"<p>The migrate library is a Go package that provides a <code>framework for managing database schema changes</code>. It supports various databases such as PostgreSQL, MySQL, SQLite, and others. The library allows you to <code>write migration scripts in SQL, JSON, YAML, etc.</code>, and then apply these scripts to your database using the command line interface or programmatically within your Go application.</p>"},{"location":"db/migrations/#key-features","title":"Key Features","text":"<p>Database Support</p> <p>The library supports a wide range of databases including PostgreSQL, MySQL, SQLite, and others. This makes it versatile and suitable for different projects that may use different types of databases.</p> <p>Script Types</p> <p>You can write your migration scripts in several formats including SQL, JSON, YAML, etc. This flexibility allows you to choose the format that best suits your project's needs.</p> <p>Command Line Interface</p> <p>The library comes with a command line interface that allows you to manage your database schema without writing any Go code. You can use this interface to create new migrations, apply existing ones, rollback migrations, etc.</p> <p>Programmatic Usage</p> <p>In addition to the command line interface, you can also use the library programmatically within your Go application. This gives you more control over how and when your migrations are applied.</p>"},{"location":"db/migrations/#cli","title":"CLI","text":"<p>The CLI is a powerful tool that allows you to <code>manage your database schema directly from the terminal</code>. Here are some common commands you might use.</p> <p>Migrate up</p> <p>This command applies all available migrations to the specified database.</p> <pre><code>$ migrate -path /path/to/migrations -database postgres://localhost:5432/mydb?sslmode=disable up\n</code></pre> <p>Migrate down</p> <p>This command undoes the last batch of migrations.</p> <pre><code>$ migrate -path /path/to/migrations -database postgres://localhost:5432/mydb?sslmode=disable down\n</code></pre> <p>Migrate force</p> <p>This command forces the migration version to be 1, effectively rolling back all migrations.</p> <pre><code>$ migrate -path /path/to/migrations -database postgres://localhost:5432/mydb?sslmode=disable force 1\n</code></pre> <p>Migrate version</p> <p>This command prints the current migration version.</p> <pre><code>$ migrate -path /path/to/migrations -database postgres://localhost:5432/mydb?sslmode=disable version\n</code></pre>"},{"location":"db/migrations/#go-programmatic-use","title":"Go - Programmatic Use","text":"<p>The Go language API provides more control and flexibility, allowing you to integrate database migrations into your Go applications.</p> <p>Example</p> <pre><code>package main\n\nimport (\n    \"database/sql\"\n    \"log\"\n\n    \"github.com/golang-migrate/migrate\"\n    _ \"github.com/lib/pq\"\n)\n\nfunc main() {\n    db, err := sql.Open(\"postgres\", \"postgres://localhost:5432/mydb?sslmode=disable\")\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    driver, err := postgres.WithInstance(db, &amp;postgres.Config{})\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    m, err := migrate.NewWithDatabaseInstance(\n        \"file://migrations\",\n        \"postgres\", driver)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    if err := m.Up(); err != nil &amp;&amp; err != migrate.ErrNoChange {\n        log.Fatal(err)\n    }\n}\n</code></pre>"},{"location":"db/sqlx/","title":"SQLX","text":"<p>The sqlx library is a powerful tool in Go that provides a set of <code>extensions on Go's standard database/sql package</code>. It offers a more convenient and efficient way to interact with databases. The library supports several database drivers, including MySQL, PostgreSQL, SQLite3, and others.</p> <p>One of the key features of sqlx is its <code>ability to map query results to struct fields, rather than requiring the developer to manually scan the result rows</code>. This feature simplifies the process of working with complex data structures and reduces the likelihood of errors. Another significant feature is the <code>support for named parameters in queries</code>. This makes SQL queries easier to read and write, especially when dealing with large numbers of parameters. Moreover, <code>sqlx</code> also provides a set of convenience <code>functions and methods that extend the functionality of the standard database/sql package</code>. These include functions for executing queries, retrieving rows, and handling transactions.</p> <p>In summary, the sqlx library offers a comprehensive solution for interacting with databases in Go. Its features <code>simplify the process of working with databases</code>, reduce the potential for errors, and provide a more enjoyable development experience.</p>"},{"location":"db/sqlx/#references","title":"References","text":"<ol> <li>SQLX GitHub</li> </ol>"},{"location":"di/wire/","title":"Wire","text":"<p>Wire is a powerful <code>code generation tool</code> designed to automate the process of connecting components through <code>dependency injection</code> in Golang. By representing <code>dependencies as function parameters, Wire encourages explicit initialization over the use of global variables</code>. Unlike some other dependency injection tools for Go, such as dig, <code>Wire operates without relying on runtime state or reflection</code>. This characteristic not only ensures efficient code execution but also makes code written for <code>Wire compatible with manual initialization</code>.</p>"},{"location":"di/wire/#key-features","title":"Key Features","text":"<p>Code Generation</p> <p>Wire operates as a code generator, <code>eliminating the need for calls to a runtime library</code>. This approach facilitates introspection of initialization and ensures accurate cross-references.</p> <p>Providers and Injectors</p> <p>Wire introduces two core concepts - <code>providers</code> and <code>injectors</code>. <code>Providers are functions that produce values, while injectors call providers in dependency order</code>. This enables clean and organized initialization of components.</p> <p>Provider Sets</p> <p>Providers can be grouped into provider sets, a convenient way to <code>manage and use multiple providers together when necessary</code>.</p>"},{"location":"di/wire/#generating-code","title":"Generating code","text":"<p>Build Constrains</p> <p>To generate the injector, add the build constraint <code>//+build wireinject</code> to your code. A build constraint, also known as a <code>build tag</code>, is a condition under which a file should be included in the package. Build constraints are given by a line comment that begins.</p> <p>To generate code, run Wire in the package directory with the <code>wire.go</code> present. The generated implementation of the injector will be saved in a file named <code>wire_gen.go</code>.</p> <p>Example</p> <pre><code>wire\n</code></pre> wire<pre><code>//go:build wireinject\n// +build wireinject\n\n// The build tag makes sure the stub is not built in the final build.\n\npackage main\n\nimport (\n    \"database/sql\"\n\n    \"github.com/RomeroGabriel/dependency-inversion/product\"\n    \"github.com/RomeroGabriel/dependency-inversion/user\"\n    \"github.com/google/wire\"\n)\n\n// Provider: a function that can produce a value.\n// Sets are useful if several providers will frequently be used together.\nvar setRepositoryDependency = wire.NewSet(\n    product.NewProductRepository,\n    wire.Bind(new(product.ProductRepositoryInterface), new(*product.ProductRepository)),\n    user.NewUserRepository,\n    wire.Bind(new(user.UserRepositoryInterface), new(*user.UserRepository)),\n)\n\nfunc NewProductUseCase(db *sql.DB) *product.ProductUseCase {\n    wire.Build(\n        setRepositoryDependency,\n        product.NewProductUseCase,\n    )\n    return &amp;product.ProductUseCase{}\n}\n\nfunc NewUserUseCase(db *sql.DB) *user.UserUseCase {\n    wire.Build(\n        setRepositoryDependency,\n        user.NewUserUseCase,\n    )\n    return &amp;user.UserUseCase{}\n}\n</code></pre> wire_gen<pre><code>// Code generated by Wire. DO NOT EDIT.\n\n//go:generate go run github.com/google/wire/cmd/wire\n//go:build !wireinject\n// +build !wireinject\n\npackage main\n\nimport (\n    \"database/sql\"\n    \"github.com/RomeroGabriel/dependency-inversion/product\"\n    \"github.com/RomeroGabriel/dependency-inversion/user\"\n    \"github.com/google/wire\"\n)\n\nimport (\n    _ \"github.com/mattn/go-sqlite3\"\n)\n\n// Injectors from wire.go:\n\nfunc NewProductUseCase(db *sql.DB) *product.ProductUseCase {\n    productRepository := product.NewProductRepository(db)\n    productUseCase := product.NewProductUseCase(productRepository)\n    return productUseCase\n}\n\nfunc NewUserUseCase(db *sql.DB) *user.UserUseCase {\n    userRepository := user.NewUserRepository(db)\n    userUseCase := user.NewUserUseCase(userRepository)\n    return userUseCase\n}\n\n// wire.go:\n\n// Provider: a function that can produce a value.\n// Sets are useful if several providers will frequently be used together.\nvar setRepositoryDependency = wire.NewSet(product.NewProductRepository, wire.Bind(new(product.ProductRepositoryInterface), new(*product.ProductRepository)), user.NewUserRepository, wire.Bind(new(user.UserRepositoryInterface), new(*user.UserRepository)))\n</code></pre>"},{"location":"di/wire/#references","title":"References","text":"<ol> <li>Hire GitHub</li> <li>Build Constraints</li> <li>Compile-time Dependency Injection With Go Cloud's Wire</li> </ol>"},{"location":"functions/","title":"Functions","text":""},{"location":"functions/#definition-and-arguments","title":"Definition and Arguments","text":"<p>The <code>func</code> keyword introduces a function definition, followed by the function name and a list of formal parameters enclosed in parentheses. Functions can take zero or more parameters. Parameters are declared with their type. <code>When function parameters share the same type, you can declare the type once for all of them</code>.</p> <p>When you pass <code>parameters to a function, they are typically passed by copy</code>. This means that a copy of the value is made, and <code>any changes you make to the parameter within the function do not affect the original value outside of the function</code>. To change the parameters passed, use pointers and pointers receivers.</p> Example <p>run command<pre><code>go run function/basic.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    print_double(6)\n    sum_result := sum(7, 3)\n    fmt.Printf(\"sum_result is: %d\\n\", sum_result)\n}\n\nfunc print_double(double int) {\n    result := double * 2\n    fmt.Printf(\"Double of %d: %d\\n\", double, result)\n}\n\nfunc sum(num1, num2 int) int {\n    return num1 + num2\n}\n</code></pre> output<pre><code>Double of 6: 12\nsum_result is: 10\n</code></pre></p>"},{"location":"functions/#variadic-functions","title":"Variadic Functions","text":"<p>Go allows you to define <code>functions that can accept a variable number of arguments</code>. You use the <code>...</code> notation before the type of the last parameter</p> Example <p>run command<pre><code>go run function/func_variadic.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc sum(numbers ...int) int {\n    total := 0\n    for _, num := range numbers {\n        total += num\n    }\n    return total\n}\n\nfunc main() {\n    result := sum(1, 2, 3, 4, 5, 6, 7, 8, 9)\n    fmt.Printf(\"Result %d\\n\", result)\n}\n</code></pre> output<pre><code>Result 45\n</code></pre></p>"},{"location":"functions/#return","title":"Return","text":"<p>Functions in Go can indeed <code>return multiple values</code>. When a function is called, it can produce multiple results. <code>Functions can declare named return values</code>, which act as variables. This can make the code more readable by specifying what the function is returning.</p> Example <p>run command<pre><code>go run function/return.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    result, is_even := sum_check_even(1, 2)\n\n    fmt.Printf(\"result is: %d\\n\", result)\n    if is_even {\n        fmt.Printf(\"result is even!!!\\n\")\n    }\n\n    result, is_even = sum_check_even(2, 2)\n    fmt.Printf(\"result is: %d\\n\", result)\n    if is_even {\n        fmt.Printf(\"result is even!!!\\n\")\n    }\n\n}\n\nfunc sum_check_even(num1, num2 int) (result int, is_even bool) {\n    result = num1 + num2\n    is_even = result%2 == 0\n    return\n}\n</code></pre> output<pre><code>result is: 3\nresult1 is: 4\nresult1 is even!!!\n</code></pre></p>"},{"location":"functions/#error-handling","title":"Error Handling","text":"<p>In Go, error handling differs significantly from languages that use try/catch blocks. <code>Go intentionally does not have try/catch mechanisms because it encourages a different approach to handling errors</code>. Instead, functions in Go often <code>return multiple values, where the last value is typically an error</code>.</p> Example <p>run command<pre><code>go run function/return_error.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\nfunc main() {\n    result, err := divide(10, 2)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Println(\"Result:\", result)\n    }\n\n    result, err = divide(10, 0)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    } else {\n        fmt.Println(\"Result:\", result)\n    }\n}\n</code></pre> output<pre><code>Result: 5\nError: division by zero\n</code></pre></p>"},{"location":"functions/#anonymous-functions-closures","title":"Anonymous Functions (Closures)","text":"<p>Go supports anonymous functions, <code>which can be assigned to variables or passed as arguments</code> to other functions. <code>They can capture and use variables from their surrounding scope</code>.</p> Example <p>run command<pre><code>go run function/closures.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    add := func(a, b int) int {\n        return a + b\n    }\n\n    result1 := add(2, 4)\n    fmt.Printf(\"result1 %d\\n\", result1)\n    result1 = add(3, 4)\n    fmt.Printf(\"result1 %d\\n\", result1)\n    result1 = add(4, 4)\n    fmt.Printf(\"result1 %d\\n\", result1)\n}\n</code></pre> output<pre><code>result1 6\nresult1 7\nresult1 8\n</code></pre></p>"},{"location":"functions/#defer","title":"Defer","text":"<p>In Go, the defer statement is used to <code>schedule a function call to be executed just before the surrounding function returns</code>. It is often used to simplify functions that perform various clean-up actions. <code>defer is commonly used for tasks such as closing files, unlocking mutexes, or generally executing clean-up actions</code>. The deferred call's arguments are <code>evaluated immediately, but the function call is not executed until the surrounding function returns</code>. It's important to note that <code>defer statements are executed in Last In, First Out (LIFO) order</code>. Multiple defer statements will be executed in the reverse order of their definition.</p> Example <p>In this code, \"Hello\" is printed first, and then the rest is printed.  This is because the defer statement <code>defers the execution tatement until after the surrounding function main finishes</code>.</p> <p>run command<pre><code>go run function/defer.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    defer fmt.Println(\"World\")\n\n    fmt.Println(\"Hello\")\n\n    defer fmt.Println(\"Hi, testttting\")\n}\n</code></pre> output<pre><code>Hello\nHi, testttting\nWorld\n</code></pre></p>"},{"location":"fundamentals/literals/","title":"Literals","text":"<p>A Go literal  is an explicitly specified <code>number</code>, <code>character</code>, or <code>string</code>. Go programs have four common kinds of literals.</p> <ol> <li>Interger literal</li> <li>Float literal</li> <li>Rune literal</li> <li>String literal</li> </ol> <p>Literals are considered <code>untyped</code>.</p>"},{"location":"fundamentals/vars/","title":"Variables and Constants","text":"<p>In Go, <code>variables and constants are strongly typed</code>. To declare a constant, you use the <code>const</code> keyword, and for variables, you use <code>var</code>. Go can also <code>automatically infer variable types</code>, providing various syntaxes for declaring variables and constants, as shown below.</p> Simple Vars Example <p>run command<pre><code>$ go run src/fundamentals/vars/basic.go\nStarting basic variables\nPrint A const:  I'm a constant\nPrint B var:  false\nNOTICE: B was infer as false\n\nDifferent ways to declare a variable: \nFull declaration:  A\nShort hand: B\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nconst A = \"I'm a constant\"\n\nvar B bool\n\nfunc main() {\n    fmt.Println(\"Starting basic variables\")\n    fmt.Println(\"Print A const: \", A)\n    fmt.Println(\"Print B var: \", B)\n    fmt.Println(\"NOTICE: B was infer as false\")\n    println()\n    fmt.Println(\"Different ways to declare a variable: \")\n    var full_declare string = \"A\"\n    fmt.Println(\"Full declaration: \", full_declare)\n    short_hand := \"B\"\n    fmt.Println(\"Short hand: \" + short_hand)\n}\n</code></pre></p>"},{"location":"fundamentals/vars/#checking-default-infered-types","title":"Checking Default Infered Types","text":"<p>Go assigns a default zero value to any variable that is declared but not assigned a value. Having an explicit zero value makes code clearer and removes a source of bugs.</p> Default Infered Types <p>run command<pre><code>$ go run src/fundamentals/vars/infer_types.go\nbool: false\nint: 0\nstring: \nfloat32: 0\nfloat64: 0\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nvar (\n    b  bool\n    c  int\n    d  string\n    e  float32\n    e6 float64\n)\n\nfunc main() {\n    fmt.Println(\"bool:\", b)\n    fmt.Println(\"int:\", c)\n    fmt.Println(\"string:\", d)\n    fmt.Println(\"float32:\", e)\n    fmt.Println(\"float64:\", e6)\n}\n</code></pre></p>"},{"location":"fundamentals/vars/#explict-type-conversion","title":"Explict Type Conversion","text":"<p>In Go, automatic type promotion between variables is not permitted. Whenever variable types do not align, explicit type conversion is necessary. Even when dealing with integers and floats of varying sizes, they must be converted to the same type before interaction. This approach ensures clarity regarding the intended data type.</p> <p>Since all type conversions in Go are explicit, <code>you cannot treat another Go type as a boolean</code>. Unlike some languages where a nonzero number or a nonempty string can be interpreted as true, <code>Go doesn't support such implicit conversions</code>. No other type can be directly converted to a boolean, <code>either implicitly or explicitly</code>. If there's a need to convert from another data type to boolean, it's necessary to use one of the <code>comparison operators explicitly</code>.</p> Converting Types <p>run command<pre><code>$ go run src/fundamentals/type_conversion.go\nExample: Converting Int and Float\nSum1:  25.5\nSum2:  25\n\nExample: Converting Int and Byte\nSum3:  110\nSum4:  110\n\nRight way to compare string\nRight way to compare int\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc intFloatConversion() {\n    fmt.Println(\"Example: Converting Int and Float\")\n    x := 10\n    y := 15.5\n    var sum1 float64 = y + float64(x)\n    var sum2 int = x + int(y)\n    fmt.Println(\"Sum1: \", sum1)\n    fmt.Println(\"Sum2: \", sum2)\n    fmt.Println()\n}\n\nfunc intByteConversion() {\n    fmt.Println(\"Example: Converting Int and Byte\")\n    x := 10\n    var y byte = 100\n    var sum3 int = x + int(y)\n    var sum4 byte = y + byte(x)\n    fmt.Println(\"Sum3: \", sum3)\n    fmt.Println(\"Sum4: \", sum4)\n    fmt.Println()\n}\n\nfunc stringIntBoolComparison() {\n    var str string = \"\"\n    // if str -&gt; will not work\n    // if str == true -&gt; will not work\n    if str == \"\" {\n        fmt.Println(\"Right way to compare string\")\n    }\n\n    // if intNum -&gt; will not work\n    // if intNum == true -&gt; will not work\n    var intNum int = 1\n    if intNum == 1 {\n        fmt.Println(\"Right way to compare int\")\n    }\n}\n\nfunc main() {\n    intFloatConversion()\n    intByteConversion()\n    stringIntBoolComparison()\n}\n</code></pre></p>"},{"location":"fundamentals/vars/#beyond-constants","title":"Beyond Constants","text":"<p>In Go, <code>constants serve as identifiers for literals</code>, providing a means to assign meaningful names to values. These constants are restricted to holding values determinable by the compiler during compilation. Unlike some other languages, <code>Go lacks built-in support for declaring values computed at runtime as immutable</code>. Consequently, there are no immutable arrays, slices, maps, or structs in Go. Furthermore, there's no inherent mechanism to declare a field within a struct as immutable.</p> <p>Resume</p> <ol> <li>Constant can only hold values determinable in compile-time<ul> <li>Numeric Literals</li> <li>Boolean</li> <li>Strings/Runes</li> </ul> </li> <li>There are no ways to declare immutable values in runtime</li> <li>Arrays, slices, maps, or structs are not immutable</li> <li>No mechanism to declare struct fields as immutable</li> </ol> <p>Constants in Go can be <code>typed</code> or <code>untyped</code>. An untyped constant behaves like a literal; it has no type but <code>defaults to a specific type</code> when no other type can be inferred. In contrast, a typed constant can only be assigned directly to a variable of its designated type. The decision to designate a constant as typed or untyped hinges on the rationale behind its declaration. Generally, <code>opting for an untyped constant provides greater flexibility</code>. However, <code>specific scenarios may necessitate the enforcement of a particular type for a constant</code>.</p> Typed vs Untyped <pre><code>const x = 10\nvar y int = x\nvar z float64 = x\nvar d byte = x\n\nconst typedX int = 10\ny = typedX\n</code></pre>"},{"location":"fundamentals/data_types/array/","title":"Array","text":"<p>In Go, an array is a <code>fixed-size collection of elements of the same type</code>. Arrays are declared with a specific size, and that <code>size cannot be changed after the array is created</code>. Arrays are useful when planning the detailed layout of memory and <code>sometimes can help avoid allocation</code>, but primarily they are a building block for slices. The <code>size of an array is part of its type</code>, so the types [10]int and [20]int are distinct.</p> <p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/arrays.go\n0\n[0 10 20]\nValue stored in 0 index is 0\nValue stored in 1 index is 10\nValue stored in 2 index is 20\nValue stored in 0 index is apple\nValue stored in 1 index is banana\nValue stored in 2 index is cherry\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var myArray [3]int\n    myArray[1] = 10\n    myArray[2] = 20\n    fmt.Println(\"Indexes not set get default value: \", myArray[0])\n    fmt.Println(\"All values in the array: \", myArray)\n    fmt.Println()\n    for i, value := range myArray {\n        fmt.Printf(\"Value stored in %d index is %d\\n\", i, value)\n    }\n\n    fmt.Println()\n    myArray[1] = 600\n    fmt.Println(\"It's possible to change index value in array: \", myArray)\n    fmt.Println()\n\n    initArray := [3]string{\"apple\", \"banana\", \"cherry\"}\n    for i, value := range initArray {\n        fmt.Printf(\"Value stored in %d index is %v\\n\", i, value)\n    }\n\n    firstValue := initArray[1:]\n    fmt.Println(firstValue)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/array/#as-function-params","title":"As Function Params","text":"<p>A function can receive an array by <code>specifying the array's type and size</code> in the function's parameter list. When you pass an array to a function, <code>Go passes the entire array by value</code>, which means the function receives a copy of the array.</p> <p>If you want to pass an array to a function and have the function modify the original array, you would need to pass a pointer to the array instead. However, <code>arrays in Go are not addressable</code>, so you cannot take the address of an array directly. Instead, you would typically use a slices, which is a reference to an underlying array and can be passed by reference.</p> <p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/array_params.go\nInital myArray:  [1 2 3 4]\nMemory allocated for myArray: 0xc000018180\nMemory allocated for data: 0xc0000181e0\nAfter call func Slice:  [1 2 3 4]\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc arrayParam(data [4]int) {\n    fmt.Printf(\"Memory allocated for data: %p\\n\", &amp;data)\n    data[0] = 90\n}\n\nfunc main() {\n    myArray := [4]int{1, 2, 3, 4}\n    fmt.Println(\"Inital myArray: \", myArray)\n    fmt.Printf(\"Memory allocated for myArray: %p\\n\", &amp;myArray)\n    arrayParam(myArray)\n    fmt.Println(\"After call func Slice: \", myArray)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/array/#slicing-an-array","title":"Slicing an Array","text":"<p>In Go, slicing an array you to <code>create a new</code> slices that references a portion of the original array. There are several ways to slice an array, depending on the range of indices you specify. The index format follows this pattern: <code>a[start:stop]</code>.</p> <p>Change the original array</p> <p>Remember that slicing does not create a new array. <code>It creates a new slice header that points to the same underlying array. Modifying the elements of the new slice will affect the original array</code>, but changing the length of the new slice (e.g., appending elements) will not affect the original array unless you explicitly make a copy of the array or slice.</p> <p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/arrays_slicing.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main() {\n    var myArray [10]int\n\n    for i := 0; i &lt;= 9; i++ {\n        value := (i + 1) * 10\n        myArray[i] = value\n    }\n\n    copyedArray := myArray[:]\n    fmt.Println(\"To create a copy of the array, use full slice omit both the start and end indices: \", copyedArray)\n    fmt.Println(\"Notice that the copyedArray is actually a slice variable:\", reflect.TypeOf(copyedArray))\n    fmt.Printf(\"Address of myArray: %p\\n\", &amp;myArray)\n    fmt.Printf(\"Address of copyedArray: %p\\n\", &amp;copyedArray)\n    copyedArray[9] = 10000\n    fmt.Println(\"Check that changing the copyedArray changes also the myArray!!!!!!!\", copyedArray, myArray)\n    fmt.Println()\n\n    startToEnd := myArray[:5]\n    fmt.Println(\"Getting 5 first elements, start to end: \", startToEnd)\n\n    fromToEnd := myArray[5:]\n    fmt.Println(\"Getting from index 5 to end, from to end: \", fromToEnd)\n\n    betweenIndexes := myArray[2:5]\n    fmt.Println(\"Getting between 2 and 5, between indexes: \", betweenIndexes)\n\n    fmt.Println(\"Go does not have built-in support for stepping through a slice like Python does. However, you can achieve this by using a loop or by manually selecting the desired indices.\")\n\n    var steppedSlice []int\n    for i := 0; i &lt; len(myArray); i += 2 {\n        steppedSlice = append(steppedSlice, myArray[i])\n    }\n    fmt.Println(\"Stepped Slice: \", steppedSlice)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/array/#convert-array-slice-and-array-slice","title":"Convert Array -&gt; Slice and Array &lt;- Slice","text":"<p>If you have an array and you want to convert it to a slice, you don't actually need to do anything special. A slice is just a reference to an underlying array, along with a length. <code>So, when you pass an array to a function expecting a slice, Go automatically converts the array to a slice that covers the entire array</code>.</p> <p>Converting a slice back to an array is a bit trickier because <code>slices can be shorter or longer than arrays</code>. <code>If you know the size of the array you want to convert to, you can create a new array and copy the elements from the slice into it</code>.</p> Array to Slice <p>run command<pre><code>$ go run src/fundamentals/data_types/arrays_convert.go\nprinting s:  [1 2 3]\ntype of s:  []int\nSlice to Array [1 2 3]\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc printSlice(s []int) {\n    fmt.Println(\"printing s: \", s)\n    fmt.Println(\"type of s: \", reflect.TypeOf(s))\n}\n\nfunc main() {\n    arr := [3]int{1, 2, 3}\n    printSlice(arr[:])\n\n    slice := []int{1, 2, 3}\n    var arrCopy [3]int\n    copy(arrCopy[:], slice)\n    fmt.Println(\"Slice to Array\", arr)\n}\n</code></pre></p> Slice to Array knowing the Size <p>run command<pre><code>$ go run src/fundamentals/data_types/arrays_convert.go\nprinting s:  [1 2 3]\ntype of s:  []int\nSlice to Array [1 2 3]\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc printSlice(s []int) {\n    fmt.Println(\"printing s: \", s)\n    fmt.Println(\"type of s: \", reflect.TypeOf(s))\n}\n\nfunc main() {\n    arr := [3]int{1, 2, 3}\n    printSlice(arr[:])\n\n    slice := []int{1, 2, 3}\n    var arrCopy [3]int\n    copy(arrCopy[:], slice)\n    fmt.Println(\"Slice to Array\", arr)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/array/#references","title":"References","text":"<ul> <li>Effective Go - Arrays</li> </ul>"},{"location":"fundamentals/data_types/maps/","title":"Maps","text":"<p>Go provides a built-in map type that implements a hash table. Maps in Go are a data structure used to store <code>key-value pairs</code>. The <code>key can be of any type for which the equality operator is defined</code>, such as integers, floating point and complex numbers, strings, pointers, interfaces (as long as the dynamic type supports equality), structs and arrays. The value may be any type at all, including another map!</p> <p>Key types not supported</p> <p>Slices cannot be used as map keys, because equality is not defined on them.</p> <p>Maps are <code>reference types</code>, that hold references to an underlying hash table. <code>If you pass a map to a function or assign it to another variable, both refer to the same data structure</code>. Since maps are reference type like pointers or slices to initialize a map, use the built in make function.</p> <p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/maps.go\nNot initalize map:  map[]\nAfter add elements:  map[key1:1 key2:2 key3:3]\nValue from key1:  1\nWhen key doesn't exist, default value is returned:  0\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var nil_map map[string]int\n    if nil_map == nil {\n        fmt.Println(\"Not initalize map: \", nil_map)\n        nil_map = make(map[string]int)\n    }\n    nil_map[\"key1\"] = 1\n    nil_map[\"key2\"] = 2\n    nil_map[\"key3\"] = 3\n    fmt.Println(\"After add elements: \", nil_map)\n\n    value1 := nil_map[\"key1\"]\n    fmt.Println(\"Value from key1: \", value1)\n    notExistKey := nil_map[\"keykkkk\"]\n    fmt.Println(\"When key doesn't exist, default value is returned : \", notExistKey)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/maps/#as-function-params","title":"As Function Params","text":"<p><code>If a function takes a map argument, changes it makes to the elements of the slice will be visible to the caller</code>, analogous to passing a pointer to the underlying array.</p> <p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/maps_params.go\nInital mySlice:  map[key1:Corinthians key2:Lakers]\nMemory allocated for mySlice: 0xc000050020\nMemory allocated for data: 0xc000050030\nAfter call func Slice:  map[key1:Corinthians key2:Lakers key3:Liverpool]\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc mapParam(data map[string]string) {\n    fmt.Printf(\"Memory allocated for data: %p\\n\", &amp;data)\n    data[\"key3\"] = \"Liverpool\"\n}\n\nfunc main() {\n    myMap := make(map[string]string)\n    myMap[\"key1\"] = \"Corinthians\"\n    myMap[\"key2\"] = \"Lakers\"\n\n    fmt.Println(\"Inital mySlice: \", myMap)\n    fmt.Printf(\"Memory allocated for mySlice: %p\\n\", &amp;myMap)\n    mapParam(myMap)\n    fmt.Println(\"After call func Slice: \", myMap)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/maps/#operations","title":"Operations","text":"<p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/maps_operations.go\nInitial myMap:  map[key1:1 key2:2 key3:3]\nkey3 Value:  3\nAdded key4:  map[key1:1 key2:2 key3:3 key4:4]\n\nKey1 exists:  1\nkey5 does not exist\n\nAfter delete key1 (exist) and key5 (not exist):  map[key2:2 key3:3 key4:4]\nLen of myMap:  3\nKey: key2, Value: 2\nKey: key3, Value: 3\nKey: key4, Value: 4\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    myMap := map[string]int{\n        \"key1\": 1,\n        \"key2\": 2,\n        \"key3\": 3,\n    }\n    fmt.Println(\"Initial myMap: \", myMap)\n    fmt.Println(\"key3 Value: \", myMap[\"key3\"])\n    myMap[\"key4\"] = 4\n    fmt.Println(\"Added key4: \", myMap)\n    fmt.Println()\n\n    if value, ok := myMap[\"key1\"]; ok {\n        fmt.Println(\"Key1 exists: \", value)\n    }\n    if value, ok := myMap[\"key5\"]; ok {\n        fmt.Println(\"Key1 exists: \", value)\n    } else {\n        fmt.Println(\"key5 does not exist\")\n    }\n    fmt.Println()\n    delete(myMap, \"key1\")\n    delete(myMap, \"key5\")\n    fmt.Println(\"After delete key1 (exist) and key5 (not exist): \", myMap)\n    fmt.Println(\"Len of myMap: \", len(myMap))\n\n    for key, value := range myMap {\n        fmt.Printf(\"Key: %s, Value: %d\\n\", key, value)\n    }\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/maps/#gos-package-for-maps","title":"Go's Package for Maps","text":"<p>Package maps defines various functions useful with maps of any type. Link here.</p>"},{"location":"fundamentals/data_types/maps/#references","title":"References","text":"<ul> <li>Go maps in action</li> <li>Effective Go - Maps</li> </ul>"},{"location":"fundamentals/data_types/slice/","title":"Slice","text":"<p>In Go, a slice is a <code>more versatile and dynamic alternative to arrays</code>. Slices are like views into an underlying array, allowing you to work with a portion of an <code>array without specifying a fixed size</code>. Slices are <code>reference types</code>, that hold references to an underlying array, and <code>if you assign one slice to another, both refer to the same array</code>.</p> <p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/slices.go\nValue in index 2:  30\nAll values in the slice:  [10 20 30 40 50 60]\n\nValue stored in 0 index is 10\nValue stored in 1 index is 20\nValue stored in 2 index is 30\nValue stored in 3 index is 40\nValue stored in 4 index is 50\nValue stored in 5 index is 60\n\nIt is possible to change index value in array in both arrays:  [10 600 30 40 50 60] [10 600 30 40 50 60]\nSee that mySlice didn't change mySlice:  [10 999 30 40 50 60] [10 600 30 40 50 60]\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    mySlice := []int{10, 20, 30, 40, 50, 60}\n    fmt.Println(\"Value in index 2: \", mySlice[2])\n    fmt.Println(\"All values in the slice: \", mySlice)\n    fmt.Println()\n    for i, value := range mySlice {\n        fmt.Printf(\"Value stored in %d index is %d\\n\", i, value)\n    }\n    fmt.Println()\n    mySlice2 := mySlice\n    mySlice2[1] = 600\n    fmt.Println(\"It's possible to change index value in array in both arrays: \", mySlice2, mySlice)\n\n    mySlice3 := make([]int, len(mySlice))\n    copy(mySlice3, mySlice)\n    mySlice3[0] = 999\n    fmt.Println(\"See that mySlice didn't change mySlice: \", mySlice3, mySlice)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/slice/#as-function-params","title":"As Function Params","text":"<p><code>If a function takes a slice argument, changes it makes to the elements of the slice will be visible to the caller</code>, analogous to passing a pointer to the underlying array.</p> <p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/slices_params.go\nInital mySlice:  [1 2 3 4]\nMemory allocated for mySlice: 0xc000010018\nMemory allocated for data: 0xc000010048\nAfter call func Slice:  [90 2 3 4]\nNotice that append elements didn't change mySlice, just change value in index\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc sliceParam(data []int) {\n    fmt.Printf(\"Memory allocated for data: %p\\n\", &amp;data)\n    data[0] = 90\n    data = append(data, 90, 80, 70)\n}\n\nfunc main() {\n    mySlice := []int{1, 2, 3, 4}\n    fmt.Println(\"Inital mySlice: \", mySlice)\n    fmt.Printf(\"Memory allocated for mySlice: %p\\n\", &amp;mySlice)\n    sliceParam(mySlice)\n    fmt.Println(\"After call func Slice: \", mySlice)\n    fmt.Println(\"Notice that append elements didn't change mySlice, just change value in index\")\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/slice/#slicing-a-slice","title":"Slicing a Slice","text":"<p>Same thing that slice an array.</p>"},{"location":"fundamentals/data_types/slice/#operations","title":"Operations","text":"<p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/slices_operations.go\nInitial mySlice:  [10 20 30 40 50 60]\nAppending an element ---------&gt;\nmySliceAdded:  [10 20 30 40 50 60 70]\nmySlice without changes:  [10 20 30 40 50 60]\n\nRemoving an element ---------&gt;\nmySlice after remove index 3:  [10 20 30 50 60]\nmySliceAdded:  [10 20 30 40 50 60 70]\n\nInsert at index ---------&gt;\nmySlice after remove:  [10 20 30 40 50 1000 60 70]\nmySliceAdded:  [10 20 30 40 50 1000 60 70]\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    mySlice := []int{10, 20, 30, 40, 50, 60}\n    fmt.Println(\"Initial mySlice: \", mySlice)\n    // Add an element to the end of the slice.\n    fmt.Println(\"Appending an element ---------&gt;\")\n    mySliceAdded := append(mySlice, 70)\n    fmt.Println(\"mySliceAdded: \", mySliceAdded)\n    fmt.Println(\"mySlice without changes: \", mySlice)\n    fmt.Println()\n    // Remove an element from the slice by index.\n    fmt.Println(\"Removing an element ---------&gt;\")\n    index := 3\n    mySlice = append(mySlice[:index], mySlice[index+1:]...) // Remove element at index\n    fmt.Println(\"mySlice after remove index 3: \", mySlice)\n    fmt.Println(\"mySliceAdded: \", mySliceAdded)\n    fmt.Println()\n\n    // Insert an element at a specific position in the slice.\n    fmt.Println(\"Insert at index ---------&gt;\")\n    index = 5\n    mySliceAdded = append(\n        mySliceAdded[:index],\n        append([]int{1000}, mySliceAdded[index:]...)...) // Insert value at index\n    fmt.Println(\"mySlice after remove: \", mySliceAdded)\n    fmt.Println(\"mySliceAdded: \", mySliceAdded)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/slice/#memory-allocation","title":"Memory Allocation","text":"<p>Remember that slices are based on arrays, so they can change in size dynamically. <code>If the underlying array runs out of capacity, a new larger array is allocated, and the data is copied over</code>.</p> <p>When a slice needs more memory...</p> <p><code>When a slice needs more capacity, Go doubles the original size. In the case of very large slices, this can consume more memory than necessary</code>.</p> <p>Doubling the capacity of the underlying array allows for more elements to be added in the future without frequent reallocations.</p> <p>Tip</p> <p>When you anticipate working with a large slice, it's a <code>good practice to initialize the slice with a size closer to the maximum you expect to use to minimize unnecessary memory consumption</code>.</p> <p>Slices also have a <code>length and capacity</code> (the maximum number of elements it can hold without reallocation). Use the <code>len()</code> and <code>cap()</code> functions to get these values.</p> <p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/slices_memory.go\nmySlice: len=6 cap=6 [10 20 30 40 50 60]\nnoneValue: len=0 cap=6 []\nfirstFour: len=4 cap=6 [10 20 30 40]\nlast_two: len=4 cap=4 [30 40 50 60]\nmySlice with 70:  [10 20 30 40 50 60 70]\nmySlice: len=7 cap=12 [10 20 30 40 50 60 70]\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    mySlice := []int{10, 20, 30, 40, 50, 60}\n\n    fmt.Printf(\"mySlice: len=%d cap=%d %v\\n\", len(mySlice), cap(mySlice), mySlice)\n    noneValue := mySlice[:0]\n    fmt.Printf(\"noneValue: len=%d cap=%d %v\\n\", len(noneValue), cap(noneValue), noneValue)\n    firstFour := mySlice[:4]\n    fmt.Printf(\"firstFour: len=%d cap=%d %v\\n\", len(firstFour), cap(firstFour), firstFour)\n    skipTwoFirst := mySlice[2:]\n    fmt.Printf(\"last_two: len=%d cap=%d %v\\n\", len(skipTwoFirst), cap(skipTwoFirst), skipTwoFirst)\n\n    mySlice = append(mySlice, 70)\n    fmt.Println(\"mySlice with 70: \", mySlice)\n    fmt.Printf(\"mySlice: len=%d cap=%d %v\\n\", len(mySlice), cap(mySlice), mySlice)\n}\n</code></pre></p> <p>When added 70 in the example above, notice that the <code>slice's capacity increases to 12 instead of 7</code>.</p>"},{"location":"fundamentals/data_types/slice/#two-dimensional-slices","title":"Two-dimensional Slices","text":"<p>Because slices are variable-length, it is possible to have each inner slice be a different length.</p> <p>Example</p> <p>run command<pre><code>$ go run src/fundamentals/data_types/2d-slices.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype LinesOfText [][]byte\n\nfunc printByLine(text LinesOfText) {\n    for i, line := range text {\n        fmt.Printf(\"Line %d text: %s\\n\", i, line)\n    }\n    fmt.Println()\n}\n\nfunc addLine(text LinesOfText, line string) LinesOfText {\n    text = append(text, []byte(line))\n    return text\n}\n\nfunc main() {\n    text := LinesOfText{\n        []byte(\"Now is the time\"),\n        []byte(\"for all good gophers\"),\n        []byte(\"to bring some fun to the party.\"),\n    }\n    printByLine(text)\n    text[0] = []byte(\"CHANGED LINE\")\n    printByLine(text)\n    text = addLine(text, \"NEW LINE\")\n    printByLine(text)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/slice/#gos-package-for-slices","title":"Go's Package for Slices","text":"<p>Package slices defines various functions useful with slices of any type. Link here.</p>"},{"location":"fundamentals/data_types/slice/#references","title":"References","text":"<ul> <li>Effective Go - Slices</li> </ul>"},{"location":"fundamentals/data_types/strings/","title":"Strings and Runes","text":""},{"location":"fundamentals/data_types/strings/#runes","title":"Runes","text":"<p>In Go, a rune is a data type used to <code>represent a Unicode code point</code>, which is a unique integer (which is an alias for the <code>int32</code> type) <code>value that corresponds to a character in the Unicode standard</code>. The Unicode standard assigns a unique code point to almost every character from every writing system in the world, making it suitable for working with text in various languages and scripts.</p>"},{"location":"fundamentals/data_types/strings/#when-to-use-runes","title":"When to Use Runes","text":"<p>You should use runes when you need to <code>work with individual characters in a string and handle text that includes characters from different languages</code>, including non-ASCII characters. Common use cases include text processing, manipulation, and validation. Using runes is an efficient way to handle text in Go because <code>it\u2019s optimized for Unicode character encoding</code>. It ensures that you can accurately represent and manipulate characters from various languages.</p> Simple example using Runes <p>run command<pre><code>$ go run src/fundamentals/data_types/runes.go\nEqual\nH e l l o ,     \u4e16 \u754c \nHello,  \u4e16\u754c\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var r1 rune = 'A'\n    r2 := 'A'\n    if r1 == r2 {\n        fmt.Println(\"Equal\")\n    } else {\n        fmt.Println(\"Not equal\")\n    }\n\n    str := \"Hello,  \u4e16\u754c\" // The string contains both ASCII and non-ASCII characters.\n    runes := []rune(str)\n    for _, r := range runes {\n        fmt.Printf(\"%c \", r)\n    }\n    fmt.Println()\n    fmt.Println(string(runes))\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/strings/#strings","title":"Strings","text":"<p>In Go, a string is a sequence of one or more characters (letters, numbers, symbols) that can be either a constant or a variable. <code>Strings are made up of Unicode and are immutable sequences, meaning they cannot be changed once created</code>.</p> <p>Strings in Go are <code>similar to byte slices</code> in that they can be used in operations that work with byte slices. This means you can use functions like <code>copy</code> and <code>append</code> with strings.</p> <p>The internal structure of a string in Go is essentially a <code>byte slice wrapper</code>. A string is <code>represented as a struct with two fields</code>: elements, which points to the underlying bytes, and len, which stores the number of bytes. This internal representation is crucial for understanding how strings are manipulated and stored in memory.</p> <p><code>Raw strings</code> are delimited with backquotes (`) and can contain any character except a backquote. There\u2019s no escape character in a raw string literal, <code>all characters are included as is</code>. When using a raw string literal, you write in multiline.</p> String Usages Example <p>run command<pre><code>$ go run src/fundamentals/data_types/string.go\nMemory allocated for str1:  0xc000014070\nMemory allocated for str2:  0xc000014080\nEven though both have the same value, the memory address is different.\n\nUsing append bytes:  Salve o Corinthians\nUsing copy bytes:  Salve o\nLorem ipsum dolor sit amet, consectetur adipiscing elit.Nunc ac urna ex. Mauris eu dolor nec orci aliquam consectetur vitae ut sapien.\n    Quisque sed commodo dui. Cras pulvinar aliquet eleifend. Nulla dignissim arcu quis nunc facilisis dictum.\nCurabitur consequat, purus vel sodales dictum, dui metus lacinia lacus, in congue est.\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    str1 := \"Corinthians\"\n    str2 := \"Corinthians\"\n    fmt.Println(\"Memory allocated for str1: \", &amp;str1)\n    fmt.Println(\"Memory allocated for str2: \", &amp;str2)\n    fmt.Println(\"Even though both have the same value, the memory address is different.\")\n    fmt.Println()\n\n    save := []byte(\"Salve o \")\n    saveStr1 := append(save, str1...)\n    fmt.Println(\"Using append bytes: \", string(saveStr1))\n\n    strCopy := make([]byte, len(save))\n    copy(strCopy, save)\n    fmt.Println(\"Using copy bytes: \", string(strCopy))\n\n    rawStr := `Lorem ipsum dolor sit amet, consectetur adipiscing elit.Nunc ac urna ex. Mauris eu dolor nec orci aliquam consectetur vitae ut sapien.\n    Quisque sed commodo dui. Cras pulvinar aliquet eleifend. Nulla dignissim arcu quis nunc facilisis dictum.\nCurabitur consequat, purus vel sodales dictum, dui metus lacinia lacus, in congue est.`\n    fmt.Println(rawStr)\n}\n</code></pre></p>"},{"location":"fundamentals/data_types/strings/#gos-package-for-string","title":"Go's Package for String","text":"<p>Package strings defines various functions useful with maps of any type. Link here.</p>"},{"location":"fundamentals/data_types/strings/#references","title":"References","text":"<ul> <li>Strings, bytes, runes and characters in Go</li> </ul>"},{"location":"fundamentals/literals/floats/","title":"Floats","text":"<p>Go has two floating-point types, <code>float32</code> and <code>float64</code>. Go uses the IEEE 754 specification, giving a large range and limited precision. Unless you have to be compatible with an existing format, <code>use float64</code> since float literals defaul value is float64.</p>"},{"location":"fundamentals/literals/floats/#precision-problems","title":"Precision Problems","text":"<p>Similar to many programming languages, Go's floating-point numbers have an extensive range, yet <code>they cannot precisely represent every value</code> within that spectrum; rather, <code>they store the closest approximation</code>. Given their inherent imprecision, floating-point numbers are suitable only for scenarios where approximate values suffice or where the nuances of floating-point arithmetic are well understood.</p> <p>Although Go permits the use of <code>==</code> and <code>!=</code> operators for comparing floats, it's advisable to avoid doing so. <code>Due to the inherent imprecision of floats, two floating-point values may not be considered equal even when they appear identical</code>. Instead, consider defining a maximum permissible variance and comparing whether the difference between two floats falls below this threshold. This threshold value (often referred to as epsilon), should be chosen based on the precision requirements of your application.</p> <p>Help to define variance value</p> <p>Checkout: Floating-Point Guide</p>"},{"location":"fundamentals/literals/integers/","title":"Integers","text":"<p>Integer literals are <code>base 10</code> by default in Golang, but different prefixes are used to indicate other bases:</p> <ol> <li>0b for binary (base 2)</li> <li>0o for octal (base 8)</li> <li>0x for hexadecimal (base 16)</li> </ol> <p>Tip</p> <p>You can use either upper or lowercase letters for the prefix.</p> <p>To make it easier to read longer integer literals, Go allows <code>you to put underscores in the middle of your literal</code>. The underscores do not affect the value of the number, and they can't be at the beginning or end of numbers and next to each other.</p> <p>Example</p> <p>For example, group by thousands in base 10 (1_234).</p>"},{"location":"fundamentals/literals/integers/#integer-types","title":"Integer Types","text":"<p>Go provides both signed and unsigned integers in a variety of sizes.</p> Type name Value range int8 \u2013128 to 127 int16 \u201332768 to 32767 int32 \u20132147483648 to 2147483647 int64 \u20139223372036854775808 to 9223372036854775807 uint8 0 to 255 uint16 0 to 65535 uint32 0 to 4294967295 uint64 0 to 18446744073709551615 Bit alias <p>A byte is an alias for uint8.</p> <p>Go has <code>int</code> and <code>unit</code> as a special name. On a 32-bit CPU, int is a 32-bit signed/unsigned integer <code>like an int32</code>. On most 64-bit CPUs, int is a 64-bit signed/unsigned integer, <code>just like an int64</code>.</p> <p>Compare ints</p> <p>Because <code>int</code> isn\u2019t consistent from platform to platform, it is a compile-time error to assign, compare, or perform mathematical operations between an int and an int32 or int64 without a type conversion.</p>"},{"location":"https_network/api/","title":"API","text":"<p>You can create an HTTP server using the <code>net/http</code> package, allowing you to handle HTTP requests and responses.</p> <p>Example</p> <p>run command<pre><code>go run src/http/basic_server.go\ncurl localhost:8080\ncurl localhost:8080/anonymous_func\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    handler := func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"Hello World!\"))\n    }\n\n    http.HandleFunc(\"/\", handler)\n    http.HandleFunc(\"/anonymous_func\", func(w http.ResponseWriter, r *http.Request) {\n        w.Write([]byte(\"Hello World from anonymous_func!\"))\n    })\n\n    fmt.Println(\"Server is running on http://localhost:8080\")\n    err := http.ListenAndServe(\":8080\", nil)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n    }\n}\n</code></pre> output<pre><code>Server is running on http://localhost:8080\nHello World!\nHello World from anonymous_func!\n</code></pre></p>"},{"location":"https_network/api/#examples","title":"Examples","text":"<ol> <li>Get Address - Basic API</li> <li>Following the Standards for API</li> </ol>"},{"location":"https_network/file_server/","title":"File Server","text":"<p>The <code>FileServer</code> function in the <code>net/http</code> package efficiently <code>serves static files from a specified directory</code>. It simplifies the process of serving a directory by providing a handler that serves HTTP requests with the contents of the specified directory.</p> <p>Example</p> <p>In this example, the FileServer function <code>serves files from the static directory</code>. The <code>http.Dir</code> function <code>specifies the directory from which to serve files</code>.</p> <p>run command<pre><code>go run src/http/file_server.go\ncurl localhost:8080\n</code></pre> <pre><code>package main\n\nimport (\n    \"log\"\n    \"net/http\"\n)\n\nfunc main() {\n    fs := http.FileServer(http.Dir(\"./static\"))\n    mux := http.NewServeMux()\n    mux.Handle(\"/\", fs)\n    log.Fatal(http.ListenAndServe(\":8080\", mux))\n}\n</code></pre> output<pre><code>&lt;p&gt;Corinthians&lt;/p&gt;\n</code></pre></p>"},{"location":"https_network/json/","title":"JSON","text":"<p>Working with JSON in Go is straightforward and can be achieved using the <code>encoding/json</code> package, which provides functionalities to encode Go data structures into JSON and decode JSON into Go data structures.</p> <p>Nice to know Struts Tags</p>"},{"location":"https_network/json/#struct-to-json","title":"Struct to JSON","text":"<p>Using <code>json.Marshal</code> is the simple way. The <code>json.NewEncoder</code> is used to create a new <code>JSON encoder that writes to an io.Writer interface, such as a file or network connection</code>. This allows you to easily encode Go data structures to JSON and write them to an external destination.</p> Example <p>run command<pre><code>go run src/http/struct_to_json.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\ntype Person struct {\n    Name string `json:\"name\"`\n    Age  int    `json:\"age\"`\n}\n\nfunc main() {\n    person := Person{Name: \"Gabriel\", Age: 25}\n    jsonData, err := json.Marshal(person)\n    fmt.Println(\"Using Marshal\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"JSON Data:\", string(jsonData))\n    fmt.Println(\"***\")\n    fmt.Println(\"Using NewEncoder\")\n    file, _ := os.Create(\"src/http/person.json\")\n    defer file.Close()\n    err = json.NewEncoder(file).Encode(person)\n}\n</code></pre> output<pre><code>Using Marshal\nJSON Data: {\"name\":\"Gabriel\",\"age\":25}\n***\nUsing NewEncoder\n</code></pre></p>"},{"location":"https_network/json/#json-to-struct","title":"JSON to Struct","text":"<p>Using <code>json.Unmarshal</code> is the simple way. The <code>json.NewDecoder</code> is used to create a new <code>JSON decoder that reads from an io.Reader interface, such as a file or network connection</code>. This enables you to easily decode JSON data from an external source into Go data structures.</p> Example <p>run command<pre><code>go run src/http/json_to_struct.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"os\"\n)\n\ntype Person struct {\n    Name string `json:\"name\"`\n    Age  int    `json:\"age\"`\n}\n\nfunc main() {\n    person := Person{Name: \"Gabriel\", Age: 25}\n    jsonData, err := json.Marshal(person)\n    fmt.Println(\"Using Marshal\")\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"JSON Data:\", string(jsonData))\n    fmt.Println(\"***\")\n    fmt.Println(\"Using NewEncoder\")\n    file, _ := os.Create(\"src/http/person.json\")\n    defer file.Close()\n    err = json.NewEncoder(file).Encode(person)\n}\n</code></pre> output<pre><code>Using Unmarshal\nPerson: {Gabriel 25}\n***\nUsing NewDecoder\nPerson2: {Gabriel 25}\n</code></pre></p>"},{"location":"https_network/request/","title":"HTTP Request","text":""},{"location":"https_network/request/#httpget","title":"http.Get","text":"<p>Use <code>http.Get for simple GET requests</code> where you don't need to customize the headers extensively.</p> Example <p>run command<pre><code>go run src/http/basic_http.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n)\n\nfunc main() {\n    req, err := http.Get(\"https://www.google.com/\")\n    if err != nil {\n        fmt.Println(\"Error requesting:\", err)\n        panic(err)\n    }\n    defer req.Body.Close()\n    res, err := io.ReadAll(req.Body)\n    if err != nil {\n        fmt.Println(\"Error reading response:\", err)\n        panic(err)\n    }\n    fmt.Println(string(res))\n}\n</code></pre> output<pre><code>GOOGLE PAGE IN STRING\n</code></pre></p>"},{"location":"https_network/request/#httppost","title":"http.Post","text":"<p>The <code>http.Post</code> function simplifies the process of sending POST requests. It allows you to <code>specify the URL, the content type, and the request body</code>. It's suitable for <code>simple POST requests</code> where you don't need to customize the headers extensively.</p> Example <p>run command<pre><code>go run src/http/http_post.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    payload := []byte(`{\"key1\": \"value1\", \"key2\": \"value2\"}`)\n    body := bytes.NewBuffer(payload)\n\n    resp, err := http.Post(\"https://httpbin.org/post\", \"application/json\", body)\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n\n    fmt.Println(\"Status:\", resp.Status)\n}\n</code></pre> output<pre><code>Status: 200 OK\n</code></pre></p>"},{"location":"https_network/request/#httpclient","title":"http.Client","text":"<p>The <code>http.Client object allows customization of the HTTP request behavior</code>, such as setting timeouts, defining transport properties, and managing the client's behavior.</p> http.Client with a 3-second Timeout <p>run command<pre><code>go run src/http/http_client.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"net/http\"\n    \"time\"\n)\n\nfunc main() {\n    client := http.Client{\n        Timeout: time.Second * 3, // Set a timeout for the request\n    }\n    resp, err := client.Get(\"https://jsonplaceholder.typicode.com/posts/1\")\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n\n    body, err := io.ReadAll(resp.Body)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(string(body))\n}\n</code></pre> output<pre><code>{\n    \"userId\": 1,\n    \"id\": 1,\n    \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\",\n    \"body\": \"quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto\"\n}\n</code></pre></p>"},{"location":"https_network/request/#httpnewrequest","title":"http.NewRequest","text":"<p>This function <code>creates a new HTTP request</code>. It allows <code>control over the request headers, methods, and request bodies</code>. You can set custom headers, perform more type requests (such as PUT and DELETE), and attach a request body. It's particularly useful for making custom or more complex HTTP requests.</p> Post using Client and NewRequest <p>run command<pre><code>go run src/http/http_newRequest.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    payload := []byte(`{\"key1\": \"value1\", \"key2\": \"value2\"}`)\n    body := bytes.NewBuffer(payload)\n\n    req, err := http.NewRequest(\"POST\", \"https://httpbin.org/post\", body)\n    if err != nil {\n        panic(err)\n    }\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    client := http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n\n    fmt.Println(\"Status:\", resp.Status)\n}\n</code></pre> output<pre><code>Status: 200 OK\n</code></pre></p>"},{"location":"https_network/request/#httpnewrequestwithcontext","title":"http.NewRequestWithContext","text":"<p>A function that creates a <code>new HTTP request with a specific context</code>. This function is particularly <code>useful when you need to set a deadline, cancel a request, or pass a request-specific value across API boundaries</code>.</p> Post using Client and NewRequestWithContext <p>run command<pre><code>go run src/http/http_NewRequestWithContext.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n)\n\nfunc main() {\n    ctx := context.Background()\n    ctx, cancel := context.WithTimeout(ctx, time.Second*5)\n    defer cancel()\n\n    req, err := http.NewRequestWithContext(ctx, \"GET\", \"https://jsonplaceholder.typicode.com/posts/1\", nil)\n    if err != nil {\n        panic(err)\n    }\n\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n\n    fmt.Println(resp.Status)\n}\n</code></pre> output<pre><code>200 OK\n</code></pre></p>"},{"location":"https_network/request/#examples","title":"Examples","text":"<ol> <li>Get Address - Basic API</li> </ol>"},{"location":"https_network/templates/","title":"Templates","text":"<p>Templates are a powerful way to <code>separate the presentation layer from your code logic</code>. The <code>text/template</code> and <code>html/template</code> packages provide functionalities for <code>parsing and executing text and HTML templates</code>. Templates are <code>useful for rendering dynamic content in web applications or generating structured text documents</code>.</p> <p>html/template package</p> <p>The <code>html/template</code> package provides additional HTML-specific features and ensures proper escaping for HTML content.</p> <p>When you use <code>template.Must</code>, it helps <code>simplify error handling when parsing templates</code>. It panics if the template parsing fails, eliminating the need to explicitly check for errors. However, <code>this approach is suitable only during initialization</code>, and the application should terminate if the templates cannot be parsed properly.</p> <p>Example</p> <p>run command<pre><code>go run src/templates/template.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    htmlTemplate \"html/template\"\n    \"os\"\n    textTemplate \"text/template\"\n)\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    tmpl, err := textTemplate.New(\"temple-string\").Parse(\"Hello, {{ .Name }}\")\n    if err != nil {\n        panic(err)\n    }\n\n    data := struct {\n        Name string\n    }{\n        Name: \"Gabriel\",\n    }\n    tmpl.Execute(os.Stdout, data)\n    fmt.Println(\"\\n************\")\n    persons := [4]Person{\n        {Name: \"Gabriel\", Age: 15},\n        {Name: \"Cassio\", Age: 40},\n        {Name: \"Yuri\", Age: 20},\n        {Name: \"Lucas\", Age: 17},\n    }\n\n    tmpl_html := htmlTemplate.Must(\n        htmlTemplate.New(\"person.html\").ParseFiles(\"person.html\"))\n    tmpl_html.Execute(os.Stdout, persons)\n}\n</code></pre> output<pre><code>Hello, Gabriel\n************\n    &lt;p&gt;All Users:&lt;/p&gt;\n    &lt;h1&gt;Hello, Gabriel!&lt;/h1&gt;\n    &lt;p&gt;Age: 15&lt;/p&gt;\n    &lt;h1&gt;Hello, Cassio!&lt;/h1&gt;\n    &lt;p&gt;Age: 40&lt;/p&gt;\n        &lt;p&gt;Adult User&lt;/p&gt;\n    &lt;h1&gt;Hello, Yuri!&lt;/h1&gt;\n    &lt;p&gt;Age: 20&lt;/p&gt;\n        &lt;p&gt;Adult User&lt;/p&gt;\n    &lt;h1&gt;Hello, Lucas!&lt;/h1&gt;\n    &lt;p&gt;Age: 17&lt;/p&gt;\n</code></pre></p>"},{"location":"https_network/templates/#compose-templates","title":"Compose Templates","text":"<p>You can compose templates by defining reusable parts and embedding them within other templates. This helps in creating modular and maintainable templates.</p> <p>Example</p> <p>run command<pre><code>go run src/templates/compose_template.go\ncurl localhost:8080\n</code></pre> <pre><code>package main\n\nimport (\n    \"html/template\"\n    \"net/http\"\n)\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    base_template := template.Must(template.ParseFiles(\n        \"header.html\",\n        \"person.html\",\n        \"footer.html\",\n    ))\n\n    persons := [4]Person{\n        {Name: \"Gabriel\", Age: 15},\n        {Name: \"Cassio\", Age: 40},\n        {Name: \"Yuri\", Age: 20},\n        {Name: \"Lucas\", Age: 17},\n    }\n\n    http.HandleFunc(\"/\", func(res http.ResponseWriter, request *http.Request) {\n        err := base_template.ExecuteTemplate(res, \"header.html\", persons)\n        if err != nil {\n            panic(err)\n        }\n    })\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre> output<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Persons&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n        &lt;p&gt;All Users:&lt;/p&gt;\n        &lt;h1&gt;Hello, Gabriel!&lt;/h1&gt;\n        &lt;p&gt;Age: 15&lt;/p&gt;\n        &lt;h1&gt;Hello, Cassio!&lt;/h1&gt;\n        &lt;p&gt;Age: 40&lt;/p&gt;\n            &lt;p&gt;Adult User&lt;/p&gt;\n        &lt;h1&gt;Hello, Yuri!&lt;/h1&gt;\n        &lt;p&gt;Age: 20&lt;/p&gt;\n            &lt;p&gt;Adult User&lt;/p&gt;\n        &lt;h1&gt;Hello, Lucas!&lt;/h1&gt;\n        &lt;p&gt;Age: 17&lt;/p&gt;\n        &lt;div&gt;\n        &lt;p&gt;A nice footer here!&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"https_network/templates/#passing-functions","title":"Passing Functions","text":"<p>You can define and use functions with the <code>Funcs field of the template</code> to perform various operations on data. The <code>FuncMap</code> type is used to define a map of template functions.</p> <p>Example</p> <p>run command<pre><code>go run src/templates/passing_func.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"html/template\"\n    \"os\"\n    \"strings\"\n)\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc printName(s string) string {\n    return \"Dear \" + s\n}\n\nfunc main() {\n    t := template.New(\"person_func.html\")\n    t.Funcs(template.FuncMap{\"upperString\": strings.ToUpper})\n    t.Funcs(template.FuncMap{\"printName\": printName})\n    persons := [4]Person{\n        {Name: \"Gabriel\", Age: 15},\n        {Name: \"Cassio\", Age: 40},\n        {Name: \"Yuri\", Age: 20},\n        {Name: \"Lucas\", Age: 17},\n    }\n    t = template.Must(t.ParseFiles(\"person_func.html\"))\n    t.Execute(os.Stdout, persons)\n}\n</code></pre> output<pre><code>&lt;p&gt;All Users:&lt;/p&gt;\n    &lt;h1&gt;Hello, Dear Gabriel!&lt;/h1&gt;\n    &lt;p&gt;Age: 15&lt;/p&gt;\n    &lt;h1&gt;Hello, Dear Cassio!&lt;/h1&gt;\n    &lt;p&gt;Age: 40&lt;/p&gt;\n        &lt;p&gt;ADULT USER: CASSIO&lt;/p&gt;\n    &lt;h1&gt;Hello, Dear Yuri!&lt;/h1&gt;\n    &lt;p&gt;Age: 20&lt;/p&gt;\n        &lt;p&gt;ADULT USER: YURI&lt;/p&gt;\n    &lt;h1&gt;Hello, Dear Lucas!&lt;/h1&gt;\n    &lt;p&gt;Age: 17&lt;/p&gt;\n</code></pre></p>"},{"location":"https_network/templates/#references","title":"References","text":"<ol> <li>Go - Template Documentation</li> </ol>"},{"location":"multithreading/channels/","title":"Channels","text":"<p>Channels in Go are a powerful feature that <code>allows goroutines to communicate with each other and synchronize their execution</code>. They are <code>used to pass data between goroutines and can be thought of as pipes that connect concurrent goroutines</code>.</p> <p>You can create a channel using the <code>make</code> function. <code>Channels are typed by the values they convey</code>. You can <code>send data into a channel</code> using the <code>channel &lt;-</code> syntax and <code>receive data</code> from a channel using the <code>&lt;-channel</code> syntax.</p> Example <p>run command<pre><code>go run src/multithereading/basic_channel.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    channel := make(chan string)\n\n    go func() {\n        channel &lt;- \"Hello Word!\"\n    }()\n\n    msg := &lt;-channel\n    fmt.Println(msg)\n}\n</code></pre> output<pre><code>Hello Word!\n</code></pre></p>"},{"location":"multithreading/channels/#channel-directions","title":"Channel Directions","text":"<p>In Go, channels can be created with a <code>specific direction</code>, which can be either <code>send-only</code>, <code>receive-only</code>, or <code>bidirectional</code>. This feature allows you to <code>enforce certain restrictions on how a channel can be used</code>, which can help prevent errors and make your code easier to understand.</p> <p>Send-Only Channels</p> <p>Syntax: <code>chan&lt;-</code>.</p> <pre><code>ch := make(chan&lt;- int) // Send-only channel\nch &lt;- 42 // Sending data\n</code></pre> <p>Receive-Only Channels</p> <p>Syntax: <code>&lt;-chan</code></p> <pre><code>ch := make(&lt;-chan int) // Receive-only channel\ndata := &lt;-ch // Receiving data\n</code></pre> Full Example <p>run command<pre><code>go run src/multithereading/channel_directions.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc setData(ch chan&lt;- string) {\n    super_secret := \"Corinthians\"\n    ch &lt;- super_secret\n}\n\nfunc readData(ch &lt;-chan string) {\n    data := &lt;-ch\n    fmt.Println(data)\n}\n\nfunc main() {\n    ch := make(chan string)\n    go setData(ch)\n\n    readData(ch)\n}\n</code></pre> output<pre><code>Corinthians\n</code></pre></p> <p>The Bidirectional channel is denoted by the <code>chan</code> syntax, <code>without any direction indicator</code>.</p>"},{"location":"multithreading/channels/#buffered-channels","title":"Buffered Channels","text":"<p>By default, sends and receives <code>block until both the sender and receiver are ready</code>. However, you can <code>create a buffered channel that can hold a certain number of values before blocking</code>. For example, to create a buffered channel that can hold up to 2 strings. In this case, the <code>send operation won't block until the channel's buffer is full, and the receive operation won't block until the channel's buffer is empty</code>.</p> Example <p>run command<pre><code>go run src/multithereading/buffered_channel.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    channel := make(chan string, 2)\n\n    channel &lt;- \"message 1\"\n    channel &lt;- \"message 2\"\n\n    msg1 := &lt;-channel\n    msg2 := &lt;-channel\n    fmt.Println(msg1)\n    fmt.Println(msg2)\n}\n</code></pre> output<pre><code>message 1\nmessage 2\n</code></pre></p>"},{"location":"multithreading/channels/#deadlock","title":"Deadlock","text":"<p>If a goroutine is sending data on a channel, then <code>it is expected that some other goroutine should be receiving the data</code>. <code>If this does not happen, then the program will panic at runtime with a deadlock error</code>. Similarly, if a goroutine is waiting to receive data from a channel, then some other goroutine is expected to write data on that channel, else the program will panic.</p>"},{"location":"multithreading/channels/#range-and-close","title":"Range and Close","text":"<p>You can use the <code>range</code> keyword to <code>read values from a channel until it's closed</code>. When the channel is closed and drained, the range loop will terminate.</p> Example <p>run command<pre><code>go run src/multithereading/range_channel.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    messages := make(chan string)\n\n    go func() {\n        messages &lt;- \"ping 1\"\n        messages &lt;- \"ping 2\"\n        close(messages)\n    }()\n\n    for msg := range messages {\n        fmt.Println(msg)\n    }\n}\n</code></pre> output<pre><code>ping 1\nping 2\n</code></pre></p> Range with WaitGroup <p>run command<pre><code>go run src/multithereading/range_waitgroup.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc publish(ch chan int, wg *sync.WaitGroup) {\n    for i := 0; i &lt; 10; i++ {\n        fmt.Printf(\"Publishing value :%d\\n\", i)\n        wg.Add(1) // using wg.Add(10) on line 27, this need to be removed\n        ch &lt;- i\n    }\n    close(ch)\n}\n\nfunc subscribe(ch chan int, wg *sync.WaitGroup) {\n    for x := range ch {\n        fmt.Printf(\"Subscribe value: :%d\\n\", x)\n        wg.Done()\n    }\n}\n\nfunc main() {\n    ch := make(chan int)\n    wg := sync.WaitGroup{}\n    // wg.Add(10)\n    go publish(ch, &amp;wg)\n    subscribe(ch, &amp;wg) // or go subscribe(ch, &amp;wg) using wg.Add(10) on line 27\n    wg.Wait()\n}\n</code></pre> output<pre><code>Publishing value :0\nPublishing value :1\nSubscribe value: :0\nSubscribe value: :1\nPublishing value :2\nPublishing value :3\nSubscribe value: :2\nSubscribe value: :3\nPublishing value :4\nPublishing value :5\nSubscribe value: :4\nSubscribe value: :5\nPublishing value :6\nPublishing value :7\nSubscribe value: :6\nSubscribe value: :7\nPublishing value :8\nPublishing value :9\nSubscribe value: :8\nSubscribe value: :9\n</code></pre></p>"},{"location":"multithreading/channels/#examples","title":"Examples","text":"<ol> <li>Api Race Challenge</li> </ol> Fake Load Balancer <p>run command<pre><code>go run src/multithereading/fake_loadbalancer.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc worker(workerId int, data &lt;-chan int) {\n    for x := range data {\n        fmt.Printf(\"Worked %d received %d\\n\", workerId, x)\n        time.Sleep(time.Second)\n    }\n}\n\nfunc main() {\n    ch := make(chan int)\n\n    workersNum := 1000\n\n    for i := 0; i &lt; workersNum; i++ {\n        go worker(i, ch)\n    }\n\n    for i := 0; i &lt; 2000; i++ {\n        ch &lt;- i\n    }\n}\n</code></pre> output<pre><code>...\nWorked 9 received 1926\nWorked 903 received 1997\nWorked 975 received 1971\nWorked 765 received 1942\nWorked 274 received 1839\nWorked 763 received 1856\nWorked 914 received 1860\nWorked 915 received 1864\nWorked 702 received 1877\nWorked 981 received 1898\nWorked 797 received 1879\nWorked 774 received 1853\nWorked 798 received 1882\nWorked 320 received 1275\nWorked 434 received 1276\nWorked 108 received 1073\nWorked 530 received 1277\n</code></pre></p>"},{"location":"multithreading/channels/#references","title":"References","text":"<ol> <li>Channels</li> <li>How to use Go channels</li> <li>Golang: Channel Directions</li> </ol>"},{"location":"multithreading/go_routines/","title":"Go Routines","text":"<p>Goroutines are one of the most important aspects of the Go programming language. <code>They are the smallest unit of execution and can continue their work alongside the main goroutine, creating concurrent execution</code>. They are <code>lightweight</code>, <code>cheap to create</code>, and can be used to effectively utilize <code>multi-core CPUs</code>. To create a goroutine is simple, just need to add the keyword <code>go</code> in front of the function you want to <code>run concurrently</code>.</p> Basic Example <p>run command<pre><code>go run src/multithereading/basic.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc print_nice(name string) {\n    for i := 0; i &lt; 10; i++ {\n        fmt.Printf(\"%d from %s\\n\", i, name)\n        time.Sleep(1 * time.Second)\n    }\n}\n\nfunc main() {\n    go print_nice(\"Corinthians\")\n    go print_nice(\"Knicks\")\n\n    go func() {\n        for i := 0; i &lt; 4; i++ {\n            fmt.Println(\"Just an annoying print\")\n            // time.Sleep(1 * time.Second)\n        }\n    }()\n\n}\n</code></pre> output<pre><code>Just an annoying print\n0 from Corinthians\n0 from Knicks\n1 from Knicks\nJust an annoying print\n1 from Corinthians\n2 from Corinthians\n2 from Knicks\nJust an annoying print\n3 from Corinthians\nJust an annoying print\n3 from Knicks\n4 from Knicks\n4 from Corinthians\n5 from Knicks\n5 from Corinthians\n6 from Knicks\n6 from Corinthians\n7 from Knicks\n7 from Corinthians\n8 from Knicks\n8 from Corinthians\n9 from Knicks\n9 from Corinthians\n</code></pre></p>"},{"location":"multithreading/go_routines/#syncwaitgroup","title":"sync.WaitGroup","text":"<p>A <code>sync.WaitGroup</code> in Go is <code>used to wait for a collection of goroutines to finish</code>. It's a way to ensure that all goroutines have completed their execution before the program continues. This is particularly useful when you have multiple goroutines performing tasks concurrently and <code>you need to wait for all of them to finish before proceeding</code>.</p> <p>Before starting a goroutine, you call the <code>Add</code> method on the WaitGroup to <code>increment the counter</code>. This tells the <code>WaitGroup</code> to <code>wait for one more goroutine to finish</code>. Inside the goroutine, when the work is done, you call the <code>Done</code> method on the <code>WaitGroup to decrement the counter</code>. Finally, you call the <code>Wait</code> method on the WaitGroup to <code>block the current goroutine until the counter is zero</code>.</p> Example <p>run command<pre><code>go run src/multithereading/wait_group.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc print_nice(name string, wg *sync.WaitGroup) {\n    for i := 0; i &lt; 10; i++ {\n        fmt.Printf(\"%d from %s\\n\", i, name)\n        time.Sleep(1 * time.Second)\n        wg.Done()\n    }\n}\n\nfunc main() {\n    waitGroup := sync.WaitGroup{}\n    waitGroup.Add(24)\n\n    go print_nice(\"Corinthians\", &amp;waitGroup)\n    go print_nice(\"Knicks\", &amp;waitGroup)\n\n    go func() {\n        for i := 0; i &lt; 4; i++ {\n            fmt.Println(\"Just an annoying print\")\n            time.Sleep(1 * time.Second)\n            waitGroup.Done()\n        }\n    }()\n    waitGroup.Wait()\n}\n</code></pre> output<pre><code>Just an annoying print\n0 from Corinthians\n0 from Knicks\n1 from Knicks\nJust an annoying print\n1 from Corinthians\n2 from Corinthians\n2 from Knicks\nJust an annoying print\n3 from Corinthians\nJust an annoying print\n3 from Knicks\n4 from Knicks\n4 from Corinthians\n5 from Knicks\n5 from Corinthians\n6 from Knicks\n6 from Corinthians\n7 from Knicks\n7 from Corinthians\n8 from Knicks\n8 from Corinthians\n9 from Knicks\n9 from Corinthians\n</code></pre></p> <p>If you need to set a <code>timeout</code> for the WaitGroup, you can use a <code>select</code> statement with a <code>time.After</code> function.</p> With Timeout <p>run command<pre><code>go run src/multithereading/wait_group_timeout.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"sync\"\n    \"time\"\n)\n\nfunc print_nice(name string, wg *sync.WaitGroup) {\n    for i := 0; i &lt; 10; i++ {\n        fmt.Printf(\"%d from %s\\n\", i, name)\n        time.Sleep(1 * time.Second)\n        defer wg.Done()\n    }\n}\n\nfunc main() {\n    waitGroup := sync.WaitGroup{}\n    waitGroup.Add(14)\n\n    go print_nice(\"Corinthians\", &amp;waitGroup)\n\n    go func() {\n        for i := 0; i &lt; 4; i++ {\n            fmt.Println(\"Just an annoying print\")\n            time.Sleep(1 * time.Second)\n            waitGroup.Done()\n        }\n    }()\n\n    done := make(chan bool)\n    go func() {\n        waitGroup.Wait()\n        // Close the Channel\n        close(done)\n    }()\n    select {\n    case &lt;-done:\n        log.Println(\"All done\")\n    case &lt;-time.After(9 * time.Second):\n        log.Println(\"Hit timeout\")\n    }\n}\n</code></pre> output<pre><code>Just an annoying print\n0 from Corinthians\n1 from Corinthians\nJust an annoying print\n2 from Corinthians\nJust an annoying print\n3 from Corinthians\nJust an annoying print\n4 from Corinthians\n5 from Corinthians\n6 from Corinthians\n7 from Corinthians\n8 from Corinthians\n2023/12/18 18:43:22 Hit timeout\n</code></pre></p>"},{"location":"multithreading/go_routines/#when-to-use-goroutines","title":"When to Use Goroutines","text":"<p>Goroutines are useful when <code>one task can be split into different segments to perform better</code>. Any work that can utilize a multi-core CPU should be well optimized using goroutines. <code>Running background operations</code> in a program might also be a use case for a goroutine.</p>"},{"location":"multithreading/go_routines/#real-life-use-cases","title":"Real-Life Use Cases","text":"<p>Some real-life use cases of goroutines include <code>reading a huge file and processing it</code> for exception or error messages, and <code>posting multiple API calls in different threads when they are not dependent on each other</code>.</p>"},{"location":"multithreading/go_routines/#goroutines-x-normal-threadsprocess","title":"Goroutines x Normal Threads/Process","text":"<p>Goroutines and threads are <code>both used for concurrent execution of code</code>, but they have <code>significant differences in terms of scheduling, communication, execution speed, infrastructure dependency, stack management, latency during program execution, resource control, and local storage management</code>.</p> <p><code>Goroutines are extremely cheap when compared to threads</code>. <code>They are only a few kilobytes in stack size</code> and the stack can grow and shrink according to the needs of the application. <code>There might be only one thread in a program with thousands of Goroutines</code>. If any Goroutine in that thread blocks, then another OS thread is created and the remaining Goroutines are moved to the new OS thread.</p> <p>Scheduling Management</p> <p><code>Goroutines are managed by the Go runtime</code>, which uses a technique known as m:n scheduling, <code>where m goroutines are executed using n operating system threads using multiplexing</code>. This means that <code>the Go scheduler is not invoked periodically by a hardware timer</code>, but implicitly by certain Go language constructs. <code>Because it doesn\u2019t need a switch to kernel context, rescheduling a goroutine is much cheaper than rescheduling a thread</code>.</p> Example <p>For example, when a goroutine calls <code>time.Sleep</code> or <code>blocks</code> in a channel or mutex operation, the scheduler puts it to sleep and runs another goroutine until it is time to wake the first one up.</p> <p>On the other hand, <code>threads are managed by the operating system</code>. Every few milliseconds, a hardware timer interrupts the processor, which causes a kernel function called the scheduler to be invoked. <code>This function suspends the currently executing thread and saves its registers in memory</code>, looks over the list of threads and decides which one should run next, restores that thread\u2019s registers from memory, then resumes the execution of that thread. <code>Because OS threads are scheduled by the kernel, passing control from one thread to another requires a full context switch, which is a slow operation</code>.</p> <p>Communication Medium</p> <p>Goroutines enhance communication through the use of a channel and <code>sync package</code> which provides a wait group function. <code>Threads do not have a clear communication medium</code>. In multiple threads executing, <code>communication is made through memory location</code>.</p> <p>Infrastructure Dependency</p> <p><code>Goroutines are not hardware dependent</code>, meaning they can be executed independently of any infrastructure. <code>Threads, are ardware dependent</code>.</p> <p>Stack Size</p> <p>Goroutines are executed in a <code>stack of 2kb (kilobytes)</code>, which <code>grows gradually</code> and is <code>destroyed once execution is done/completed</code>. Threads also execute in a stack, but they require at least a minimum of <code>1 megabyte</code> to execute, and <code>stack size is fixed</code>. Thus, stack management is easier with goroutines compared to threads.</p> <p>Latency During Program Execution</p> <p><code>Goroutines communicate with each other through</code> channels, thus low latency is experienced from one channel to another. In threads, since there is no communication medium between one thread to another, communication takes place with high latency.</p>"},{"location":"multithreading/go_routines/#references","title":"References","text":"<ol> <li>Goroutines in Golang</li> <li>Goroutines</li> <li>Goroutines vs Threads in Golang</li> </ol>"},{"location":"multithreading/race_condition/","title":"Race Condition","text":"<p>In Go, a <code>race condition occurs when two or more goroutines access and modify the same data concurrently</code>, leading to unpredictable and often erroneous behavior. <code>Go provides several tools to prevent race conditions and ensure the integrity of shared data</code>, including Mutexes, Read-Write Locks, and Atomic Operations.</p> <p>go run -race</p> <p>The <code>-race</code> flag in Go is used to enable the <code>built-in data race detector</code>. <code>Data races occur when two or more goroutines access the same memory location concurrently, and at least one of the accesses is a write</code>. This can lead to unpredictable behavior and hard-to-debug issues. It's typically used for <code>testing and debugging</code>, not for running production code.</p> run command<pre><code>go test -race mypkg   // test the package\ngo run -race mysrc.go // compile and run the program\ngo build -race mycmd  // build the command\ngo install -race mypkg // install the package\n</code></pre>"},{"location":"multithreading/race_condition/#mutexes-mutual-exclusion","title":"Mutexes (Mutual Exclusion)","text":"<p>A Mutex, short for mutual exclusion, is the <code>most basic form of concurrency control</code> in Go. It <code>allows only one goroutine to access a critical section of code at a time</code>.</p> Example <p>The shared <code>counter</code> variable, <code>which multiple goroutines increment concurrently</code>. <code>The sync.Mutex ensures that only one goroutine can execute the increment function at a time by locking and unlocking the Mutex before and after the critical section</code>.</p> <p>run command<pre><code>go run src/multithereading/mutex.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar (\n    counter int\n    mu      sync.Mutex\n)\n\nfunc increment() {\n    mu.Lock()\n    defer mu.Unlock()\n    counter++\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    for i := 0; i &lt; 1000; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            increment()\n        }()\n    }\n    wg.Wait()\n    fmt.Println(\"Counter: \", counter)\n}\n</code></pre> output<pre><code>Counter:  1000\n</code></pre></p>"},{"location":"multithreading/race_condition/#read-write-locks","title":"Read-Write Locks","text":"<p>Read-Write Locks are a <code>type of lock that can be held by multiple readers but only one writer at a time</code>. They are useful when you have <code>many read operations and few write operations</code>.</p> <p>In Go, the <code>sync.RWMutex</code> type provides a read-write lock that <code>allows multiple goroutines to read data simultaneously but ensures exclusive access for writing</code>. This is useful in scenarios where you have many read operations and few write operations.</p> Example <p>The <code>sync.RWMutex</code> protect access to the <code>data</code> map. <code>Multiple goroutines can read the data using RLock()</code>, allowing for concurrent reading. <code>When writing data, we use Lock() to ensure exclusive access</code>, preventing any concurrent reads or writes.</p> <p>run command<pre><code>go run src/multithereading/rwmutex.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nvar (\n    data  map[string]string\n    mutex sync.RWMutex\n)\n\nfunc init() {\n    data = make(map[string]string)\n    data[\"key1\"] = \"value1\"\n    data[\"key2\"] = \"value2\"\n}\n\nfunc readData(key string) string {\n    mutex.RLock()\n    defer mutex.RUnlock()\n    return data[key]\n}\n\nfunc writeData(key, value string) {\n    mutex.Lock()\n    defer mutex.Unlock()\n    data[key] = value\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n    for i := 0; i &lt; 5; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            fmt.Println(\"Read Data:\", readData(\"key1\"))\n        }()\n    }\n    time.Sleep(time.Second) // Let the readers start first\n\n    for i := 0; i &lt; 2; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            writeData(\"key1\", \"newvalue1\")\n            fmt.Println(\"Write Data: key1 -&gt; newvalue1\")\n        }()\n    }\n\n    wg.Wait()\n}\n</code></pre> output<pre><code>Read Data: value1\nRead Data: value1\nRead Data: value1\nRead Data: value1\nRead Data: value1\nWrite Data: key1 -&gt; newvalue1\nWrite Data: key1 -&gt; newvalue1\n</code></pre></p>"},{"location":"multithreading/race_condition/#atomic-operations","title":"Atomic Operations","text":"<p>While Mutexes and Read-Write Locks provide high-level abstractions for concurrency control, Go also offers <code>atomic operations for more fine-grained control over shared variables</code>. These operations <code>allow you to perform read-modify-write operations on variables atomically</code>, without the need for locks.</p> Example <p>The <code>atomic.AddInt32</code> atomically increment the counter variable. <code>Since atomic operations are executed without locks, they are highly efficient and are suitable for scenarios where fine-grained control is needed with minimal overhead</code>.</p> <p>run command<pre><code>go run src/multithereading/atomic.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"sync/atomic\"\n)\n\nvar (\n    counter int32\n    wg      sync.WaitGroup\n)\n\nfunc increment() {\n    atomic.AddInt32(&amp;counter, 1)\n    wg.Done()\n}\n\nfunc main() {\n    const numGoroutines = 1000\n    wg.Add(numGoroutines)\n\n    for i := 0; i &lt; numGoroutines; i++ {\n        go increment()\n    }\n    wg.Wait()\n    fmt.Println(\"Counter: \", counter)\n}\n</code></pre> output<pre><code>Counter:  1000\n</code></pre></p>"},{"location":"multithreading/race_condition/#choosing-the-right-concurrency-control-mechanism","title":"Choosing the Right Concurrency Control Mechanism","text":"<p>When it comes to choosing the right concurrency control mechanism in Go, you need to consider the <code>specific requirements of your application</code>. <code>Mutexes are suitable for scenarios where only one goroutine should access a critical section at a time</code>. <code>Atomic operations are more efficient but can be more difficult to use correctly</code>. In some cases, a combination of these mechanisms may be beneficial.</p>"},{"location":"multithreading/race_condition/#references","title":"References","text":"<ol> <li>Concurrency Control in Go: Mutexes, Read-Write Locks, and Atomic Operations</li> <li>Introducing the Go Race Detector</li> <li>Data Race Detector</li> </ol>"},{"location":"multithreading/select/","title":"Select","text":"<p>The <code>select</code> statement in Go is used to <code>handle multiple channel operations concurrently</code>. It blocks until one of the operations can proceed. <code>This is particularly useful when you have multiple goroutines communicating via channels and you want to handle their messages as they arrive</code>. You can also use the <code>default</code> case in a select statement to <code>prevent blocking</code>. <code>If none of the cases are ready</code>, the <code>default</code> case will be executed.</p> <p>Example</p> <p>We then use a <code>select statement to receive data from either channel</code>. In this case, it will print the data received from the <code>number channel because this channel is ready first</code>.</p> <p>run command<pre><code>go run src/multithereading/basic_select.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    number := make(chan int)\n    message := make(chan string)\n\n    go channelNumber(number)\n    go channelMessage(message)\n\n    select {\n    case firstChannel := &lt;-number:\n        fmt.Println(\"Channel Data:\", firstChannel)\n\n    case secondChannel := &lt;-message:\n        fmt.Println(\"Channel Data:\", secondChannel)\n    }\n}\n\nfunc channelNumber(number chan int) {\n    number &lt;- 15\n}\n\nfunc channelMessage(message chan string) {\n    time.Sleep(2 * time.Second)\n    message &lt;- \"Learning Go Select\"\n}\n</code></pre> output<pre><code>Channel Data: 15\n</code></pre></p> <p>Default</p> <p>run command<pre><code>go run src/multithereading/default_select.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"time\"\n)\n\nfunc main() {\n\n    ch := make(chan int)\n\n    go func() {\n        for i := 0; i &lt; 3; i++ {\n            time.Sleep(2 * time.Second)\n            ch &lt;- 1\n        }\n    }()\n\n    for i := 0; i &lt; 10; i++ {\n        time.Sleep(time.Second)\n        select {\n        case num := &lt;-ch:\n            fmt.Printf(\"Number received: %d\\n\", num)\n        default:\n            log.Println(\"Default\")\n        }\n    }\n}\n</code></pre> output<pre><code>...\n2023/12/20 12:13:12 Default\nNumber received: 1\n2023/12/20 12:13:14 Default\nNumber received: 1\n2023/12/20 12:13:16 Default\n2023/12/20 12:13:17 Default\nNumber received: 1\n2023/12/20 12:13:19 Default\n2023/12/20 12:13:20 Default\n2023/12/20 12:13:21 Default\n</code></pre></p> <p>More Complex example</p> <p>run command<pre><code>go run src/multithereading/select.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"sync/atomic\"\n    \"time\"\n)\n\ntype Message struct {\n    id  int32\n    Msg string\n}\n\nvar countId int32 = 0\n\nfunc rabbitMQMessage(ch chan&lt;- Message) {\n    // Infity loop\n    for {\n        atomic.AddInt32(&amp;countId, 1)\n        msg := Message{countId, fmt.Sprintf(\"Message %d from RabbitMQ\", countId)}\n        ch &lt;- msg\n        if countId &gt; 8 {\n            time.Sleep(4 * time.Second)\n        }\n    }\n}\n\nfunc kafkaMessage(ch chan&lt;- Message) {\n    // Infity loop\n    for {\n        atomic.AddInt32(&amp;countId, 1)\n        msg := Message{countId, fmt.Sprintf(\"Message %d from Kafka\", countId)}\n        ch &lt;- msg\n        if countId &gt; 4 {\n            time.Sleep(4 * time.Second)\n        }\n    }\n}\n\nfunc main() {\n    ch1 := make(chan Message)\n    ch2 := make(chan Message)\n\n    go rabbitMQMessage(ch1)\n    go kafkaMessage(ch2)\n\n    for i := 0; i &lt; 20; i++ {\n        select {\n        case msg := &lt;-ch1:\n            fmt.Printf(\"Received from ch1: ID: %d - %s\\n\", msg.id, msg.Msg)\n        case msg := &lt;-ch2:\n            fmt.Printf(\"Received from ch2: ID: %d - %s\\n\", msg.id, msg.Msg)\n        case &lt;-time.After(time.Second * 2):\n            log.Print(\"timeout\")\n        }\n    }\n\n}\n</code></pre> output<pre><code>...\nReceived from ch2: ID: 1 - Message 1 from Kafka\nReceived from ch2: ID: 2 - Message 2 from Kafka\nReceived from ch2: ID: 4 - Message 4 from Kafka\nReceived from ch2: ID: 5 - Message 5 from Kafka\nReceived from ch1: ID: 5 - Message 3 from RabbitMQ\nReceived from ch1: ID: 6 - Message 6 from RabbitMQ\nReceived from ch1: ID: 7 - Message 7 from RabbitMQ\nReceived from ch1: ID: 8 - Message 8 from RabbitMQ\nReceived from ch1: ID: 9 - Message 9 from RabbitMQ\n2023/12/20 12:05:49 timeout\n2023/12/20 12:05:51 timeout\nReceived from ch1: ID: 10 - Message 10 from RabbitMQ\nReceived from ch2: ID: 11 - Message 11 from Kafka\n2023/12/20 12:05:53 timeout\nReceived from ch2: ID: 12 - Message 12 from Kafka\nReceived from ch1: ID: 13 - Message 13 from RabbitMQ\n2023/12/20 12:05:57 timeout\nReceived from ch1: ID: 14 - Message 14 from RabbitMQ\nReceived from ch2: ID: 15 - Message 15 from Kafka\n2023/12/20 12:06:01 timeout\n</code></pre></p>"},{"location":"multithreading/select/#references","title":"References","text":"<ol> <li>Go Select</li> <li>How To Effectively Utilize Golang Select In Your Projects</li> </ol>"},{"location":"projects/get_br_zipcode/","title":"Get Address - Basic API","text":"<p>Help: JSON-to-Go</p> run command<pre><code>cd src/projectapi/\ngo run main.go\ncurl localhost:8080/get-address?zipcode=08295005\ncurl localhost:8080/get-address?zipcode=03087000\ncurl localhost:8080/get-address?zipcode=17509180\n</code></pre> <pre><code>package address\n\nimport (\n    \"encoding/json\"\n    \"io\"\n    \"net/http\"\n)\n\ntype Address struct {\n    ZipCode     string `json:\"cep\"`\n    PublicPlace string `json:\"logradouro\"`\n    Extra       string `json:\"complemento\"`\n    District    string `json:\"bairro\"`\n    City        string `json:\"localidade\"`\n    State       string `json:\"uf\"`\n    Ibge        string `json:\"ibge\"`\n    Gia         string `json:\"gia\"`\n    Ddd         string `json:\"ddd\"`\n    Siafi       string `json:\"siafi\"`\n}\n\nfunc GetAddress(zipcode string) (*Address, error) {\n    url := \"https://viacep.com.br/ws/\" + zipcode + \"/json\"\n    req, err := http.Get(url)\n    if err != nil {\n        return nil, err\n    }\n    defer req.Body.Close()\n    res, _ := io.ReadAll(req.Body)\n    var address Address\n    err = json.Unmarshal(res, &amp;address)\n    if err != nil {\n        return nil, err\n    }\n    return &amp;address, nil\n}\n</code></pre> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"example.com/api.project/address\"\n)\n\nfunc setHeaders(next http.Handler) http.Handler {\n    return http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {\n        res.Header().Set(\"Content-Type\", \"application/json\")\n        next.ServeHTTP(res, req)\n    })\n}\n\nfunc GetAddressHandler(res http.ResponseWriter, req *http.Request) {\n    queryData := req.URL.Query()\n    if !queryData.Has(\"zipcode\") {\n        res.WriteHeader(http.StatusBadRequest)\n        return\n    }\n    zipCodeParam := req.URL.Query().Get(\"zipcode\")\n    address, error := address.GetAddress(zipCodeParam)\n    if error != nil {\n        res.WriteHeader(http.StatusInternalServerError)\n        return\n    }\n    res.WriteHeader(http.StatusOK)\n    json.NewEncoder(res).Encode(address)\n}\n\nfunc main() {\n    mux := http.NewServeMux()\n\n    mux.HandleFunc(\"/get-address\", GetAddressHandler)\n    mux_wrapped := setHeaders(mux)\n\n    server := &amp;http.Server{\n        Addr:    \":8080\",\n        Handler: mux_wrapped,\n    }\n\n    fmt.Println(\"Server is listening on port 8080\")\n    if err := server.ListenAndServe(); err != nil {\n        log.Fatal(err)\n    }\n}\n</code></pre> output<pre><code>{\"cep\":\"08295-005\",\"logradouro\":\"Avenida Miguel Ign\u00e1cio Curi\",\"complemento\":\"\",\"bairro\":\"Vila Carmosina\",\"localidade\":\"S\u00e3o Paulo\",\"uf\":\"SP\",\"ibge\":\"3550308\",\"gia\":\"1004\",\"ddd\":\"11\",\"siafi\":\"7107\"}\n{\"cep\":\"03087-000\",\"logradouro\":\"Rua S\u00e3o Jorge\",\"complemento\":\"\",\"bairro\":\"Parque S\u00e3o Jorge\",\"localidade\":\"S\u00e3o Paulo\",\"uf\":\"SP\",\"ibge\":\"3550308\",\"gia\":\"1004\",\"ddd\":\"11\",\"siafi\":\"7107\"}\n{\"cep\":\"17509-180\",\"logradouro\":\"Avenida Vicente Ferreira\",\"complemento\":\"at\u00e9 470/471\",\"bairro\":\"Mar\u00edlia\",\"localidade\":\"Mar\u00edlia\",\"uf\":\"SP\",\"ibge\":\"3529005\",\"gia\":\"4388\",\"ddd\":\"14\",\"siafi\":\"6681\"}\n</code></pre>"},{"location":"structs/interface/","title":"Interface","text":"<p>In Go, interfaces are a powerful and flexible way to <code>define sets of methods that types must implement</code>. <code>They allow you to write functions and methods that can work with various types, as long as those types satisfy the interface contract</code>. Interfaces support methods but <code>not properties or fields</code>.</p> <p>To declare an interface, <code>you list the method signatures that types must implement</code>. <code>Any type that has methods matching these signatures implicitly implements the interface</code>. To implement an interface, <code>a type needs to provide method implementations that match the method signatures in the interface</code>. If a type has all the required methods, <code>it implicitly satisfies the interface</code>. Interfaces <code>promote polymorphism and decoupling of code</code>.</p> Example <p>run command<pre><code>go run structs/interfaces.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype Shape interface {\n    Area() float64\n}\n\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) Area() float64 {\n    return 3.14 * c.Radius * c.Radius\n}\n\ntype Rectangle struct {\n    Width  float64\n    Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc printArea(s Shape) {\n    area := s.Area()\n    fmt.Printf(\"Area: %.2f\\n\", area)\n}\n\nfunc main() {\n    c := Circle{Radius: 5.0}\n    r := Rectangle{Width: 4.0, Height: 6.0}\n    printArea(c)\n    printArea(r)\n}\n</code></pre> output<pre><code>Area: 78.50\nArea: 24.00\n</code></pre></p>"},{"location":"structs/structs/","title":"Structs","text":"<p>In Go, <code>structs are composite data types used to group together variables (fields) under a single data structure</code>. They are similar to classes in other languages, but <code>Go doesn't have classes in the traditional sense</code>.</p> <p>You define a struct using the <code>type</code> keyword, followed by the <code>name of the struct</code> and a set of field declarations within curly braces. To <code>create an instance</code> of a struct, you can use the <code>struct's name followed by curly braces and provide values for its fields</code>.</p> Example <p>run command<pre><code>go run structs/basic.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    person := Person{\n        Name: \"Gabriel\",\n        Age:  100,\n    }\n    fmt.Printf(\"Create object person, from Person struct: %v\\n\", person)\n}\n</code></pre> output<pre><code>Create object person, from Person struct: {Gabriel 100}\n</code></pre></p>"},{"location":"structs/structs/#anonymous-structs","title":"Anonymous Structs","text":"<p>Anonymous Structs are structs without a defined name, often used for <code>temporary data structures</code>.</p> Example <p>run command<pre><code>go run structs/anonymous.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    vector := struct {\n        X int\n        Y int\n    }{\n        X: 10,\n        Y: 20,\n    }\n    fmt.Printf(\"Create object from an anonymous structs : %v\\n\", vector)\n    fmt.Printf(\"X : %v\\n\", vector.X)\n    fmt.Printf(\"Y : %v\\n\", vector.Y)\n}\n</code></pre> output<pre><code>Create object from an anonymous structs : {10 20}\nX : 10\nY : 20\n</code></pre></p>"},{"location":"structs/structs/#composing-structs","title":"Composing Structs","text":"<p>In Go, you can <code>embed one struct within another</code>, creating a composition of structs. This is <code>similar to inheritance</code> in other languages.</p> Example <p>run command<pre><code>go run structs/composing.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype Team struct {\n    TeamName string\n}\n\ntype Person struct {\n    Name string\n    Age  int\n    Team\n    PersonTeam Team\n}\n\nfunc main() {\n    person := Person{\n        Name:       \"Gabriel\",\n        Age:        100,\n        Team:       Team{\"Corinthians\"},\n        PersonTeam: Team{\"Knicks\"},\n    }\n    fmt.Printf(\"Person: %v\\n\", person)\n    fmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.Team)\n    fmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.Team.TeamName)\n    fmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.TeamName)\n    fmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.PersonTeam)\n    fmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.TeamName)\n}\n</code></pre> output<pre><code>Person: {Gabriel 100 {Corinthians} {Knicks}}\nPerson name: Gabriel, Clube: {Corinthians}\nPerson name: Gabriel, Clube: Corinthians\nPerson name: Gabriel, Clube: Corinthians\nPerson name: Gabriel, Clube: {Knicks}\nPerson name: Gabriel, Clube: Corinthians\n</code></pre></p> Composing x Property, and Accessing Properties <p>In the given example, it's evident that the <code>Person struct is composed of a Team</code> and <code>has a property named PersonTeam of type Team</code>. The key distinction here is that when using the abbreviation <code>person.TeamName</code>, it returns the value of the composition, not the property. In Go, <code>you can directly access the properties of a composed struct</code>.</p>"},{"location":"structs/structs/#struct-methods","title":"Struct Methods","text":"<p>In Go, <code>structs can have methods associated with them</code>. These methods are <code>functions that operate on instances of the struct</code>, and they enable you to define behavior specific to the struct type.</p> Example <p>run command<pre><code>go run structs/methods.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) Area() float64 {\n    return 3.14 * c.Radius * c.Radius\n}\n\nfunc main() {\n    circle := Circle{Radius: 5.0}\n    area := circle.Area()\n    fmt.Printf(\"Area: %v\\n\", area)\n}\n</code></pre> output<pre><code>Area: 78.5\n</code></pre></p>"},{"location":"structs/structs/#pointer-receivers","title":"Pointer Receivers","text":"<p><code>Pointer receivers can modify the state of the struct directly</code>. Using a pointer receiver allows you to <code>change the state</code> of an instance directly. When you pass a struct to a function, you're essentially <code>passing a copy of the struct</code>. Using pointers, you can <code>pass a reference to the struct</code>, allowing the function to modify the original data.</p> Example <p>run command<pre><code>go run structs/methods_pointer.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) NormalArea() float64 {\n    result := 3.14 * c.Radius * c.Radius\n    c.Radius = 100\n    return result\n}\n\nfunc (c *Circle) PointerArea() float64 {\n    result := 3.14 * c.Radius * c.Radius\n    c.Radius = 100\n    return result\n}\n\nfunc main() {\n    circle := Circle{Radius: 5.0}\n    area := circle.NormalArea()\n    fmt.Printf(\"Area: %v\\n\", area)\n    fmt.Printf(\"Circle change? %v\\n\", circle)\n    area = circle.PointerArea()\n    fmt.Printf(\"Area: %v\\n\", area)\n    fmt.Printf(\"Circle change? %v\\n\", circle)\n}\n</code></pre> output<pre><code>Area: 78.5\nCircle change? {5}\nArea: 78.5\nCircle change? {100}\n</code></pre></p>"},{"location":"structs/structs/#pointers-constructors","title":"Pointers Constructors","text":"<p>In Go, when you create a constructor function for a struct, <code>it typically returns a reference to the newly created struct</code>. With this technique, <code>any modification made to the reference returned by the constructor will affect all places that use that reference. This can be quite powerful, especially when managing resources like database connections</code>.</p> Example <p>run command<pre><code>go run structs/constructor_pointer.go\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\ntype DbConnection struct {\n    isOpen   bool\n    str_conn string\n}\n\nfunc NewDbConnection(str_conn string) *DbConnection {\n    return &amp;DbConnection{\n        isOpen:   true,\n        str_conn: str_conn,\n    }\n}\n\nfunc (conn *DbConnection) Close() {\n    conn.isOpen = false\n    fmt.Println(\"Closing the DB conncetion \", conn.str_conn)\n}\n\nfunc main() {\n    dbConn := NewDbConnection(\"**nice connection!***\")\n    dbConnValue := *dbConn\n    performQuery1(dbConnValue)\n    performQuery2(dbConn)\n    performQuery3(dbConn)\n\n    dbConn.Close()\n\n    performQuery1(dbConnValue)\n    performQuery2(dbConn)\n    performQuery3(dbConn)\n}\n\nfunc performQuery1(conn DbConnection) {\n    fmt.Println(\"Query 1 executed\", conn.str_conn, conn.isOpen)\n}\n\nfunc performQuery2(conn *DbConnection) {\n    fmt.Println(\"Query 2 executed\", conn.str_conn, conn.isOpen)\n}\n\nfunc performQuery3(conn *DbConnection) {\n    fmt.Println(\"Query 3 executed\", conn.str_conn, conn.isOpen)\n}\n</code></pre> output<pre><code>Query 1 executed **nice connection!*** true\nQuery 2 executed **nice connection!*** true\nQuery 3 executed **nice connection!*** true\nClosing the DB conncetion  **nice connection!***\nQuery 1 executed **nice connection!*** true\nQuery 2 executed **nice connection!*** false\nQuery 3 executed **nice connection!*** false\n</code></pre></p>"},{"location":"structs/structs/#structs-tags","title":"Structs Tags","text":"<p>Struct tags are <code>annotations that can be added to the fields of a struct to provide additional information or metadata about the field</code>. Struct tags are <code>typically used to describe how the struct fields should be encoded or decoded to and from other formats, such as JSON, XML, or other data serialization formats</code>. They play a crucial role in mapping Go data structures to external formats, enabling seamless data interchange between different systems or languages.</p> Example <ol> <li>Struct tags are added to each field to <code>specify the corresponding JSON field names</code>. For example, the json:\"name\" tag indicates that the Name field should be encoded as \"name\" in JSON.</li> <li>The <code>omitempty</code> option in the json:\"address,omitempty\" tag indicates that the Address <code>field should be omitted from the JSON output if it is empty</code>.</li> </ol> <p>run command<pre><code>go run src/structs/tags.go\n</code></pre> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\ntype Person struct {\n    Name    string `json:\"name\"`\n    Age     int    `json:\"age\"`\n    Address string `json:\"address,omitempty\"`\n}\n\nfunc main() {\n    person := Person{Name: \"Gabriel\", Age: 25}\n    jsonData, err := json.Marshal(person)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"JSON Data:\", string(jsonData))\n}\n</code></pre> output<pre><code>JSON Data: {\"name\":\"Gabriel\",\"age\":25}\n</code></pre></p>"},{"location":"testing/","title":"Testing","text":"<p>In Go, the <code>testing</code> package provides support for <code>automated testing</code> of Go packages. It is intended to be used in concert with the <code>go test</code> command, <code>which automates execution of any function of the form func TestXxx(*testing.T) where Xxx does not start with a lowercase letter</code>. The function name serves to identify the test routine. Within these functions, use the <code>Error</code>, <code>Fail</code> or related methods to signal failure.</p> <p><code>To write a new test suite, create a file that contains the TestXxx functions and give that file a name ending in _test.go</code>. <code>The file will be excluded from regular package builds but will be included when the \"go test\" command is run</code>. The test file can be in the same package as the one being tested, or in a corresponding package with the suffix <code>_test</code>.</p> <p>Example</p> <p><pre><code>package tax\n\nfunc CalculateTax(amount float64) float64 {\n    if amount &lt;= 0 {\n        return 0\n    }\n\n    if amount &gt;= 1000 &amp;&amp; amount &lt; 20000 {\n        return 10.0\n    }\n\n    if amount &gt;= 20000 {\n        return 20.0\n    }\n    return 5.0\n}\n</code></pre> <pre><code>package tax\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCalculateTax(t *testing.T) {\n    result := CalculateTax(500.0)\n    assert.Equal(t, result, 5.0)\n}\n\nfunc TestCalculateTaxBatch(t *testing.T) {\n    type calcTax struct {\n        amount, expect float64\n    }\n\n    table := []calcTax{\n        {500.0, 5.0},\n        {1000.0, 10.0},\n        {1500.0, 10.0},\n    }\n\n    for _, item := range table {\n        result := CalculateTax(item.amount)\n        if result != item.expect {\n            t.Errorf(\"Expected %f but got %f\", item.expect, result)\n        }\n    }\n}\n</code></pre></p>"},{"location":"testing/#measure-test-coverage","title":"Measure Test Coverage","text":"<p>In Go, you can measure test coverage using the command <code>go test -coverprofile</code> flag. This flag instructs the command to write a coverage profile to a file after running the tests. <code>The coverage profile includes information about which parts of your code were executed during the tests</code>.</p> <p>Example</p> <p>This command will run all tests in the current directory and write the coverage profile to a file named <code>coverage.out</code>.</p> <p><pre><code>go test -coverprofile=coverage.out\n</code></pre> output<pre><code>PASS\ncoverage: 80.0% of statements\nok      tax     0.003s\n</code></pre></p> <p>Analyze the coverage profile using the <code>go tool cover</code> command. <code>This command can generate a report in different formats, such as text or HTML</code>.</p> Example <p>This command will generate an <code>HTML report</code> and write it to a file named <code>coverage.html</code>. You can then open this file in a web browser to view the coverage report.</p> <p><pre><code>go tool cover -html=coverage.out -o coverage.html\n</code></pre> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;\n        &lt;title&gt;tax: Go Coverage Report&lt;/title&gt;\n        &lt;style&gt;\n            body {\n                background: black;\n                color: rgb(80, 80, 80);\n            }\n            body, pre, #legend span {\n                font-family: Menlo, monospace;\n                font-weight: bold;\n            }\n            #topbar {\n                background: black;\n                position: fixed;\n                top: 0; left: 0; right: 0;\n                height: 42px;\n                border-bottom: 1px solid rgb(80, 80, 80);\n            }\n            #content {\n                margin-top: 50px;\n            }\n            #nav, #legend {\n                float: left;\n                margin-left: 10px;\n            }\n            #legend {\n                margin-top: 12px;\n            }\n            #nav {\n                margin-top: 10px;\n            }\n            #legend span {\n                margin: 0 5px;\n            }\n            .cov0 { color: rgb(192, 0, 0) }\n.cov1 { color: rgb(128, 128, 128) }\n.cov2 { color: rgb(116, 140, 131) }\n.cov3 { color: rgb(104, 152, 134) }\n.cov4 { color: rgb(92, 164, 137) }\n.cov5 { color: rgb(80, 176, 140) }\n.cov6 { color: rgb(68, 188, 143) }\n.cov7 { color: rgb(56, 200, 146) }\n.cov8 { color: rgb(44, 212, 149) }\n.cov9 { color: rgb(32, 224, 152) }\n.cov10 { color: rgb(20, 236, 155) }\n\n        &lt;/style&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;div id=\"topbar\"&gt;\n            &lt;div id=\"nav\"&gt;\n                &lt;select id=\"files\"&gt;\n\n                &lt;option value=\"file0\"&gt;tax/tax.go (80.0%)&lt;/option&gt;\n\n                &lt;/select&gt;\n            &lt;/div&gt;\n            &lt;div id=\"legend\"&gt;\n                &lt;span&gt;not tracked&lt;/span&gt;\n\n                &lt;span class=\"cov0\"&gt;not covered&lt;/span&gt;\n                &lt;span class=\"cov8\"&gt;covered&lt;/span&gt;\n\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div id=\"content\"&gt;\n\n        &lt;pre class=\"file\" id=\"file0\" style=\"display: none\"&gt;package tax\n\nfunc CalculateTax(amount float64) float64 &lt;span class=\"cov8\" title=\"1\"&gt;{\n        if amount == 0 &lt;/span&gt;&lt;span class=\"cov0\" title=\"0\"&gt;{\n                return 0\n        }&lt;/span&gt;\n\n        &lt;span class=\"cov8\" title=\"1\"&gt;if amount &amp;gt;= 1000 &lt;/span&gt;&lt;span class=\"cov8\" title=\"1\"&gt;{\n                return 10.0\n        }&lt;/span&gt;\n        &lt;span class=\"cov8\" title=\"1\"&gt;return 5.0&lt;/span&gt;\n}\n&lt;/pre&gt;\n\n        &lt;/div&gt;\n    &lt;/body&gt;\n    &lt;script&gt;\n    (function() {\n        var files = document.getElementById('files');\n        var visible;\n        files.addEventListener('change', onChange, false);\n        function select(part) {\n            if (visible)\n                visible.style.display = 'none';\n            visible = document.getElementById(part);\n            if (!visible)\n                return;\n            files.value = part;\n            visible.style.display = 'block';\n            location.hash = part;\n        }\n        function onChange() {\n            select(files.value);\n            window.scrollTo(0, 0);\n        }\n        if (location.hash != \"\") {\n            select(location.hash.substr(1));\n        }\n        if (!visible) {\n            select(\"file0\");\n        }\n    })();\n    &lt;/script&gt;\n&lt;/html&gt;\n</code></pre></p>"},{"location":"testing/#benchmarking","title":"Benchmarking","text":"<p>You can also write <code>benchmark tests</code> in Go, which <code>measure the performance of a function or program</code>. It allows you to identify <code>potential areas for optimization</code> and <code>understand the impact of the changes you make to your code</code>. The <code>testing</code> package in Go provides support for benchmarking, which is done by creating <code>functions with a specific signature that takes a pointer to testing.B as its only argument</code>.</p> <p>To <code>run</code> the benchmark, use the <code>go test</code> command with the <code>-bench</code> flag.</p> Example <p>This command will generate an <code>HTML report</code> and write it to a file named <code>coverage.html</code>. You can then open this file in a web browser to view the coverage report.</p> <p><pre><code>go test -bench=.\n# OR go test -bench=. -count 5 -run=^# -benchtime=5s\n</code></pre> <pre><code>package tax\n\nimport \"time\"\n\nfunc CalculateTaxB(amount float64) float64 {\n    if amount == 0 {\n        return 0\n    }\n\n    if amount &gt;= 1000 {\n        return 10.0\n    }\n    return 5.0\n}\n\nfunc CalculateTaxB2(amount float64) float64 {\n    if amount == 0 {\n        return 0\n    }\n    time.Sleep(time.Millisecond)\n    if amount &gt;= 1000 {\n        return 10.0\n    }\n    return 5.0\n}\n</code></pre> <pre><code>package tax\n\nimport \"testing\"\n\nfunc BenchmarkCalculateTax(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        CalculateTaxB(500.0)\n    }\n}\n\nfunc BenchmarkCalculateTax2(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        CalculateTaxB2(500.0)\n    }\n}\n</code></pre> output<pre><code>goos: linux\ngoarch: amd64\npkg: tax\ncpu: Intel(R) Core(TM) i5-9300H CPU @ 2.40GHz\nBenchmarkCalculateTax-8         1000000000               0.2814 ns/op\nBenchmarkCalculateTax2-8            1084           1109872 ns/op\nPASS\nok      tax     1.629s\n</code></pre></p>"},{"location":"testing/#fuzzing","title":"Fuzzing","text":"<p>Fuzzing is a type of automated testing which <code>continuously manipulates inputs to a program to find bugs</code>. Fuzzing uses <code>coverage guidance to intelligently walk through the code being fuzzed to find and report failures to the user</code>. It can reach <code>edge cases</code> which humans often miss, making fuzz testing particularly valuable for <code>finding security exploits and vulnerabilities</code>.</p> <pre><code>```bash\ngo test -fuzz=. -fuzztime=5s\n```\n```go\npackage tax\n\nfunc CalculateTax(amount float64) float64 {\n    if amount &lt;= 0 {\n        return 0\n    }\n\n    if amount &gt;= 1000 &amp;&amp; amount &lt; 20000 {\n        return 10.0\n    }\n\n    if amount &gt;= 20000 {\n        return 20.0\n    }\n    return 5.0\n}\n```\n```go\npackage tax\n\nimport \"testing\"\n\nfunc FuzzCalculateTax(f *testing.F) {\n    seed := []float64{-1, -2, -2.5, 500.0, 1000.0, 1501.0}\n    for _, amount := range seed {\n        f.Add(amount)\n    }\n    f.Fuzz(func(t *testing.T, amount float64) {\n        result := CalculateTax(amount)\n        if amount &lt;= 0 &amp;&amp; result != 0 {\n            t.Errorf(\"Reveived %f but expected 0\", result)\n        }\n        if amount &gt; 20000 &amp;&amp; result != 20 {\n            t.Errorf(\"Reveived %f but expected 20\", result)\n        }\n    })\n}\n```\n```bash title=\"output\"\nfuzz: elapsed: 0s, gathering baseline coverage: 0/8 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 8/8 completed, now fuzzing with 8 workers\nfuzz: elapsed: 3s, execs: 89077 (29688/sec), new interesting: 0 (total: 8)\nfuzz: elapsed: 5s, execs: 150973 (29952/sec), new interesting: 0 (total: 8)\nPASS\nok      tax     5.073s\n```\n</code></pre>"},{"location":"testing/#reference","title":"Reference","text":"<ol> <li>Go testing</li> <li>How To Write Unit Tests in Go</li> <li>Go Fuzzing</li> </ol>"}]}