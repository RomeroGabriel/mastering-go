{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Go","text":"<p>Gi Studies Wiki: A centralized repository offering a wealth of resources and insights for mastering Go programming.</p> <p>A particular but not private repository to centralize all studies about Go and a few famous Go's libraries. It's kind my own documentation about the language. </p>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>Go Expert - FullCycle</li> </ul> <p>*and of course chatGPT </p>"},{"location":"basics/go_cli/","title":"Go CLI","text":""},{"location":"basics/go_cli/#go-environment-command","title":"Go Environment Command","text":"<p>Lists all Go <code>environment variables</code>.</p> <pre><code>go env\n</code></pre> go env output <pre><code>GO111MODULE=''\nGOARCH='amd64'\nGOBIN=''\nGOCACHE='/home/gabriel/.cache/go-build'\nGOENV='/home/gabriel/.config/go/env'\nGOEXE=''\nGOEXPERIMENT=''\nGOFLAGS=''\nGOHOSTARCH='amd64'\nGOHOSTOS='linux'\nGOINSECURE=''\nGOMODCACHE='/home/gabriel/go/pkg/mod'\nGONOPROXY=''\nGONOSUMDB=''\nGOOS='linux'\nGOPATH='/home/gabriel/go'\nGOPRIVATE=''\nGOPROXY='https://proxy.golang.org,direct'\nGOROOT='/usr/local/go'\nGOSUMDB='sum.golang.org'\nGOTMPDIR=''\nGOTOOLCHAIN='auto'\nGOTOOLDIR='/usr/local/go/pkg/tool/linux_amd64'\nGOVCS=''\nGOVERSION='go1.21.1'\nGCCGO='gccgo'\nGOAMD64='v1'\nAR='ar'\nCC='gcc'\nCXX='g++'\nCGO_ENABLED='1'\nGOMOD='/dev/null'\nGOWORK=''\nCGO_CFLAGS='-O2 -g'\nCGO_CPPFLAGS=''\nCGO_CXXFLAGS='-O2 -g'\nCGO_FFLAGS='-O2 -g'\nCGO_LDFLAGS='-O2 -g'\nPKG_CONFIG='pkg-config'\nGOGCCFLAGS='-fPIC -m64 -pthread -Wl,--no-gc-sections -fmessage-length=0 -ffile-prefix-map=/tmp/go-build4097433368=/tmp/go-build -gno-record-gcc-switches'\n</code></pre>"},{"location":"basics/go_cli/#gopath","title":"GOPATH","text":"<p><code>GOPATH</code> is a variable that <code>defines the root of your workspace</code>. It stores your code base and all the files necessary for your development. <code>It also contains the binaries of your compilations and the libraries used.</code></p>"},{"location":"basics/go_cli/#gomodcache","title":"GOMODCACHE","text":"<p><code>GOMODCACHE</code> is related to <code>Go module management</code>, which is used for handling dependencies. It is <code>typically a subfolder within your GOPATH</code>.</p>"},{"location":"basics/go_paradigm/","title":"Go's Paradigms","text":"<p>Go aims to be both simple and powerful, with the goal of enhancing programmers' productivity. <code>It boasts a straightforward and consistent syntax that remains stable across versions, ensuring compatibility</code>. One of Go's standout features is its robust support for concurrency. <code>It is designed to efficiently leverage multicore processors and excel in handling network-related tasks</code>. In terms of typing, <code>Go follows a static and strong typing system</code>. Here are some key aspects of Go's paradigms and its way of work:</p> <ol> <li>Concurrent and Structured Programming;</li> <li>Static and Strong Typing;</li> </ol>"},{"location":"basics/packages/","title":"Packages","text":"<p>Every <code>.go file begins with the package command</code>, and the <code>package's name should match the directory in which the file resides</code>. The exceptions to this rule are 'package main' and 'package test,' which serve as the entry points for applications and tests, respectively. <code>Packages within the same directory should share the same package name. Anything within the same package can be accessed and utilized</code>.</p> <p>Simple package example</p> <p>run command<pre><code>go run src/packages/*\n</code></pre> src/packages/nice_func.go<pre><code>package main\nfunc nice_func() {\nprintln(\"   I'm on the same directory than main, so my package has to be main\")\n}\n</code></pre> src/packages/main.go<pre><code>package main\nfunc main() {\nprintln(\"Starting script\")\nprintln(\"Now, calling nice_func that is defined from the same file directory, on nice_func.go file\")\nnice_func()\n}\n</code></pre> output<pre><code>Starting script\nNow, calling nice_func that is defined from the same file directory, on nice_func.go file\n    I'm on the same directory than main, so my package has to be main\n</code></pre></p>"},{"location":"basics/packages/#references","title":"References","text":"<ul> <li>Go Expert - FullCycle</li> </ul>"},{"location":"basics/vars/","title":"Variables and Data Types","text":"<p>In Go, <code>variables and constants are strongly typed</code>. To declare a constant, you use the <code>const</code> keyword, and for variables, you use <code>var</code>.</p> <p>Go can also <code>automatically infer variable types</code>, providing various syntaxes for declaring variables and constants, as shown below.</p> Simple vars example <p>run command<pre><code>go run src/variables/*\n</code></pre> <pre><code>package main\nconst A = \"I'm a constant\"\nvar B bool\nfunc main() {\nprintln(\"Starting basic variables\")\nprint(\"Print A const: \")\nprintln(A)\nprint(\"Print B var: \")\nprintln(B)\nprintln(\"NOTICE: B was infer as false\")\nprintln()\nprintln(\"Different ways to declare a variable: \")\nvar full_declare string = \"A\"\nprintln(\"Full declaration: \" + full_declare)\nshort_hand := \"B\"\nprintln(\"Short hand: \" + short_hand)\n}\n</code></pre> output<pre><code>Starting basic variables\nPrint A const: I'm a constant\nPrint B var: false\nNOTICE: B was infer as false\nDifferent ways to declare a variable:\nFull declaration: A\nShort hand: B\n</code></pre></p> Checking Default Infered Types <p>run command<pre><code>go run variables/infer_types.go </code></pre> <pre><code>package main\nvar (\nb  bool\nc  int\nd  string\ne  float32\ne6 float64\n)\nfunc main() {\nprint(\"bool \")\nprintln(b)\nprint(\"int \")\nprintln(c)\nprint(\"string \")\nprintln(d)\nprint(\"float32 \")\nprintln(e)\nprint(\"float64 \")\nprintln(e6)\n}\n</code></pre> output<pre><code>bool false\nint 0\nstring float32 +0.000000e+000\nfloat64 +0.000000e+000\n</code></pre></p>"},{"location":"basics/vars/#using-type","title":"Using type","text":"<p>In Go the <code>type</code> keyword is used to <code>define custom data types</code>. These custom types can be based on existing types, making it a versatile feature in the language.</p> Using type <p>run command<pre><code>go run variables/using_type.go\n</code></pre> <pre><code>package main\ntype custom_id string\nfunc main() {\ncustom_id := \"e96d759e-dc59-4394-9feb-79c8bf4130c9\"\nprintln(\"custom_id value: \" + custom_id)\n}\n</code></pre> output<pre><code>custom_id value: e96d759e-dc59-4394-9feb-79c8bf4130c9\n</code></pre></p>"},{"location":"basics/vars/#arrays","title":"Arrays","text":"<p>In Go, an array is a <code>fixed-size collection of elements of the same type</code>. Arrays are declared with a specific size, and that <code>size cannot be changed after the array is created</code>.</p> Example <p>run command<pre><code>go run variables/arrays.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvar myArray [3]int\nmyArray[1] = 10\nmyArray[2] = 20\nfmt.Println(myArray[0])\nfmt.Println(myArray)\nfor i, value := range myArray {\nfmt.Printf(\"Value stored in %d index is %d\\n\", i, value)\n}\ninitArray := [3]string{\"apple\", \"banana\", \"cherry\"}\nfor i, value := range initArray {\nfmt.Printf(\"Value stored in %d index is %v\\n\", i, value)\n}\n}\n</code></pre> output<pre><code>0\n[0 10 20]\nValue stored in 0 index is 0\nValue stored in 1 index is 10\nValue stored in 2 index is 20\nValue stored in 0 index is apple\nValue stored in 1 index is banana\nValue stored in 2 index is cherry\n</code></pre></p>"},{"location":"basics/vars/#slices","title":"Slices","text":"<p>In Go, a slice is a <code>more versatile and dynamic alternative to arrays</code>. Slices are like views into an underlying array, allowing you to work with a portion of an a<code>rray without specifying a fixed size</code>. Slices allow you to perform operations like appending elements, slicing (creating sub-slices), and growing dynamically.</p> <p>Slices also have a <code>length and capacity</code> (the maximum number of elements it can hold without reallocation). Use the <code>len()</code> and <code>cap()</code> functions to get these values.</p> Example <p>run command<pre><code>go run variables/slices.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nmy_slice := []int{10, 20, 30, 40, 50, 60}\nfmt.Println(\"Full slice: \", my_slice)\nfirst_three_elem := my_slice[0:3]\nfmt.Println(\"First 3 elements: \", first_three_elem)\nfmt.Printf(\"my_slice    = len=%d cap=%d %v\\n\", len(my_slice), cap(my_slice), my_slice)\nnone_value := my_slice[:0]\nfmt.Printf(\"none_value  = len=%d cap=%d %v\\n\", len(none_value), cap(none_value), none_value)\nfirst_four := my_slice[:4]\nfmt.Printf(\"first_four  = len=%d cap=%d %v\\n\", len(first_four), cap(first_four), first_four)\nskip_two_first := my_slice[2:]\nfmt.Printf(\"last_two    = len=%d cap=%d %v\\n\", len(skip_two_first), cap(skip_two_first), skip_two_first)\nmy_slice = append(my_slice, 70)\nfmt.Println(\"my_slice with 70: \", my_slice)\nfmt.Printf(\"my_slice    = len=%d cap=%d %v\\n\", len(my_slice), cap(my_slice), my_slice)\n}\n</code></pre> output<pre><code>Full slice:  [10 20 30 40 50 60]\nFirst 3 elements:  [10 20 30]\nmy_slice        = len=6 cap=6 [10 20 30 40 50 60]\nnone_value      = len=0 cap=6 []\nfirst_four      = len=4 cap=6 [10 20 30 40]\nlast_two        = len=4 cap=4 [30 40 50 60]\nmy_slice with 70:  [10 20 30 40 50 60 70]\nmy_slice        = len=7 cap=12 [10 20 30 40 50 60 70]\n</code></pre></p> <p>Warning</p> <p>Remember that slices are based on arrays, so they can change in size dynamically. <code>If the underlying array runs out of capacity, a new larger array is allocated, and the data is copied over</code>. When added 70 in the example aboce, notice that the <code>slice's capacity increases to 12 instead of 7</code>. This happens because Go, when it needs to increase capacity, <code>doubles the original size</code>. Doubling the capacity of the underlying array allows for more elements to be added in the future without frequent reallocations. <code>In the case of very large slices, this can consume more memory than necessary</code>. So, when you anticipate working with a large slice, it's a <code>good practice to initialize the slice with a size closer to the maximum you expect to use to minimize unnecessary memory consumption</code>.</p>"},{"location":"basics/vars/#maps","title":"Maps","text":"<p>Maps in Go are a versatile data structure used to store <code>key-value pairs</code>. They are <code>similar to dictionaries or hash tables</code> in other programming languages. A key feature of maps is their ability to provide fast and efficient lookups for values based on their associated keys.</p> <p>Remember that maps are <code>reference types</code>, so when you pass a map to a function or assign it to another variable, you're working with a reference to the same underlying data structure.</p> Example <p>run command<pre><code>go run variables/maps.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nempty_map := map[string]int{}\nfmt.Println(empty_map)\nempty_make := make(map[string]int)\nfmt.Println(empty_make)\nmap_works_salary := map[string]int{\"Gabriel\": 100, \"Renato Augusto\": 3000}\nmap_works_salary[\"Cassio\"] = 3000\ngabriel_salary := map_works_salary[\"Gabriel\"]\nfmt.Printf(\"Init map_works_salary: %v\\n\", map_works_salary)\nfmt.Printf(\"Gabriel salary: %v\\n\", gabriel_salary)\nvalue, exists := map_works_salary[\"Yuri Alberto\"]\nif exists {\nfmt.Printf(\"Yuri Alberto salary: %v\\n\", value)\n} else {\nmap_works_salary[\"Yuri Alberto\"] = 3000\nyuri_salary := map_works_salary[\"Yuri Alberto\"]\nfmt.Printf(\"Yuri Alberto salary: %v\\n\", yuri_salary)\n}\ndelete(map_works_salary, \"Gabriel\")\nfmt.Printf(\"After delete Gabriel: %v\\n\\n\", map_works_salary)\nfor key, value := range map_works_salary {\nfmt.Printf(\"Player: %v, Salaray: %d\\n\", key, value)\n}\n}\n</code></pre> output<pre><code>map[]\nmap[]\nInit map_works_salary: map[Cassio:3000 Gabriel:100 Renato Augusto:3000]\nGabriel salary: 100\nYuri Alberto salary: 3000\nAfter delete Gabriel: map[Cassio:3000 Renato Augusto:3000 Yuri Alberto:3000]\nPlayer: Renato Augusto, Salaray: 3000\nPlayer: Cassio, Salaray: 3000\nPlayer: Yuri Alberto, Salaray: 3000\n</code></pre></p>"}]}