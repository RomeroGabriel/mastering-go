{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Mastering Go","text":"<p>Gi Studies Wiki: A centralized repository offering a wealth of resources and insights for mastering Go programming.</p> <p>A particular but not private repository to centralize all studies about Go and a few famous Go's libraries. It's kind my own documentation about the language. </p>"},{"location":"#references","title":"References","text":"<p>The following is a list of materials utilized for studying and creating this documentation:</p> <ul> <li>Go Expert - FullCycle</li> </ul> <p>*and of course chatGPT </p>"},{"location":"basics/go_cli/","title":"Go CLI","text":""},{"location":"basics/go_cli/#go-environment-command","title":"Go Environment Command","text":"<p>Lists all Go <code>environment variables</code>.</p> <pre><code>go env\n</code></pre> go env output <pre><code>GO111MODULE=''\nGOARCH='amd64'\nGOBIN=''\nGOCACHE='/home/gabriel/.cache/go-build'\nGOENV='/home/gabriel/.config/go/env'\nGOEXE=''\nGOEXPERIMENT=''\nGOFLAGS=''\nGOHOSTARCH='amd64'\nGOHOSTOS='linux'\nGOINSECURE=''\nGOMODCACHE='/home/gabriel/go/pkg/mod'\nGONOPROXY=''\nGONOSUMDB=''\nGOOS='linux'\nGOPATH='/home/gabriel/go'\nGOPRIVATE=''\nGOPROXY='https://proxy.golang.org,direct'\nGOROOT='/usr/local/go'\nGOSUMDB='sum.golang.org'\nGOTMPDIR=''\nGOTOOLCHAIN='auto'\nGOTOOLDIR='/usr/local/go/pkg/tool/linux_amd64'\nGOVCS=''\nGOVERSION='go1.21.1'\nGCCGO='gccgo'\nGOAMD64='v1'\nAR='ar'\nCC='gcc'\nCXX='g++'\nCGO_ENABLED='1'\nGOMOD='/dev/null'\nGOWORK=''\nCGO_CFLAGS='-O2 -g'\nCGO_CPPFLAGS=''\nCGO_CXXFLAGS='-O2 -g'\nCGO_FFLAGS='-O2 -g'\nCGO_LDFLAGS='-O2 -g'\nPKG_CONFIG='pkg-config'\nGOGCCFLAGS='-fPIC -m64 -pthread -Wl,--no-gc-sections -fmessage-length=0 -ffile-prefix-map=/tmp/go-build4097433368=/tmp/go-build -gno-record-gcc-switches'\n</code></pre>"},{"location":"basics/go_cli/#gopath","title":"GOPATH","text":"<p><code>GOPATH</code> is a variable that <code>defines the root of your workspace</code>. It stores your code base and all the files necessary for your development. <code>It also contains the binaries of your compilations and the libraries used.</code></p>"},{"location":"basics/go_cli/#gomodcache","title":"GOMODCACHE","text":"<p><code>GOMODCACHE</code> is related to <code>Go module management</code>, which is used for handling dependencies. It is <code>typically a subfolder within your GOPATH</code>.</p>"},{"location":"basics/go_paradigm/","title":"Go's Paradigms","text":"<p>Go aims to be both simple and powerful, with the goal of enhancing programmers' productivity. <code>It boasts a straightforward and consistent syntax that remains stable across versions, ensuring compatibility</code>. One of Go's standout features is its robust support for concurrency. <code>It is designed to efficiently leverage multicore processors and excel in handling network-related tasks</code>. In terms of typing, <code>Go follows a static and strong typing system</code>. Here are some key aspects of Go's paradigms and its way of work:</p> <ol> <li>Concurrent and Structured Programming;</li> <li>Static and Strong Typing;</li> </ol>"},{"location":"basics/packages/","title":"Packages","text":"<p>Every <code>.go file begins with the package command</code>, and the <code>package's name should match the directory in which the file resides</code>. The exceptions to this rule are 'package main' and 'package test,' which serve as the entry points for applications and tests, respectively. <code>Packages within the same directory should share the same package name. Anything within the same package can be accessed and utilized</code>.</p> <p>Simple package example</p> <p>run command<pre><code>go run src/packages/*\n</code></pre> src/packages/nice_func.go<pre><code>package main\nfunc nice_func() {\nprintln(\"   I'm on the same directory than main, so my package has to be main\")\n}\n</code></pre> src/packages/main.go<pre><code>package main\nfunc main() {\nprintln(\"Starting script\")\nprintln(\"Now, calling nice_func that is defined from the same file directory, on nice_func.go file\")\nnice_func()\n}\n</code></pre> output<pre><code>Starting script\nNow, calling nice_func that is defined from the same file directory, on nice_func.go file\n    I'm on the same directory than main, so my package has to be main\n</code></pre></p>"},{"location":"basics/packages/#references","title":"References","text":"<ul> <li>Go Expert - FullCycle</li> </ul>"},{"location":"basics/vars/","title":"Variables and Data Types","text":"<p>In Go, <code>variables and constants are strongly typed</code>. To declare a constant, you use the <code>const</code> keyword, and for variables, you use <code>var</code>.</p> <p>Go can also <code>automatically infer variable types</code>, providing various syntaxes for declaring variables and constants, as shown below.</p> Simple vars example <p>run command<pre><code>go run src/variables/*\n</code></pre> <pre><code>package main\nconst A = \"I'm a constant\"\nvar B bool\nfunc main() {\nprintln(\"Starting basic variables\")\nprint(\"Print A const: \")\nprintln(A)\nprint(\"Print B var: \")\nprintln(B)\nprintln(\"NOTICE: B was infer as false\")\nprintln()\nprintln(\"Different ways to declare a variable: \")\nvar full_declare string = \"A\"\nprintln(\"Full declaration: \" + full_declare)\nshort_hand := \"B\"\nprintln(\"Short hand: \" + short_hand)\n}\n</code></pre> output<pre><code>Starting basic variables\nPrint A const: I'm a constant\nPrint B var: false\nNOTICE: B was infer as false\nDifferent ways to declare a variable:\nFull declaration: A\nShort hand: B\n</code></pre></p> Checking Default Infered Types <p>run command<pre><code>go run variables/infer_types.go </code></pre> <pre><code>package main\nvar (\nb  bool\nc  int\nd  string\ne  float32\ne6 float64\n)\nfunc main() {\nprint(\"bool \")\nprintln(b)\nprint(\"int \")\nprintln(c)\nprint(\"string \")\nprintln(d)\nprint(\"float32 \")\nprintln(e)\nprint(\"float64 \")\nprintln(e6)\n}\n</code></pre> output<pre><code>bool false\nint 0\nstring float32 +0.000000e+000\nfloat64 +0.000000e+000\n</code></pre></p>"},{"location":"basics/vars/#using-type","title":"Using type","text":"<p>In Go the <code>type</code> keyword is used to <code>define custom data types</code>. These custom types can be based on existing types, making it a versatile feature in the language.</p> Using type <p>run command<pre><code>go run variables/using_type.go\n</code></pre> <pre><code>package main\ntype custom_id string\nfunc main() {\ncustom_id := \"e96d759e-dc59-4394-9feb-79c8bf4130c9\"\nprintln(\"custom_id value: \" + custom_id)\n}\n</code></pre> output<pre><code>custom_id value: e96d759e-dc59-4394-9feb-79c8bf4130c9\n</code></pre></p>"},{"location":"basics/vars/#arrays","title":"Arrays","text":"<p>In Go, an array is a <code>fixed-size collection of elements of the same type</code>. Arrays are declared with a specific size, and that <code>size cannot be changed after the array is created</code>.</p> Example <p>run command<pre><code>go run variables/arrays.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvar myArray [3]int\nmyArray[1] = 10\nmyArray[2] = 20\nfmt.Println(myArray[0])\nfmt.Println(myArray)\nfor i, value := range myArray {\nfmt.Printf(\"Value stored in %d index is %d\\n\", i, value)\n}\ninitArray := [3]string{\"apple\", \"banana\", \"cherry\"}\nfor i, value := range initArray {\nfmt.Printf(\"Value stored in %d index is %v\\n\", i, value)\n}\n}\n</code></pre> output<pre><code>0\n[0 10 20]\nValue stored in 0 index is 0\nValue stored in 1 index is 10\nValue stored in 2 index is 20\nValue stored in 0 index is apple\nValue stored in 1 index is banana\nValue stored in 2 index is cherry\n</code></pre></p>"},{"location":"basics/vars/#slices","title":"Slices","text":"<p>In Go, a slice is a <code>more versatile and dynamic alternative to arrays</code>. Slices are like views into an underlying array, allowing you to work with a portion of an a<code>rray without specifying a fixed size</code>. Slices allow you to perform operations like appending elements, slicing (creating sub-slices), and growing dynamically.</p> <p>Slices also have a <code>length and capacity</code> (the maximum number of elements it can hold without reallocation). Use the <code>len()</code> and <code>cap()</code> functions to get these values.</p> Example <p>run command<pre><code>go run variables/slices.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nmy_slice := []int{10, 20, 30, 40, 50, 60}\nfmt.Println(\"Full slice: \", my_slice)\nfirst_three_elem := my_slice[0:3]\nfmt.Println(\"First 3 elements: \", first_three_elem)\nfmt.Printf(\"my_slice    = len=%d cap=%d %v\\n\", len(my_slice), cap(my_slice), my_slice)\nnone_value := my_slice[:0]\nfmt.Printf(\"none_value  = len=%d cap=%d %v\\n\", len(none_value), cap(none_value), none_value)\nfirst_four := my_slice[:4]\nfmt.Printf(\"first_four  = len=%d cap=%d %v\\n\", len(first_four), cap(first_four), first_four)\nskip_two_first := my_slice[2:]\nfmt.Printf(\"last_two    = len=%d cap=%d %v\\n\", len(skip_two_first), cap(skip_two_first), skip_two_first)\nmy_slice = append(my_slice, 70)\nfmt.Println(\"my_slice with 70: \", my_slice)\nfmt.Printf(\"my_slice    = len=%d cap=%d %v\\n\", len(my_slice), cap(my_slice), my_slice)\n}\n</code></pre> output<pre><code>Full slice:  [10 20 30 40 50 60]\nFirst 3 elements:  [10 20 30]\nmy_slice        = len=6 cap=6 [10 20 30 40 50 60]\nnone_value      = len=0 cap=6 []\nfirst_four      = len=4 cap=6 [10 20 30 40]\nlast_two        = len=4 cap=4 [30 40 50 60]\nmy_slice with 70:  [10 20 30 40 50 60 70]\nmy_slice        = len=7 cap=12 [10 20 30 40 50 60 70]\n</code></pre></p> <p>Warning</p> <p>Remember that slices are based on arrays, so they can change in size dynamically. <code>If the underlying array runs out of capacity, a new larger array is allocated, and the data is copied over</code>. When added 70 in the example aboce, notice that the <code>slice's capacity increases to 12 instead of 7</code>. This happens because Go, when it needs to increase capacity, <code>doubles the original size</code>. Doubling the capacity of the underlying array allows for more elements to be added in the future without frequent reallocations. <code>In the case of very large slices, this can consume more memory than necessary</code>. So, when you anticipate working with a large slice, it's a <code>good practice to initialize the slice with a size closer to the maximum you expect to use to minimize unnecessary memory consumption</code>.</p>"},{"location":"basics/vars/#maps","title":"Maps","text":"<p>Maps in Go are a versatile data structure used to store <code>key-value pairs</code>. They are <code>similar to dictionaries or hash tables</code> in other programming languages. A key feature of maps is their ability to provide fast and efficient lookups for values based on their associated keys.</p> <p>Remember that maps are <code>reference types</code>, so when you pass a map to a function or assign it to another variable, you're working with a reference to the same underlying data structure.</p> Example <p>run command<pre><code>go run variables/maps.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nempty_map := map[string]int{}\nfmt.Println(empty_map)\nempty_make := make(map[string]int)\nfmt.Println(empty_make)\nmap_works_salary := map[string]int{\"Gabriel\": 100, \"Renato Augusto\": 3000}\nmap_works_salary[\"Cassio\"] = 3000\ngabriel_salary := map_works_salary[\"Gabriel\"]\nfmt.Printf(\"Init map_works_salary: %v\\n\", map_works_salary)\nfmt.Printf(\"Gabriel salary: %v\\n\", gabriel_salary)\nvalue, exists := map_works_salary[\"Yuri Alberto\"]\nif exists {\nfmt.Printf(\"Yuri Alberto salary: %v\\n\", value)\n} else {\nmap_works_salary[\"Yuri Alberto\"] = 3000\nyuri_salary := map_works_salary[\"Yuri Alberto\"]\nfmt.Printf(\"Yuri Alberto salary: %v\\n\", yuri_salary)\n}\ndelete(map_works_salary, \"Gabriel\")\nfmt.Printf(\"After delete Gabriel: %v\\n\\n\", map_works_salary)\nfor key, value := range map_works_salary {\nfmt.Printf(\"Player: %v, Salaray: %d\\n\", key, value)\n}\n}\n</code></pre> output<pre><code>map[]\nmap[]\nInit map_works_salary: map[Cassio:3000 Gabriel:100 Renato Augusto:3000]\nGabriel salary: 100\nYuri Alberto salary: 3000\nAfter delete Gabriel: map[Cassio:3000 Renato Augusto:3000 Yuri Alberto:3000]\nPlayer: Renato Augusto, Salaray: 3000\nPlayer: Cassio, Salaray: 3000\nPlayer: Yuri Alberto, Salaray: 3000\n</code></pre></p>"},{"location":"functions/","title":"Functions","text":""},{"location":"functions/#definition-and-arguments","title":"Definition and Arguments","text":"<p>The <code>func</code> keyword introduces a function definition, followed by the function name and a list of formal parameters enclosed in parentheses. Functions can take zero or more parameters. Parameters are declared with their type. <code>When function parameters share the same type, you can declare the type once for all of them</code>.</p> Example <p>run command<pre><code>go run function/basic.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nprint_double(6)\nsum_result := sum(7, 3)\nfmt.Printf(\"sum_result is: %d\\n\", sum_result)\n}\nfunc print_double(double int) {\nresult := double * 2\nfmt.Printf(\"Double of %d: %d\\n\", double, result)\n}\nfunc sum(num1, num2 int) int {\nreturn num1 + num2\n}\n</code></pre> output<pre><code>Double of 6: 12\nsum_result is: 10\n</code></pre></p>"},{"location":"functions/#variadic-functions","title":"Variadic Functions","text":"<p>Go allows you to define <code>functions that can accept a variable number of arguments</code>. You use the <code>...</code> notation before the type of the last parameter</p> Example <p>run command<pre><code>go run function/func_variadic.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc sum(numbers ...int) int {\ntotal := 0\nfor _, num := range numbers {\ntotal += num\n}\nreturn total\n}\nfunc main() {\nresult := sum(1, 2, 3, 4, 5, 6, 7, 8, 9)\nfmt.Printf(\"Result %d\\n\", result)\n}\n</code></pre> output<pre><code>Result 45\n</code></pre></p>"},{"location":"functions/#return","title":"Return","text":"<p>Functions in Go can indeed <code>return multiple values</code>. When a function is called, it can produce multiple results. <code>Functions can declare named return values</code>, which act as variables. This can make the code more readable by specifying what the function is returning.</p> Example <p>run command<pre><code>go run function/return.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nresult, is_even := sum_check_even(1, 2)\nfmt.Printf(\"result is: %d\\n\", result)\nif is_even {\nfmt.Printf(\"result is even!!!\\n\")\n}\nresult, is_even = sum_check_even(2, 2)\nfmt.Printf(\"result is: %d\\n\", result)\nif is_even {\nfmt.Printf(\"result is even!!!\\n\")\n}\n}\nfunc sum_check_even(num1, num2 int) (result int, is_even bool) {\nresult = num1 + num2\nis_even = result%2 == 0\nreturn\n}\n</code></pre> output<pre><code>result is: 3\nresult1 is: 4\nresult1 is even!!!\n</code></pre></p>"},{"location":"functions/#error-handling","title":"Error Handling","text":"<p>In Go, error handling differs significantly from languages that use try/catch blocks. <code>Go intentionally does not have try/catch mechanisms because it encourages a different approach to handling errors</code>. Instead, functions in Go often <code>return multiple values, where the last value is typically an error</code>.</p> Example <p>run command<pre><code>go run function/return_error.go\n</code></pre> <pre><code>package main\nimport (\n\"errors\"\n\"fmt\"\n)\nfunc divide(a, b float64) (float64, error) {\nif b == 0 {\nreturn 0, errors.New(\"division by zero\")\n}\nreturn a / b, nil\n}\nfunc main() {\nresult, err := divide(10, 2)\nif err != nil {\nfmt.Println(\"Error:\", err)\n} else {\nfmt.Println(\"Result:\", result)\n}\nresult, err = divide(10, 0)\nif err != nil {\nfmt.Println(\"Error:\", err)\n} else {\nfmt.Println(\"Result:\", result)\n}\n}\n</code></pre> output<pre><code>Result: 5\nError: division by zero\n</code></pre></p>"},{"location":"functions/#anonymous-functions-closures","title":"Anonymous Functions (Closures)","text":"<p>Go supports anonymous functions, <code>which can be assigned to variables or passed as arguments</code> to other functions. <code>They can capture and use variables from their surrounding scope</code>.</p> Example <p>run command<pre><code>go run function/closures.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nadd := func(a, b int) int {\nreturn a + b\n}\nresult1 := add(2, 4)\nfmt.Printf(\"result1 %d\\n\", result1)\nresult1 = add(3, 4)\nfmt.Printf(\"result1 %d\\n\", result1)\nresult1 = add(4, 4)\nfmt.Printf(\"result1 %d\\n\", result1)\n}\n</code></pre> output<pre><code>result1 6\nresult1 7\nresult1 8\n</code></pre></p>"},{"location":"structs/interface/","title":"Interface","text":"<p>In Go, interfaces are a powerful and flexible way to <code>define sets of methods that types must implement</code>. <code>They allow you to write functions and methods that can work with various types, as long as those types satisfy the interface contract</code>. Interfaces support methods but <code>not properties or fields</code>.</p> <p>To declare an interface, <code>you list the method signatures that types must implement</code>. <code>Any type that has methods matching these signatures implicitly implements the interface</code>. To implement an interface, <code>a type needs to provide method implementations that match the method signatures in the interface</code>. If a type has all the required methods, <code>it implicitly satisfies the interface</code>. Interfaces <code>promote polymorphism and decoupling of code</code>.</p> Example <p>run command<pre><code>go run structs/interfaces.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Shape interface {\nArea() float64\n}\ntype Circle struct {\nRadius float64\n}\nfunc (c Circle) Area() float64 {\nreturn 3.14 * c.Radius * c.Radius\n}\ntype Rectangle struct {\nWidth  float64\nHeight float64\n}\nfunc (r Rectangle) Area() float64 {\nreturn r.Width * r.Height\n}\nfunc printArea(s Shape) {\narea := s.Area()\nfmt.Printf(\"Area: %.2f\\n\", area)\n}\nfunc main() {\nc := Circle{Radius: 5.0}\nr := Rectangle{Width: 4.0, Height: 6.0}\nprintArea(c)\nprintArea(r)\n}\n</code></pre> output<pre><code>Area: 78.50\nArea: 24.00\n</code></pre></p>"},{"location":"structs/structs/","title":"Structs","text":"<p>In Go, <code>structs are composite data types used to group together variables (fields) under a single data structure</code>. They are similar to classes in other languages, but <code>Go doesn't have classes in the traditional sense</code>.</p> <p>You define a struct using the <code>type</code> keyword, followed by the <code>name of the struct</code> and a set of field declarations within curly braces. To <code>create an instance</code> of a struct, you can use the <code>struct's name followed by curly braces and provide values for its fields</code>.</p> Example <p>run command<pre><code>go run structs/basic.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Person struct {\nName string\nAge  int\n}\nfunc main() {\nperson := Person{\nName: \"Gabriel\",\nAge:  100,\n}\nfmt.Printf(\"Create object person, from Person struct: %v\\n\", person)\n}\n</code></pre> output<pre><code>Create object person, from Person struct: {Gabriel 100}\n</code></pre></p>"},{"location":"structs/structs/#anonymous-structs","title":"Anonymous Structs","text":"<p>Anonymous Structs are structs without a defined name, often used for <code>temporary data structures</code>.</p> Example <p>run command<pre><code>go run structs/anonymous.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\nfunc main() {\nvector := struct {\nX int\nY int\n}{\nX: 10,\nY: 20,\n}\nfmt.Printf(\"Create object from an anonymous structs : %v\\n\", vector)\nfmt.Printf(\"X : %v\\n\", vector.X)\nfmt.Printf(\"Y : %v\\n\", vector.Y)\n}\n</code></pre> output<pre><code>Create object from an anonymous structs : {10 20}\nX : 10\nY : 20\n</code></pre></p>"},{"location":"structs/structs/#composing-structs","title":"Composing Structs","text":"<p>In Go, you can <code>embed one struct within another</code>, creating a composition of structs. This is <code>similar to inheritance</code> in other languages.</p> Example <p>run command<pre><code>go run structs/composing.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Team struct {\nTeamName string\n}\ntype Person struct {\nName string\nAge  int\nTeam\nPersonTeam Team\n}\nfunc main() {\nperson := Person{\nName:       \"Gabriel\",\nAge:        100,\nTeam:       Team{\"Corinthians\"},\nPersonTeam: Team{\"Knicks\"},\n}\nfmt.Printf(\"Person: %v\\n\", person)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.Team)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.Team.TeamName)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.TeamName)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.PersonTeam)\nfmt.Printf(\"Person name: %v, Clube: %v\\n\", person.Name, person.TeamName)\n}\n</code></pre> output<pre><code>Person: {Gabriel 100 {Corinthians} {Knicks}}\nPerson name: Gabriel, Clube: {Corinthians}\nPerson name: Gabriel, Clube: Corinthians\nPerson name: Gabriel, Clube: Corinthians\nPerson name: Gabriel, Clube: {Knicks}\nPerson name: Gabriel, Clube: Corinthians\n</code></pre></p> Composing x Property, and Accessing Properties <p>In the given example, it's evident that the <code>Person struct is composed of a Team</code> and <code>has a property named PersonTeam of type Team</code>. The key distinction here is that when using the abbreviation <code>person.TeamName</code>, it returns the value of the composition, not the property. In Go, <code>you can directly access the properties of a composed struct</code>.</p>"},{"location":"structs/structs/#struct-methods","title":"Struct Methods","text":"<p>In Go, <code>structs can have methods associated with them</code>. These methods are <code>functions that operate on instances of the struct</code>, and they enable you to define behavior specific to the struct type.</p> Example <p>run command<pre><code>go run structs/methods.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Circle struct {\nRadius float64\n}\nfunc (c Circle) Area() float64 {\nreturn 3.14 * c.Radius * c.Radius\n}\nfunc main() {\ncircle := Circle{Radius: 5.0}\narea := circle.Area()\nfmt.Printf(\"Area: %v\\n\", area)\n}\n</code></pre> output<pre><code>Area: 78.5\n</code></pre></p>"},{"location":"structs/structs/#pointer-receivers","title":"Pointer Receivers","text":"<p><code>Pointer receivers can modify the state of the struct directly</code>. Using a pointer receiver allows you to <code>change the state</code> of an instance directly.</p> Example <p>run command<pre><code>go run structs/methods_pointer.go\n</code></pre> <pre><code>package main\nimport \"fmt\"\ntype Circle struct {\nRadius float64\n}\nfunc (c Circle) NormalArea() float64 {\nresult := 3.14 * c.Radius * c.Radius\nc.Radius = 100\nreturn result\n}\nfunc (c *Circle) PointerArea() float64 {\nresult := 3.14 * c.Radius * c.Radius\nc.Radius = 100\nreturn result\n}\nfunc main() {\ncircle := Circle{Radius: 5.0}\narea := circle.NormalArea()\nfmt.Printf(\"Area: %v\\n\", area)\nfmt.Printf(\"Circle change? %v\\n\", circle)\narea = circle.PointerArea()\nfmt.Printf(\"Area: %v\\n\", area)\nfmt.Printf(\"Circle change? %v\\n\", circle)\n}\n</code></pre> output<pre><code>Area: 78.5\nCircle change? {5}\nArea: 78.5\nCircle change? {100}\n</code></pre></p>"}]}